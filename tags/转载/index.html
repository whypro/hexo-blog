<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>Tag: 转载 - 格里莫广场12号</title><link rel="manifest" href="/hexo-blog/manifest.json"><meta name="application-name" content="格里莫广场12号"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="格里莫广场12号"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="格里莫广场12号"><meta property="og:url" content="http://whypro.github.io/hexo-blog"><meta property="og:site_name" content="格里莫广场12号"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://whypro.github.io/hexo-blog/img/og_image.png"><meta property="article:author" content="whypro"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/hexo-blog/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://whypro.github.io/hexo-blog"},"headline":"格里莫广场12号","image":["http://whypro.github.io/hexo-blog/img/og_image.png"],"author":{"@type":"Person","name":"whypro"},"publisher":{"@type":"Organization","name":"格里莫广场12号","logo":{"@type":"ImageObject","url":"http://whypro.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/hexo-blog/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/hexo-blog/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?17e1c6a0010d7be7e49ae6d2c2e7b817";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/hexo-blog/"><img src="/hexo-blog/img/logo.svg" alt="格里莫广场12号" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/hexo-blog/">Home</a><a class="navbar-item" href="/hexo-blog/archives">Archives</a><a class="navbar-item" href="/hexo-blog/categories">Categories</a><a class="navbar-item" href="/hexo-blog/tags">Tags</a><a class="navbar-item" href="/hexo-blog/about.html">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/whypro"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/hexo-blog/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">转载</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time datetime="2018-01-10T14:01:52.000Z" title="1/10/2018, 2:01:52 PM">2018-01-10</time></span><span class="level-item">Updated&nbsp;<time datetime="2019-06-02T09:10:11.000Z" title="6/2/2019, 9:10:11 AM">2019-06-02</time></span><span class="level-item">2 hours read (About 14663 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo-blog/2018/01/10/%E4%BB%8E%E5%A4%B4%E7%BC%96%E5%86%99%E4%B8%80%E6%AC%BE%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E5%BA%93/">从头编写一款时间序列数据库</a></h1><div class="content"><blockquote><p>本文转自 <a target="_blank" rel="noopener" href="http://dockone.io/article/2300">从头编写一款时间序列数据库</a> （翻译：Colstuwjx），请支持原作者。</p></blockquote><p>我从事监控方面的工作。尤其是专注在 <a target="_blank" rel="noopener" href="https://prometheus.io/">Prometheus</a>，一款内置了自己定制的时间序列数据库的监控系统，以及它和 <a target="_blank" rel="noopener" href="https://kubernetes.io/">Kubernetes</a> 的集成工作。</p><p>从很多方面来说，Kubernetes 表现出了一切 Prometheus 专门设计的东西。它使得持续部署，自动扩缩，以及高度动态环境的其他功能更易于实现。它的查询语言和操作模型，还有许多其他概念方面的决策使得 Prometheus 尤其适合这样的环境。然而，如果被监控的工作负载变得更加显著动态的话，这也会给监控系统本身带来新的压力。基于这一点的考虑，与其再次回顾 Prometheus 已经很好解决的问题，还不如专注于在这样一个高度动态或短生命周期服务的环境里提高它的性能。</p><p>Prometheus 的存储层在历史上有着惊人的性能表现，一个单台服务器每秒可以摄取多达 100 万个采样，数百万个时间序列，同时仅占用令人惊叹的少量磁盘空间。尽管当前的存储已经给我们提供了不错的服务，笔者构思了一个新设计的存储子系统用来纠正现有解决方案的一些短板，并且可以用来配备支撑下一代的集群规模。</p></div><a class="article-more button is-small is-size-7" href="/hexo-blog/2018/01/10/%E4%BB%8E%E5%A4%B4%E7%BC%96%E5%86%99%E4%B8%80%E6%AC%BE%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E5%BA%93/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time datetime="2016-09-09T16:45:13.000Z" title="9/9/2016, 4:45:13 PM">2016-09-10</time></span><span class="level-item">Updated&nbsp;<time datetime="2019-07-04T03:44:51.000Z" title="7/4/2019, 3:44:51 AM">2019-07-04</time></span><span class="level-item">18 minutes read (About 2628 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo-blog/2016/09/09/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E4%B8%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E4%B9%8B%E6%AF%94%E8%BE%83/">引用计数与垃圾收集之比较</a></h1><div class="content"><blockquote><p>原文地址：<a target="_blank" rel="noopener" href="http://blog.codingnow.com/2008/06/gc.html">http://blog.codingnow.com/2008/06/gc.html</a></p></blockquote><p>本质上来说，引用计数策略和垃圾收集策略都属于资源的自动化管理。所谓自动化管理，就是在逻辑层不知道资源在什么时候被释放掉，而依赖底层库来维持资源的生命期。</p><p>而手工管理，则是可以准确的知道资源的生命期，在准确的位置回收它。在 C++ 中，体现在析构函数中写明 delete 用到的资源，并由编译器自动生成的代码析构基类和成员变量。</p><p>所以，为 C++ 写一个垃圾收集器，并不和手工管理资源冲突。自动化管理几乎在所有有点规模的 C++ 工程中都在使用，只不过用的是引用计数的策略而非垃圾收集而已。也就是说，我们使用 C++ 或 C 长期以来就是结合了手工管理和自动管理在构建系统了。无论用引用计数，还是用垃圾收集，软件实现的细节上，该手工管理的地方我们依旧可以手工管理。</p><p>为什么要用资源生命期自动管理？</p></div><a class="article-more button is-small is-size-7" href="/hexo-blog/2016/09/09/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E4%B8%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E4%B9%8B%E6%AF%94%E8%BE%83/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time datetime="2016-09-08T16:30:33.000Z" title="9/8/2016, 4:30:33 PM">2016-09-09</time></span><span class="level-item">Updated&nbsp;<time datetime="2021-07-25T15:26:06.761Z" title="7/25/2021, 3:26:06 PM">2021-07-25</time></span><span class="level-item">18 minutes read (About 2680 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo-blog/2016/09/08/Makefile%20%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/">Makefile 简易教程</a></h1><div class="content"><h2 id="Makefile-简介"><a href="#Makefile-简介" class="headerlink" title="Makefile 简介"></a>Makefile 简介</h2><p>在软件开发中，make通常被视为一种软件构建工具。该工具主要经由读取一种名为“makefile”或“Makefile”的文件来实现软件的自动化建构。它会通过一种被称之为“target”概念来检查相关文件之间的依赖关系，这种依赖关系的检查系统非常简单，主要通过对比文件的修改时间来实现。在大多数情况下，我们主要用它来编译源代码，生成结果代码，然后把结果代码连接起来生成可执行文件或者库文件。</p><h2 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h2><p>与大多数古老的Unix工具一样，make也分别有着人数众多的拥护者和反对者。它在适应现代大型软件项目方面有着许许多多的问题。但是，依然有很多人坚定地认为（包括我）它能应付绝大多数常见的情况，而且使用非常的简单，功能强大，表达清楚。无论如何，make如今仍然被用来编译很多完整的操作系统，而且它的那些“更为现代”的替代品们在基本操作上与它没有太大差别。</p><p>当然，随着现代的集成开发环境（IDE）的诞生，特别是非Unix的平台上，很多程序员不再手动管理依靠关系检查，甚至不用去管哪些文件是这个项目的一部分，而是把这些任务交给了他们的开发环境去做。类似的，很多现代的编程语言有自己专属的、能高效配置依赖关系的方法（譬如Ant）。</p><h3 id="主要版本"><a href="#主要版本" class="headerlink" title="主要版本"></a>主要版本</h3><p>make程序经历过各方多次的改写与重写，各方都依据自己的需要做了一些特定的改良。目前市面上主要流行有以下几种版本：</p><ul><li><p>GNU make： GNU make对make的标准功能（通过clean-room工程）进行了重新改写，并加入作者自认为值得加入的新功能，常和GNU编译系统一起被使用，是大多数GNU Linux默认安装的工具。</p></li><li><p>BSD make： 该版本是从Adam de Boor制作的版本上发展起来的。它在编译目标的时有并发计算的能力。主要应用于FreeBSD，NetBSD和OpenBSD这些系统。</p></li><li><p>Microsoft nmake： 该版本主要用于微软的Windows系统中，需要注意的是，微软的nmake与Unix项目中的nmake是两种不同的东西，千万不要混淆。</p></li></ul><h3 id="从一个简单的例子开始"><a href="#从一个简单的例子开始" class="headerlink" title="从一个简单的例子开始"></a>从一个简单的例子开始</h3><p>我们可以用K&amp;R C中4.5那个例子来做个说明。在这个例子中，我们会看到一份主程序代码 <code>main.c</code>、三份函数代码 <code>getop.c</code>、<code>stack.c</code>、<code>getch.c</code>以及一个头文件 <code>calc.h</code>。通常情况下，我们需要这样编译它：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o calc main.c getch.c getop.c stack.c </span><br></pre></td></tr></table></figure><p>如果没有makefile，在开发+调试程序的过程中，我们就需要不断地重复输入上面这条编译命令，要不就是通过终端的历史功能不停地按上下键来寻找最近执行过的命令。这样做两个缺陷：</p><p>一旦终端历史记录被丢失，我们就不得不从头开始；</p><p>任何时候只要我们修改了其中一个文件，上述编译命令就会重新编译所有的文件，当文件足够多时这样的编译会非常耗时。</p><p>那么 Makefile 又能做什么呢？我们先来看一个最简单的 <code>makefile</code> 文件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">calc: main.c getch.c getop.c stack.c</span></span><br><span class="line">    gcc -o calc main.c getch.c getop.c stack.c </span><br></pre></td></tr></table></figure><p>现在你看到的就是一个最基本的Makefile语句，它主要分成了三个部分，第一行冒号之前的 <code>calc</code>，我们称之为目标（target），被认为是这条语句所要处理的对象，具体到这里就是我们所要编译的这个程序 <code>calc</code>。冒号后面的部分（main.c getch.c getop.c stack.c），我们称之为依赖关系表，也就是编译calc所需要的文件，这些文件只要有一个发生了变化，就会触发该语句的第三部分，我们称其为命令部分，相信你也看得出这就是一条编译命令。现在我们只要将上面这两行语句写入一个名为Makefile或者makefile的文件，然后在终端中输入make命令，就会看到它按照我们的设定去编译程序了。</p><blockquote><p>请注意，在第二行的“gcc”命令之前必须要有一个tab缩进。语法规定Makefile中的任何命令之前都必须要有一个tab缩进，否则make就会报错。</p></blockquote><p>接下来，让我们来解决一下效率方面的问题，先初步修改一下上面的代码：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cc = gcc</span><br><span class="line">prom = calc</span><br><span class="line">source = main.c getch.c getop.c stack.c</span><br><span class="line"></span><br><span class="line"><span class="variable">$(prom)</span>: <span class="variable">$(source)</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$(prom)</span> <span class="variable">$(source)</span></span><br></pre></td></tr></table></figure><p>如你所见，我们在上述代码中定义了三个常量 <code>cc</code>、<code>prom</code> 以及 <code>source</code>。它们分别告诉了make我们要使用的编译器、要编译的目标以及源文件。这样一来，今后我们要修改这三者中的任何一项，只需要修改常量的定义即可，而不用再去管后面的代码部分了。</p><blockquote><p><del>请注意，很多教程将这里的 <code>cc</code>、<code>prom</code> 和 <code>source</code> 称之为变量，个人认为这是不妥当的，因为它们在整个文件的执行过程中并不是可更改的，作用也仅仅是字符串替换而已，非常类似于C语言中的宏定义。或者说，事实上它就是一个宏。</del></p></blockquote><p>但我们现在依然还是没能解决当我们只修改一个文件时就要全部重新编译的问题。而且如果我们修改的是 <code>calc.h</code> 文件，make就无法察觉到变化了（所以有必要为头文件专门设置一个常量，并将其加入到依赖关系表中）。下面，我们来想一想如何解决这个问题。考虑到在标准的编译过程中，源文件往往是先被编译成目标文件，然后再由目标文件连接成可执行文件的。我们可以利用这一点来调整一下这些文件之间的依赖关系：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cc = gcc</span><br><span class="line">prom = calc</span><br><span class="line">deps = calc.h</span><br><span class="line">obj = main.o getch.o getop.o stack.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(prom)</span>: <span class="variable">$(obj)</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$(prom)</span> <span class="variable">$(obj)</span></span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c <span class="variable">$(deps)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> -c main.c</span><br><span class="line"></span><br><span class="line"><span class="section">getch.o: getch.c <span class="variable">$(deps)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> -c getch.c</span><br><span class="line"></span><br><span class="line"><span class="section">getop.o: getop.c <span class="variable">$(deps)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> -c getop.c</span><br><span class="line"></span><br><span class="line"><span class="section">stack.o: stack.c <span class="variable">$(deps)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> -c stack.c      </span><br></pre></td></tr></table></figure><p>这样一来，上面的问题显然是解决了，但同时我们又让代码变得非常啰嗦，啰嗦往往伴随着低效率，是不祥之兆。经过再度观察，我们发现所有.c都会被编译成相同名称的 <code>.o</code> 文件。我们可以根据该特点再对其做进一步的简化：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cc = gcc</span><br><span class="line">prom = calc</span><br><span class="line">deps = calc.h</span><br><span class="line">obj = main.o getch.o getop.o stack.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(prom)</span>: <span class="variable">$(obj)</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$(prom)</span> <span class="variable">$(obj)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c <span class="variable">$(deps)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>在这里，我们用到了几个特殊的宏。首先是 <code>%.o:%.c</code>，这是一个模式规则，表示所有的.o目标都依赖于与它同名的 <code>.c</code> 文件（当然还有deps中列出的头文件）。再来就是命令部分的 <code>$&lt;</code> 和 <code>$@</code>，其中$&lt;代表的是依赖关系表中的第一项（如果我们想引用的是整个关系表，那么就应该使用 <code>$^</code>），具体到我们这里就是%.c。而$@代表的是当前语句的目标，即 <code>%.o</code>。这样一来，make命令就会自动将所有的 <code>.c</code> 源文件编译成同名的 <code>.o</code> 文件。不用我们一项一项去指定了。整个代码自然简洁了许多。</p><p>到目前为止，我们已经有了一个不错的makefile，至少用来维护这个小型工程是没有什么问题了。当然，如果要进一步增加上面这个项目的可扩展性，我们就会需要用到一些Makefile中的伪目标和函数规则了。例如，如果我们想增加自动清理编译结果的功能就可以为其定义一个带伪目标的规则；</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cc = gcc</span><br><span class="line">prom = calc</span><br><span class="line">deps = calc.h</span><br><span class="line">obj = main.o getch.o getop.o stack.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(prom)</span>: <span class="variable">$(obj)</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$(prom)</span> <span class="variable">$(obj)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c <span class="variable">$(deps)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf <span class="variable">$(obj)</span> <span class="variable">$(prom)</span></span><br></pre></td></tr></table></figure><p>有了上面最后两行代码，当我们在终端中执行 <code>make clean</code> 命令时，它就会去删除该工程生成的所有编译文件。</p><p>另外，如果我们需要往工程中添加一个 <code>.c</code> 或 <code>.h</code>，可能同时就要再手动为 <code>obj</code> 常量再添加第一个 <code>.o</code> 文件，如果这列表很长，代码会非常难看，为此，我们需要用到Makefile中的函数，这里我们演示两个：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cc = gcc</span><br><span class="line">prom = calc</span><br><span class="line">deps = <span class="variable">$(<span class="built_in">shell</span> find ./ -name &quot;*.h&quot;)</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">shell</span> find ./ -name &quot;*.c&quot;)</span></span><br><span class="line">obj = $(src:%.c=%.o) </span><br><span class="line"></span><br><span class="line"><span class="variable">$(prom)</span>: <span class="variable">$(obj)</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$(prom)</span> <span class="variable">$(obj)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c <span class="variable">$(deps)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf <span class="variable">$(obj)</span> <span class="variable">$(prom)</span></span><br></pre></td></tr></table></figure><p>其中，<code>shell</code> 函数主要用于执行shell命令，具体到这里就是找出当前目录下所有的 <code>.c</code> 和 <code>.h</code> 文件。而 <code>$(src:%.c=%.o)</code> 则是一个字符替换函数，它会将 <code>src</code> 所有的 <code>.c</code> 字串替换成 <code>.o</code>，实际上就等于列出了所有 <code>.c</code> 文件要编译的结果。有了这两个设定，无论我们今后在该工程加入多少 <code>.c</code> 和 <code>.h</code> 文件，Makefile都能自动将其纳入到工程中来。</p><p>到这里，我们就基本上将日常会用到的Makefile写法介绍了一遍。如果你想了解更多关于makefile和make的知识，请参考 <a target="_blank" rel="noopener" href="http://www.cs.utexas.edu/~cannata/cs345/GNU%20Make%20Manual.pdf">GNU Make Manual</a>。</p><hr><p>原文地址：<a target="_blank" rel="noopener" href="http://www.epubit.com.cn/article/546">http://www.epubit.com.cn/article/546</a></p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time datetime="2016-09-08T16:30:30.000Z" title="9/8/2016, 4:30:30 PM">2016-09-09</time></span><span class="level-item">Updated&nbsp;<time datetime="2019-07-04T03:44:51.000Z" title="7/4/2019, 3:44:51 AM">2019-07-04</time></span><span class="level-item">29 minutes read (About 4361 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo-blog/2016/09/08/%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8E%86%E5%8F%B2%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%92%8C%E6%9C%AA%E6%9D%A5/">协程的历史，现在和未来</a></h1><div class="content"><blockquote><p>原文地址：<a target="_blank" rel="noopener" href="http://blog.youxu.info/2014/12/04/coroutine/">http://blog.youxu.info/2014/12/04/coroutine/</a></p></blockquote><p>本文原发于《程序员》2014年11月刊，发表时略有修改。</p><p>计算机科学是一门应用科学，几乎所有概念都是为了理解或解决实际问题而生的。协程 (Coroutine) 的出现也不例外。协程的概念，最早可以追溯到写作 COBOL 语言编译器中的技术难题。</p></div><a class="article-more button is-small is-size-7" href="/hexo-blog/2016/09/08/%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8E%86%E5%8F%B2%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%92%8C%E6%9C%AA%E6%9D%A5/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time datetime="2016-09-08T16:30:27.000Z" title="9/8/2016, 4:30:27 PM">2016-09-09</time></span><span class="level-item">Updated&nbsp;<time datetime="2019-07-04T03:44:51.000Z" title="7/4/2019, 3:44:51 AM">2019-07-04</time></span><span class="level-item">11 minutes read (About 1600 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo-blog/2016/09/08/IO-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9AReactor-%E5%92%8C-Proactor-%E5%AF%B9%E6%AF%94/">IO 设计模式：Reactor 和 Proactor 对比</a></h1><div class="content"><blockquote><p>原文地址：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000002715832">https://segmentfault.com/a/1190000002715832</a><br>Posted by: 大CC | 28APR,2015<br>博客：<a target="_blank" rel="noopener" href="http://blog.me115.com/">blog.me115.com</a> [<a target="_blank" rel="noopener" href="http://feed.feedsky.com/me115">订阅</a>]<br>微博：<a target="_blank" rel="noopener" href="http://weibo.com/bigcc115">新浪微博</a></p></blockquote><p>平时接触的开源产品如Redis、ACE，事件模型都使用的Reactor模式；而同样做事件处理的Proactor，由于操作系统的原因，相关的开源产品也少；这里学习下其模型结构，重点对比下两者的异同点；</p><h2 id="反应器Reactor"><a href="#反应器Reactor" class="headerlink" title="反应器Reactor"></a>反应器Reactor</h2><h3 id="Reactor模式结构"><a href="#Reactor模式结构" class="headerlink" title="Reactor模式结构"></a>Reactor模式结构</h3></div><a class="article-more button is-small is-size-7" href="/hexo-blog/2016/09/08/IO-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9AReactor-%E5%92%8C-Proactor-%E5%AF%B9%E6%AF%94/#more">Read more</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time datetime="2016-09-08T16:30:23.000Z" title="9/8/2016, 4:30:23 PM">2016-09-09</time></span><span class="level-item">Updated&nbsp;<time datetime="2021-07-25T15:22:07.081Z" title="7/25/2021, 3:22:07 PM">2021-07-25</time></span><span class="level-item">24 minutes read (About 3667 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo-blog/2016/09/08/%E5%A6%82%E4%BD%95%E5%9C%A8%20Git%20%E9%87%8C%E6%92%A4%E9%94%80%EF%BC%88%E5%87%A0%E4%B9%8E%EF%BC%89%E4%BB%BB%E4%BD%95%E6%93%8D%E4%BD%9C/">如何在 Git 里撤销（几乎）任何操作</a></h1><div class="content"><p>任何版本控制系统的一个最有的用特性就是“撤销 (undo)”你的错误操作的能力。在 Git 里，“撤销” 蕴含了不少略有差别的功能。</p><p>当你进行一次新的提交的时候，Git 会保存你代码库在那个特定时间点的快照；之后，你可以利用 Git 返回到你的项目的一个早期版本。</p><p>在本篇博文里，我会讲解某些你需要“撤销”已做出的修改的常见场景，以及利用 Git 进行这些操作的最佳方法。</p><h2 id="撤销一个“已公开”的改变"><a href="#撤销一个“已公开”的改变" class="headerlink" title="撤销一个“已公开”的改变"></a>撤销一个“已公开”的改变</h2><p><strong>场景：</strong> 你已经执行了 <code>git push</code>, 把你的修改发送到了 GitHub，现在你意识到这些 <code>commit</code> 的其中一个是有问题的，你需要撤销那一个 <code>commit</code>.</p><p><strong>方法：</strong> <code>git revert &lt;SHA&gt;</code></p><p><strong>原理：</strong> <code>git revert</code> 会产生一个新的 <code>commit</code>，它和指定 <code>SHA</code> 对应的 <code>commit</code> 是相反的（或者说是反转的）。如果原先的 <code>commit</code> 是“物质”，新的 <code>commit</code> 就是“反物质” — 任何从原先的 <code>commit</code> 里删除的内容会在新的 <code>commit</code> 里被加回去，任何在原先的 <code>commit</code> 里加入的内容会在新的 <code>commit</code> 里被删除。</p><p>这是 Git 最安全、最基本的撤销场景，因为它并不会改变历史 — 所以你现在可以 <code>git push</code> 新的“反转” <code>commit</code> 来抵消你错误提交的 <code>commit</code>。</p><h2 id="修正最后一个-commit-消息"><a href="#修正最后一个-commit-消息" class="headerlink" title="修正最后一个 commit 消息"></a>修正最后一个 commit 消息</h2><p><strong>场景：</strong> 你在最后一条 <code>commit</code> 消息里有个笔误，已经执行了 <code>git commit -m &quot;Fxies bug #42&quot;</code>，但在 <code>git push</code> 之前你意识到消息应该是 <code>&quot;Fixes bug #42&quot;</code>。</p><p><strong>方法：</strong> <code>git commit --amend</code> 或 <code>git commit --amend -m &quot;Fixes bug #42&quot;</code></p><p><strong>原理：</strong> <code>git commit --amend</code> 会用一个新的 <code>commit</code> 更新并替换最近的 <code>commit</code> ，这个新的 <code>commit</code> 会把任何修改内容和上一个 <code>commit</code> 的内容结合起来。如果当前没有提出任何修改，这个操作就只会把上次的 <code>commit</code> 消息重写一遍。</p><h2 id="撤销“本地的”修改"><a href="#撤销“本地的”修改" class="headerlink" title="撤销“本地的”修改"></a>撤销“本地的”修改</h2><p><strong>场景：</strong> 一只猫从键盘上走过，无意中保存了修改，然后破坏了编辑器。不过，你还没有 <code>commit</code> 这些修改。你想要恢复被修改文件里的所有内容 — 就像上次 <code>commit</code> 的时候一模一样。</p><p><strong>方法：</strong> <code>git checkout -- &lt;bad filename&gt;</code></p><p><strong>原理：</strong> <code>git checkout</code> 会把工作目录里的文件修改到 Git 之前记录的某个状态。你可以提供一个你想返回的分支名或特定 <code>SHA</code> ，或者在缺省情况下，Git 会认为你希望 <code>checkout</code> 的是 <code>HEAD</code>，当前 <code>checkout</code> 分支的最后一次 <code>commit</code>。</p><p>记住： 你用这种方法“撤销”的任何修改真的会完全消失。因为它们从来没有被提交过，所以之后 Git 也无法帮助我们恢复它们。你要确保自己了解你在这个操作里扔掉的东西是什么！（也许可以先利用 <code>git diff</code> 确认一下）</p><h2 id="重置“本地的”修改"><a href="#重置“本地的”修改" class="headerlink" title="重置“本地的”修改"></a>重置“本地的”修改</h2><p><strong>场景：</strong> 你在本地提交了一些东西（还没有 push），但是所有这些东西都很糟糕，你希望撤销前面的三次提交 — 就像它们从来没有发生过一样。</p><p><strong>方法：</strong> <code>git reset &lt;last good SHA&gt;</code> 或 <code>git reset --hard &lt;last good SHA&gt;</code></p><p><strong>原理：</strong> <code>git reset</code> 会把你的代码库历史返回到指定的 <code>SHA</code> 状态。 这样就像是这些提交从来没有发生过。缺省情况下，<code>git reset</code> 会保留工作目录。这样，提交是没有了，但是修改内容还在磁盘上。这是一种安全的选择，但通常我们会希望一步就“撤销”提交以及修改内容 — 这就是 <code>--hard</code> 选项的功能。</p><h2 id="在撤销“本地修改”之后再恢复"><a href="#在撤销“本地修改”之后再恢复" class="headerlink" title="在撤销“本地修改”之后再恢复"></a>在撤销“本地修改”之后再恢复</h2><p><strong>场景：</strong> 你提交了几个 <code>commit</code>，然后用 <code>git reset --hard</code> 撤销了这些修改（见上一段），接着你又意识到：你希望还原这些修改！</p><p><strong>方法：</strong> <code>git reflog</code> 和 <code>git reset</code> 或 <code>git checkout</code></p><p><strong>原理：</strong> <code>git reflog</code> 对于恢复项目历史是一个超棒的资源。你可以恢复几乎 任何东西 — 任何你 <code>commit</code> 过的东西 — 只要通过 <code>reflog</code>。</p><p>你可能已经熟悉了 <code>git log</code> 命令，它会显示 <code>commit</code> 的列表。<code>git reflog</code> 也是类似的，不过它显示的是一个 <code>HEAD</code> 发生改变的时间列表.</p><p>一些注意事项：</p><ul><li>它涉及的只是 <code>HEAD</code> 的改变。在你切换分支、用 <code>git commit</code> 进行提交、以及用 <code>git reset</code> 撤销 <code>commit</code> 时，<code>HEAD</code> 会改变，但当你用 <code>git checkout -- &lt;bad filename&gt;</code>撤销时（正如我们在前面讲到的情况），<code>HEAD</code> 并不会改变 — 如前所述，这些修改从来没有被提交过，因此 <code>reflog</code> 也无法帮助我们恢复它们。</li><li><code>git reflog</code> 不会永远保持。Git 会定期清理那些 “用不到的” 对象。不要指望几个月前的提交还一直躺在那里。</li><li>你的 <code>reflog</code> 就是你的，只是你的。你不能用 <code>git reflog</code> 来恢复另一个开发者没有 <code>push</code> 过的 <code>commit</code>。</li></ul><p><img src="f6b9f054-d891-11e4-8c53-838eff9f40ae.png" alt="reflog"></p><p>那么…你怎么利用 <code>reflog</code> 来“恢复”之前“撤销”的 <code>commit</code> 呢？它取决于你想做到的到底是什么：</p><ul><li>如果你希望准确地恢复项目的历史到某个时间点，用 <code>git reset --hard &lt;SHA&gt;</code></li><li>如果你希望重建工作目录里的一个或多个文件，让它们恢复到某个时间点的状态，用 <code>git checkout &lt;SHA&gt; -- &lt;filename&gt;</code></li><li>如果你希望把这些 <code>commit</code> 里的某一个重新提交到你的代码库里，用 <code>git cherry-pick &lt;SHA&gt;</code></li></ul><h2 id="利用分支的另一种做法"><a href="#利用分支的另一种做法" class="headerlink" title="利用分支的另一种做法"></a>利用分支的另一种做法</h2><p><strong>场景：</strong> 你进行了一些提交，然后意识到你开始 <code>check out</code> 的是 <code>master</code> 分支。你希望这些提交进到另一个特性（<code>feature</code>）分支里。</p><p><strong>方法：</strong> <code>git branch feature</code>, <code>git reset --hard origin/master</code>, and <code>git checkout feature</code></p><p><strong>原理：</strong> 你可能习惯了用 <code>git checkout -b &lt;name&gt;</code> 创建新的分支 — 这是创建新分支并马上 <code>check out</code> 的流行捷径 — 但是你不希望马上切换分支。这里， <code>git branch feature</code> 创建一个叫做 <code>feature</code> 的新分支并指向你最近的 <code>commit</code>，但还是让你 <code>check out</code> 在 <code>master</code> 分支上。</p><p>下一步，在提交任何新的 <code>commit</code> 之前，用 <code>git reset --hard</code> 把 <code>master</code> 分支倒回 <code>origin/master</code> 。不过别担心，那些 <code>commit</code> 还在 <code>feature</code> 分支里。</p><p>最后，用 <code>git checkout</code> 切换到新的 <code>feature</code> 分支，并且让你最近所有的工作成果都完好无损。</p><h2 id="及时分支，省去繁琐"><a href="#及时分支，省去繁琐" class="headerlink" title="及时分支，省去繁琐"></a>及时分支，省去繁琐</h2><p><strong>场景：</strong> 你在 <code>master</code> 分支的基础上创建了 <code>feature</code> 分支，但 <code>master</code> 分支已经滞后于 <code>origin/master</code> 很多。现在 <code>master</code> 分支已经和 <code>origin/master</code> 同步，你希望在 <code>feature</code> 上的提交是从现在开始，而不是也从滞后很多的地方开始。</p><p><strong>方法：</strong> <code>git checkout feature</code> 和 <code>git rebase master</code></p><p><strong>原理：</strong> 要达到这个效果，你本来可以通过 <code>git reset</code> (不加 <code>--hard</code>, 这样可以在磁盘上保留修改) 和 <code>git checkout -b &lt;new branch name&gt;</code> 然后再重新提交修改，不过这样做的话，你就会失去提交历史。我们有更好的办法。</p><p><code>git rebase master</code> 会做如下的事情：</p><ul><li>首先它会找到你当前 <code>check out</code> 的分支和 <code>master</code> 分支的共同祖先。</li><li>然后它 <code>reset</code> 当前 <code>check out</code> 的分支到那个共同祖先，在一个临时保存区存放所有之前的提交。</li><li>然后它把当前 <code>check out</code> 的分支提到 <code>master</code> 的末尾部分，并从临时保存区重新把存放的 <code>commit</code> 提交到 <code>master</code> 分支的最后一个 <code>commit</code> 之后。</li></ul><h2 id="大量的撤销-恢复"><a href="#大量的撤销-恢复" class="headerlink" title="大量的撤销/恢复"></a>大量的撤销/恢复</h2><p><strong>场景：</strong> 你向某个方向开始实现一个特性，但是半路你意识到另一个方案更好。你已经进行了十几次提交，但你现在只需要其中的一部分。你希望其他不需要的提交统统消失。</p><p><strong>方法：</strong> <code>git rebase -i &lt;earlier SHA&gt;</code></p><p><strong>原理：</strong> <code>-i</code> 参数让 <code>rebase</code> 进入“交互模式”。它开始类似于前面讨论的 <code>rebase</code>，但在重新进行任何提交之前，它会暂停下来并允许你详细地修改每个提交。</p><p><code>rebase -i</code> 会打开你的缺省文本编辑器，里面列出候选的提交。如下所示：</p><p><img src="f6b1ab88-d891-11e4-97c1-e0630ac74e74.png" alt="rebase-interactive1"></p><p>前面两列是键：第一个是选定的命令，对应第二列里的 <code>SHA</code> 确定的 <code>commit</code>。缺省情况下， <code>rebase -i</code> 假定每个 <code>commit</code> 都要通过 <code>pick</code> 命令被运用。</p><p>要丢弃一个 <code>commit</code>，只要在编辑器里删除那一行就行了。如果你不再需要项目里的那几个错误的提交，你可以删除上例中的1、3、4行。</p><p>如果你需要保留 <code>commit</code> 的内容，而是对 <code>commit</code> 消息进行编辑，你可以使用 <code>reword</code> 命令。 把第一列里的 <code>pick</code> 替换为 <code>reword</code> (或者直接用 <code>r</code>)。有人会觉得在这里直接重写 <code>commit</code> 消息就行了，但是这样不管用 <code>rebase -i</code> 会忽略 <code>SHA</code> 列前面的任何东西。它后面的文本只是用来帮助我们记住 <code>0835fe2</code> 是干啥的。当你完成 <code>rebase -i</code> 的操作之后，你会被提示输入需要编写的任何 <code>commit</code> 消息。</p><p>如果你需要把两个 <code>commit</code> 合并到一起，你可以使用 <code>squash</code> 或 <code>fixup</code> 命令，如下所示：</p><p><img src="f6b605ca-d891-11e4-98cf-d567ca9f4edc.png" alt="rebase-interactive2"></p><p><code>squash</code> 和 <code>fixup</code> 会“向上”合并 — 带有这两个命令的 <code>commit</code> 会被合并到它的前一个 <code>commit</code> 里。在这个例子里， <code>0835fe2</code> 和 <code>6943e85</code> 会被合并成一个 <code>commit</code>， <code>38f5e4e</code> 和 <code>af67f82</code> 会被合并成另一个。</p><p>如果你选择了 <code>squash</code>， Git 会提示我们给新合并的 <code>commit</code> 一个新的 <code>commit</code> 消息； <code>fixup</code> 则会把合并清单里第一个 <code>commit</code> 的消息直接给新合并的 <code>commit</code> 。 这里，你知道 <code>af67f82</code> 是一个“完了完了….” 的 <code>commit</code>，所以你会留着 <code>38f5e4e</code> as的 <code>commit</code> 消息，但你会给合并了 <code>0835fe2</code> 和 <code>6943e85</code> 的新 <code>commit</code> 编写一个新的消息。</p><p>在你保存并退出编辑器的时候，Git 会按从顶部到底部的顺序运用你的 <code>commit</code>。你可以通过在保存前修改 <code>commit</code> 顺序来改变运用的顺序。如果你愿意，你也可以通过如下安排把 <code>af67f82</code> 和 <code>0835fe2</code> 合并到一起：</p><p><img src="f6b4a9d2-d891-11e4-9ac9-10039c031d06.png" alt="rebase-interactive3"></p><h2 id="修复更早期的-commit"><a href="#修复更早期的-commit" class="headerlink" title="修复更早期的 commit"></a>修复更早期的 commit</h2><p><strong>场景：</strong> 你在一个更早期的 <code>commit</code> 里忘记了加入一个文件，如果更早的 <code>commit</code> 能包含这个忘记的文件就太棒了。你还没有 <code>push</code>，但这个 <code>commit</code> 不是最近的，所以你没法用 <code>commit --amend</code>.</p><p><strong>方法：</strong> <code>git commit --squash &lt;SHA of the earlier commit&gt;</code> 和 <code>git rebase --autosquash -i &lt;even earlier SHA&gt;</code></p><p><strong>原理：</strong> <code>git commit --squash</code> 会创建一个新的 <code>commit</code> ，它带有一个 <code>commit</code> 消息，类似于 squash! Earlier commit。 (你也可以手工创建一个带有类似 <code>commit</code> 消息的 <code>commit</code>，但是 <code>commit --squash</code> 可以帮你省下输入的工作。)</p><p>如果你不想被提示为新合并的 <code>commit</code> 输入一条新的 <code>commit</code> 消息，你也可以利用 <code>git commit --fixup</code> 。在这个情况下，你很可能会用 <code>commit --fixup</code> ，因为你只是希望在 <code>rebase</code> 的时候使用早期 <code>commit</code> 的 <code>commit</code> 消息。</p><p><code>rebase --autosquash -i</code> 会激活一个交互式的 <code>rebase</code> 编辑器，但是编辑器打开的时候，在 <code>commit</code> 清单里任何 <code>squash</code> 和 <code>fixup</code> 的 <code>commit</code> 都已经配对到目标 <code>commit</code> 上了，如下所示：</p><p><img src="f6a7a1d8-d891-11e4-8784-c32262ff54da.png" alt="rebase-autosquash"></p><p>在使用 <code>--squash</code> 和 <code>--fixup</code> 的时候，你可能不记得想要修正的 <code>commit</code> 的 <code>SHA</code> 了— 只记得它是前面第 1 个或第 5 个 <code>commit</code>。你会发现 Git 的 <code>^</code> 和 <code>~</code> 操作符特别好用。<code>HEAD^</code> 是 <code>HEAD</code> 的前一个 <code>commit</code>。 <code>HEAD~4</code> 是 <code>HEAD</code> 往前第 4 个 – 或者一起算，倒数第 5 个 commit。</p><h2 id="停止追踪一个文件"><a href="#停止追踪一个文件" class="headerlink" title="停止追踪一个文件"></a>停止追踪一个文件</h2><p><strong>场景：</strong> 你偶然把 <code>application.log</code> 加到代码库里了，现在每次你运行应用，Git 都会报告在 <code>application.log</code> 里有未提交的修改。你把 <code>*.login</code> 放到了 <code>.gitignore</code> 文件里，可文件还是在代码库里 — 你怎么才能告诉 Git “撤销” 对这个文件的追踪呢？</p><p><strong>方法：</strong> <code>git rm --cached application.log</code></p><p><strong>原理：</strong> 虽然 <code>.gitignore</code> 会阻止 Git 追踪文件的修改，甚至不关注文件是否存在，但这只是针对那些以前从来没有追踪过的文件。一旦有个文件被加入并提交了，Git 就会持续关注该文件的改变。类似地，如果你利用 <code>git add -f</code> 来强制或覆盖了 <code>.gitignore</code>， Git 还会持续追踪改变的情况。之后你就不必用 <code>-f</code> 来添加这个文件了。</p><p>如果你希望从 Git 的追踪对象中删除那个本应忽略的文件， <code>git rm --cached</code> 会从追踪对象中删除它，但让文件在磁盘上保持原封不动。因为现在它已经被忽略了，你在 <code>git status</code> 里就不会再看见这个文件，也不会再偶然提交该文件的修改了。</p><hr><p>这就是如何在 Git 里撤销任何操作的方法。要了解更多关于本文中用到的 Git 命令，请查看下面的有关文档：</p><ul><li><a target="_blank" rel="noopener" href="http://git-scm.com/docs/git-checkout">checkout</a></li><li><a target="_blank" rel="noopener" href="http://git-scm.com/docs/git-commit">commit</a></li><li><a target="_blank" rel="noopener" href="http://git-scm.com/docs/git-rebase">rebase</a></li><li><a target="_blank" rel="noopener" href="http://git-scm.com/docs/git-reflog">reflog</a></li><li><a target="_blank" rel="noopener" href="http://git-scm.com/docs/git-reset">reset</a></li><li><a target="_blank" rel="noopener" href="http://git-scm.com/docs/git-revert">revert</a></li><li><a target="_blank" rel="noopener" href="http://git-scm.com/docs/git-rm">rm</a></li></ul><hr><p>原文地址：<a target="_blank" rel="noopener" href="https://github.com/blog/2019-how-to-undo-almost-anything-with-git">https://github.com/blog/2019-how-to-undo-almost-anything-with-git</a><br>译文地址：<a target="_blank" rel="noopener" href="http://blog.jobbole.com/87700/">http://blog.jobbole.com/87700/</a></p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time datetime="2016-09-08T16:30:20.000Z" title="9/8/2016, 4:30:20 PM">2016-09-09</time></span><span class="level-item">Updated&nbsp;<time datetime="2021-07-25T15:32:35.052Z" title="7/25/2021, 3:32:35 PM">2021-07-25</time></span><span class="level-item">15 minutes read (About 2261 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo-blog/2016/09/08/mmap%20%E8%AF%A6%E8%A7%A3/">mmap 详解</a></h1><div class="content"><p>共享内存可以说是最有用的进程间通信方式，也是最快的 IPC 形式, 因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据: 一次从输入文件到共享内存区，另一次从共享内存区到输出文件。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。</p><h3 id="一、传统文件访问"><a href="#一、传统文件访问" class="headerlink" title="一、传统文件访问"></a>一、传统文件访问</h3><p>UNIX访问文件的传统方法是用 <code>open</code> 打开它们, 如果有多个进程访问同一个文件，则每一个进程在自己的地址空间都包含有该文件的副本，这不必要地浪费了存储空间。下图说明了两个进程同时读一个文件的同一页的情形。系统要将该页从磁盘读到高速缓冲区中，每个进程再执行一个存储器内的复制操作将数据从高速缓冲区读到自己的地址空间。</p><p><img src="91b3885b-1b16-3a35-90dd-e059090121b8.jpg"></p><h3 id="二、共享存储映射"><a href="#二、共享存储映射" class="headerlink" title="二、共享存储映射"></a>二、共享存储映射</h3><p>现在考虑另一种处理方法：进程 A 和进程 B 都将该页映射到自己的地址空间，当进程 A 第一次访问该页中的数据时，它生成一个缺页中断。内核此时读入这一页到内存并更新页表使之指向它。以后，当进程 B 访问同一页面而出现缺页中断时，该页已经在内存，内核只需要将进程 B 的页表登记项指向次页即可。如下图所示：</p><p><img src="cf6dcb8a-5182-3ecc-bc2d-f1d556cb1a66.jpg"></p><h3 id="三、mmap-及其相关系统调用"><a href="#三、mmap-及其相关系统调用" class="headerlink" title="三、mmap() 及其相关系统调用"></a>三、mmap() 及其相关系统调用</h3><p><code>mmap()</code> 系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以向访<br>问普通内存一样对文件进行访问，不必再调用 <code>read()</code>，<code>write()</code>等操作。</p><p><code>mmap()</code> 系统调用形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mmap</span><span class="params">(<span class="keyword">void</span>* addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span> </span></span><br></pre></td></tr></table></figure><p><code>mmap</code> 的作用是映射文件描述符 <code>fd</code> 指定文件的 <code>[off, off+len]</code> 区域至调用进程的 <code>[addr, addr+len]</code> 的内存区域, 如下图所示:</p><p><img src="fe463a08-18a5-3a75-ab51-6c4c425cb4db.jpg"></p><p>参数 <code>fd</code> 为即将映射到进程空间的文件描述字，一般由 <code>open()</code> 返回，同时，<code>fd</code> 可以指定为 -1，此时须指定 <code>flags</code> 参数中的 <code>MAP_ANON</code>，表明进行的是匿名映射（不涉及具体的文件名，避免了文件的创建及打开，很显然只能用于具有亲缘关系的进程间通信）。<br><code>len</code> 是映射到调用进程地址空间的字节数，它从被映射文件开头 <code>offset</code> 个字节开始算起。<br><code>prot</code> 参数指定共享内存的访问权限。可取如下几个值的或：<code>PROT_READ</code>（可读），<code>PROT_WRITE</code>（可写），<code>PROT_EXEC</code>（可执行），<code>PROT_NONE</code>（不可访问）。<br><code>flags</code> 由以下几个常值指定：<code>MAP_SHARED</code>, <code>MAP_PRIVATE</code>, <code>MAP_FIXED</code>，其中，<code>MAP_SHARED</code>, <code>MAP_PRIVATE</code> 必选其一，而 <code>MAP_FIXED</code> 则不推荐使用。<br><code>offset</code> 参数一般设为 0，表示从文件头开始映射。<br>参数 <code>addr</code> 指定文件应被映射到进程空间的起始地址，一般被指定一个空指针，此时选择起始地址的任务留给内核来完成。函数的返回值为最后文件映射到进程空间的地址，进程可直接操作起始地址为该值的有效地址。</p><h3 id="四、mmap的两个例子"><a href="#四、mmap的两个例子" class="headerlink" title="四、mmap的两个例子"></a>四、mmap的两个例子</h3><p>范例中使用的测试文件 data.txt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aaaaaaaaa</span><br><span class="line">bbbbbbbbb</span><br><span class="line">ccccccccc</span><br><span class="line">ddddddddd</span><br></pre></td></tr></table></figure><ol><li>通过共享映射的方式修改文件</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;error.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, nread, i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *mapped, buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BUF_SIZE; i++) &#123;</span><br><span class="line">        buf[i] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打开文件 */</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(argv[<span class="number">1</span>], O_RDWR)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取文件的属性 */</span></span><br><span class="line">    <span class="keyword">if</span> ((fstat(fd, &amp;sb)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将文件映射至进程的地址空间 */</span></span><br><span class="line">    <span class="keyword">if</span> ((mapped = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, sb.st_size, PROT_READ | </span><br><span class="line">                    PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>)) == (<span class="keyword">void</span> *)<span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 映射完后, 关闭文件也可以操纵内存 */</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, mapped);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 修改一个字符,同步到磁盘文件 */</span></span><br><span class="line">    mapped[<span class="number">20</span>] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> ((msync((<span class="keyword">void</span> *)mapped, sb.st_size, MS_SYNC)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;msync&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 释放存储映射区 */</span></span><br><span class="line">    <span class="keyword">if</span> ((munmap((<span class="keyword">void</span> *)mapped, sb.st_size)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>私有映射无法修改文件</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将文件映射至进程的地址空间 */</span></span><br><span class="line"><span class="keyword">if</span> ((mapped = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, sb.st_size, PROT_READ | </span><br><span class="line">    PROT_WRITE, MAP_PRIVATE, fd, <span class="number">0</span>)) == (<span class="keyword">void</span> *)<span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、使用共享映射实现两个进程之间的通信"><a href="#五、使用共享映射实现两个进程之间的通信" class="headerlink" title="五、使用共享映射实现两个进程之间的通信"></a>五、使用共享映射实现两个进程之间的通信</h3><p>两个程序映射同一个文件到自己的地址空间，进程 A 先运行, 每隔两秒读取映射区域，看是否发生变化。<br>进程 B 后运行，它修改映射区域，然后退出，此时进程 A 能够观察到存储映射区的变化。<br>进程 A 的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;error.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd, nread, i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *mapped, buf[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BUF_SIZE; i++) &#123;</span><br><span class="line">        buf[i] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打开文件 */</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(argv[<span class="number">1</span>], O_RDWR)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取文件的属性 */</span></span><br><span class="line">    <span class="keyword">if</span> ((fstat(fd, &amp;sb)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将文件映射至进程的地址空间 */</span></span><br><span class="line">    <span class="keyword">if</span> ((mapped = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, sb.st_size, PROT_READ | </span><br><span class="line">                    PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>)) == (<span class="keyword">void</span> *)<span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 文件已在内存, 关闭文件也可以操纵内存 */</span></span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 每隔两秒查看存储映射区是否被修改 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, mapped);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进程 B 的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;error.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> fd, nread, i;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span>  </span><br><span class="line">    <span class="keyword">char</span> *mapped, buf[BUF_SIZE];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BUF_SIZE; i++) &#123;  </span><br><span class="line">        buf[i] = <span class="string">&#x27;#&#x27;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 打开文件 */</span>  </span><br><span class="line">    <span class="keyword">if</span> ((fd = open(argv[<span class="number">1</span>], O_RDWR)) &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 获取文件的属性 */</span>  </span><br><span class="line">    <span class="keyword">if</span> ((fstat(fd, &amp;sb)) == <span class="number">-1</span>) &#123;  </span><br><span class="line">        perror(<span class="string">&quot;fstat&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 私有文件映射将无法修改文件 */</span>  </span><br><span class="line">    <span class="keyword">if</span> ((mapped = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, sb.st_size, PROT_READ |   </span><br><span class="line">                    PROT_WRITE, MAP_PRIVATE, fd, <span class="number">0</span>)) == (<span class="keyword">void</span> *)<span class="number">-1</span>) &#123;  </span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 映射完后, 关闭文件也可以操纵内存 */</span>  </span><br><span class="line">    close(fd);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 修改一个字符 */</span>  </span><br><span class="line">    mapped[<span class="number">20</span>] = <span class="string">&#x27;9&#x27;</span>;  </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、通过匿名映射实现父子进程通信"><a href="#六、通过匿名映射实现父子进程通信" class="headerlink" title="六、通过匿名映射实现父子进程通信"></a>六、通过匿名映射实现父子进程通信</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>    *p_map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 匿名映射,创建一块内存供父子进程通信 */</span></span><br><span class="line">    p_map = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, BUF_SIZE, PROT_READ | PROT_WRITE,</span><br><span class="line">            MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child got a message: %s\n&quot;</span>, p_map);</span><br><span class="line">        <span class="built_in">sprintf</span>(p_map, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;hi, dad, this is son&quot;</span>);</span><br><span class="line">        munmap(p_map, BUF_SIZE); <span class="comment">//实际上，进程终止时，会自动解除映射。</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(p_map, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;hi, this is father&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent got a message: %s\n&quot;</span>, p_map);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、对-mmap-返回地址的访问"><a href="#七、对-mmap-返回地址的访问" class="headerlink" title="七、对 mmap() 返回地址的访问"></a>七、对 mmap() 返回地址的访问</h3><p>linux 采用的是页式管理机制。对于用 <code>mmap()</code> 映射普通文件来说，进程会在自己的地址空间新增一块空间，空间大小由 <code>mmap()</code> 的 <code>len</code> 参数指定，注意，进程并不一定能够对全部新增空间都能进行有效访问。进程能够访问的有效地址大小取决于文件被映射部分的大小。简单的说，能够容纳文件被映射部分大小的最少页面个数决定了进程从 <code>mmap()</code> 返回的地址开始，能够有效访问的地址空间大小。超过这个空间大小，内核会根据超过的严重程度返回发送不同的信号给进程。可用如下图示说明：</p><p><img src="1be9f93e-d964-3b32-b0ff-611329940295.gif"></p><p>总结一下就是，文件大小，<code>mmap</code> 的参数 <code>len</code> 都不能决定进程能访问的大小，而是容纳文件被映射部分的最小页面数决定进程能访问的大小。下面看一个实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd,i;</span><br><span class="line">    <span class="keyword">int</span> pagesize,offset;</span><br><span class="line">    <span class="keyword">char</span> *p_map;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 取得page size */</span></span><br><span class="line">    pagesize = sysconf(_SC_PAGESIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pagesize is %d\n&quot;</span>,pagesize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打开文件 */</span></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDWR, <span class="number">00777</span>);</span><br><span class="line">    fstat(fd, &amp;sb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;file size is %zd\n&quot;</span>, (<span class="keyword">size_t</span>)sb.st_size);</span><br><span class="line"></span><br><span class="line">    offset = <span class="number">0</span>;    </span><br><span class="line">    p_map = (<span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>, pagesize * <span class="number">2</span>, PROT_READ|PROT_WRITE, </span><br><span class="line">            MAP_SHARED, fd, offset);</span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    p_map[sb.st_size] = <span class="string">&#x27;9&#x27;</span>;  <span class="comment">/* 导致总线错误 */</span></span><br><span class="line">    p_map[pagesize] = <span class="string">&#x27;9&#x27;</span>;    <span class="comment">/* 导致段错误 */</span></span><br><span class="line"></span><br><span class="line">    munmap(p_map, pagesize * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>原文地址：<a target="_blank" rel="noopener" href="http://kenby.iteye.com/blog/1164700">http://kenby.iteye.com/blog/1164700</a></p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time datetime="2016-09-08T16:30:15.000Z" title="9/8/2016, 4:30:15 PM">2016-09-09</time></span><span class="level-item">Updated&nbsp;<time datetime="2021-07-25T15:35:17.498Z" title="7/25/2021, 3:35:17 PM">2021-07-25</time></span><span class="level-item">7 minutes read (About 997 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo-blog/2016/09/08/%E6%B5%85%E6%98%BE%E7%90%86%E8%A7%A3%20Python%20%E9%97%AD%E5%8C%85/">浅显理解 Python 闭包</a></h1><div class="content"><p>闭包这个概念在 JavaScript 中讨论和使用得比较多，不过在 Python 中却不是那么显而易见，之所以说“不是那么”，是因为即使用到了，也没用注意到而已，比如定义一个 Decorator 时，就已经用到闭包了。网上对闭包的各种解释，感觉非常晦涩，在这里谈谈我的浅显认识：要形成闭包，首先得有一个嵌套的函数，即函数中定义了另一个函数，闭包则是一个集合，它包括了外部函数的局部变量，这些局部变量在外部函数返回后也继续存在，并能被内部函数引用。</p><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>这是个经常使用到的例子，定义一个函数 <code>generate_power_func</code>，它返回另一个函数，现在闭包形成的条件已经达到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_power_func</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;id(n): %X&quot;</span> % <span class="built_in">id</span>(n)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nth_power</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> x**n</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;id(nth_power): %X&quot;</span> % <span class="built_in">id</span>(nth_power)</span><br><span class="line">    <span class="keyword">return</span> nth_power</span><br></pre></td></tr></table></figure><p>对于内部函数 <code>nth_power</code>，它能引用到外部函数的局部变量 <code>n</code>，而且即使 <code>generate_power_func</code> 已经返回。把这种现象就称为闭包。具体使用一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>raised_to_4 = generate_power_func(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">id</span>(n): 246F770</span><br><span class="line"><span class="built_in">id</span>(nth_power): 2C090C8</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(raised_to_4)</span><br><span class="line"><span class="string">&#x27;&lt;function nth_power at 0x2c090c8&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>从结果可以看出，当 <code>generate_power_func(4)</code> 执行后, 创建和返回了 <code>nth_power</code> 这个函数对象，内存地址是 <code>0x2C090C8</code>,并且发现 <code>raised_to_4</code> 和它的内存地址相同，即 <code>raised_to_4</code> 只是这个函数对象的一个引用。先在全局命名空间中删除 <code>generate_power_func</code>，再试试会出现什么结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> generate_power_func</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>raised_to_4(<span class="number">2</span>)</span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><p>啊哈，居然没出现错误， <code>nth_power</code> 是怎么知道 <code>n</code> 的值是 <code>4</code>，而且现在 <code>generate_power_func</code> 甚至都不在这个命名空间了。对，这就是闭包的作用，外部函数的局部变量可以被内部函数引用，即使外部函数已经返回了。</p><h2 id="closure-属性和-cell-对象"><a href="#closure-属性和-cell-对象" class="headerlink" title="closure 属性和 cell 对象"></a><strong>closure</strong> 属性和 cell 对象</h2><p>现在知道闭包是怎么一回事了，那就到看看闭包到底是怎么回事的时候了。Python 中函数也是对象，所以函数也有很多属性，和闭包相关的就是 <code>__closure__</code> 属性。<code>__closure__</code> 属性定义的是一个包含 <code>cell</code> 对象的元组，其中元组中的每一个 <code>cell</code> 对象用来保存作用域中变量的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>raised_to_4.__closure__</span><br><span class="line">(&lt;cell at <span class="number">0x2bf4ec0</span>: <span class="built_in">int</span> <span class="built_in">object</span> at <span class="number">0x246f770</span>&gt;,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(raised_to_4.__closure__[<span class="number">0</span>])</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;cell&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>raised_to_4.__closure__[<span class="number">0</span>].cell_contents</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>就如刚才所说，在 <code>raised_to_4</code> 的 <code>__closure__</code> 属性中有外部函数变量 <code>n</code> 的引用，通过内存地址可以发现，引用的都是同一个 <code>n</code>。如果没用形成闭包，则 <code>__closure__</code> 属性为 <code>None</code>。对于 Python 具体是如何实现闭包的，可以查看 <a target="_blank" rel="noopener" href="http://www.cnblogs.com/ChrisChen3121/p/3208119.html">Python闭包详解</a>，它通过分析 Python 字节码来讲述闭包的实现。</p><h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h2><p>闭包特性有着非常多的作用，不过都是需要时才会不经意的用上，不要像使用设计模式一样去硬套这些法则。这篇文章按照自己的理解翻译至 <a target="_blank" rel="noopener" href="http://www.shutupandship.com/2012/01/python-closures-explained.html">Python Closures Explained</a>，可能和原文有些不同之处，如有疑惑，请查看原文。附上一些参考资料。</p><ol><li><a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/linux/l-cn-closure/">闭包的概念、形式与应用</a>: 可以从其中了解闭包的应用</li><li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/ChrisChen3121/p/3208119.html">Python闭包详解</a>：从字节码出发了解 Python 闭包的实现机制</li><li><a target="_blank" rel="noopener" href="http://coolshell.cn/articles/6731.html">理解Javascript的闭包</a>: 从 Javascript 的闭包中了解一些闭包特性，可以和 Python 作下对比</li></ol><hr><p>原文地址：<a target="_blank" rel="noopener" href="https://serholiu.com/python-closures">https://serholiu.com/python-closures</a></p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time datetime="2015-06-06T14:32:00.000Z" title="6/6/2015, 2:32:00 PM">2015-06-06</time></span><span class="level-item">Updated&nbsp;<time datetime="2021-07-25T15:04:46.870Z" title="7/25/2021, 3:04:46 PM">2021-07-25</time></span><span class="level-item">33 minutes read (About 4882 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo-blog/2015/06/06/%E5%88%A9%E7%94%A8%E5%9B%BE%E7%89%87%E6%8C%87%E7%BA%B9%E6%A3%80%E6%B5%8B%E9%AB%98%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%9B%BE%E7%89%87/">利用图片指纹检测高相似度图片</a></h1><div class="content"><p><img src="image_fingerprint_flow.jpg"></p><p>大概五年前吧，我那时还在为一家约会网站做开发工作。他们是早期创业公司，但他们也开始拥有了一些稳定用户量。不像其他约会网站，这家公司向来以洁身自好为主要市场形象。它不是一个供你鬼混的网站——是让你能找到忠实伴侣的地方。</p><p>由于投入了数以百万计的风险资本（在US大萧条之前），他们关于真爱并找寻灵魂伴侣的在线广告势如破竹。Forbes(福布斯，美国著名财经杂志)采访了他们。全国性电视节目也对他们进行了专访。早期的成功促成了事业起步时让人垂涎的指数级增长现象——他们的用户数量以每月加倍的速度增长。对他们而言，一切都似乎顺风顺水。</p><p>但他们有一个严重的问题——<strong>色情问题</strong>。</p><p>该约会网站的用户中会有一些人上传色情图片，然后设置为其个人头像。这种行为破坏了很多其他用户的体验——导致很多用户取消了会员。</p><p>可能对于现在的一些约会网站随处可见几张色情图片也许并不能称之为是问题。或者可以说是习以为常甚至有些期待，只是一个被接受然后被无视的在线约会的副产品。</p><p>然而，这样的行为既不应该被接受也应该被忽视。</p><p>别忘了，这次创业可是将自己定位在优秀的约会天堂，免于用户受到困扰其他约会网站的污秽和垃圾的烦扰。简而言之，他们拥有很实在的<strong>以风险资本作为背后支撑的名声</strong>，而这也正是他们需要保持的风格。</p><p>该约会网站为了能迅速阻止色情图片的爆发可以说是不顾一切了。他们雇佣了图片论坛版主团队，真是不做其他事只是每天盯着监管页面8个小时以上，然后移除任何被上传到社交网络的色情图片。</p><p>毫不夸张的说，他们投入了数万美元（更不用说数不清的人工小时）来解决这个问题，然而也仅仅只是缓解，控制情况不变严重而不是在源头上阻止。</p><p>色情图片的爆发在2009年的七月达到了临界水平。8个月来第一次用户量没能翻倍（甚至已经开始减少了）。更糟糕的是，投资者声称若该公司不能解决这个问题将会撤资。事实上，污秽的潮汐早已开始冲击这座象牙塔了，将它推翻流入大海也不过是时间问题。</p><p>正在这个约会网站巨头快要撑不住时，我提出了一个更鲁棒的长期解决方案：<strong>如果我们使用图片指纹来与色情图片的爆发斗争呢？</strong></p><p>你看，每张图片都有一个指纹。正如人的指纹可以识别人，图片的指纹能识别图片。</p><p>这促使了一个三阶段算法的实现：</p><ol><li><p>为不雅图片建立指纹，然后将图片指纹存储在一个数据库中。</p></li><li><p>当一个用户上传一份新的头像时，我们会将它与数据库中的图片指纹对比。如果上传图片的指纹与数据库任意一个不雅图片指纹相符，我们就阻止用户将该图片设置为个人头像。</p></li><li><p>当图片监管人标记新的色情图片时，这些图片也被赋予指纹并存入我们的数据库，建立一个能用于阻止非法上传且不断进化的数据库。</p></li></ol><p>我们的方法，尽管不十分完美，但是也卓有成效。慢慢地，色情图片爆发的情况有所减慢。它永远不会消失——但这个算法让我们成功将非法上传的数量减少了**80%**以上。</p><p>这也挽回了投资者的心。他们继续为我们提供资金支持——直到萧条到来，我们都失业了。</p><p>回顾过去时，我不禁笑了。我的工作并没持续太久。这个公司也没有坚持太久。甚至还有几个投资者卷铺盖走人了。</p><p>但有一样确实存活了下来。提取图片指纹的算法。几年之后，我把这个算法的基本内容分享出来，期望你们可以将它应用到你们自己的项目中。</p><p>但最大的问题是，我们怎么才能建立图片指纹呢？</p><p>继续读下去一探究竟吧。</p><h2 id="即将要做的事情"><a href="#即将要做的事情" class="headerlink" title="即将要做的事情"></a>即将要做的事情</h2><p>我们打算用图片指纹进行相似图片的检测。这种技术通常被称为“感知图像hash”或是简单的“图片hash”。</p><h2 id="什么是图片指纹-图片哈希"><a href="#什么是图片指纹-图片哈希" class="headerlink" title="什么是图片指纹/图片哈希"></a>什么是图片指纹/图片哈希</h2><p>图片hash是检测一张图片的内容然后根据检测的内容为图片建立一个唯一值的过程。</p><p>比如，看看本文最上面的那张图片。给定一张图片作为输入，应用一个hash函数，然后基于图片的视觉计算出一个图片hash。相似的图片也应当有相似的hash值。图片hash算法的应用使得相似图片的检测变得相当简单了。</p><p>特别地，我们将会使用“差别Hash”或简单的DHash算法计算图片指纹。简单来说，DHash算法着眼于两个相邻像素之间的差值。然后，基于这样的差值，就建立起一个hash值了。</p><h2 id="为什么不使用md5-sha-1等算法？"><a href="#为什么不使用md5-sha-1等算法？" class="headerlink" title="为什么不使用md5,sha-1等算法？"></a>为什么不使用md5,sha-1等算法？</h2><p>不幸的是，我们不能在实现中使用加密hash算法。由于加密hash算法的本质使然，输入文件中非常微小的差别也能造成差异极大的hash值。而在图片指纹的案例中，我们实际上希望相似的输入可以有相似的hash输出值。</p><h2 id="图片指纹可以用在哪里？"><a href="#图片指纹可以用在哪里？" class="headerlink" title="图片指纹可以用在哪里？"></a>图片指纹可以用在哪里？</h2><p>正如我上面举的例子，你可以使用图片指纹来维护一个保存不雅图片的数据库——当用户尝试上传类似图片时可以发出警告。</p><p>你可以建立一个图片的逆向搜索引擎，比如TinEye，它可以记录图片以及它们出现的相关网页。</p><p>你还可以使用图片指纹帮助管理你个人的照片收集。假设你有一个硬盘，上面有你照片库的一些局部备份，但需要一个方法删除局部备份，一张图片仅保留一份唯一的备份——图片指纹可以帮你做到。</p><p>简单来说，你几乎可以将图片指纹/哈希用于任何需要你检测图片的相似副本的场景中。</p><h2 id="需要的库有哪些？"><a href="#需要的库有哪些？" class="headerlink" title="需要的库有哪些？"></a>需要的库有哪些？</h2><p>为了建立图片指纹方案，我们打算使用三个主要的Python包：</p><ul><li><a target="_blank" rel="noopener" href="https://pillow.readthedocs.org/">PIL / Pillow</a>用于读取和载入图片</li><li><a target="_blank" rel="noopener" href="https://pypi.python.org/pypi/ImageHash">ImageHash</a>，包括DHash的实现</li><li>以及 <a target="_blank" rel="noopener" href="http://www.numpy.org/">NumPy</a>/ <a target="_blank" rel="noopener" href="http://www.scipy.org/">SciPy</a>，ImageHash的依赖包</li></ul><p>你可以使用下列命令一键安装所需要的必备库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install pillow imagehash</span><br></pre></td></tr></table></figure><h2 id="第一步：为一个图片集建立指纹"><a href="#第一步：为一个图片集建立指纹" class="headerlink" title="第一步：为一个图片集建立指纹"></a>第一步：为一个图片集建立指纹</h2><p>第一步就是为我们的图片集建立指纹。</p><p>也许你会问，但我们不会，我们不会使用那些我为那家约会网站工作时的色情图片。相反，我创建了一个可供使用的人工数据集。</p><p>对计算机视觉的研究人员而言，数据集 <a target="_blank" rel="noopener" href="http://www.vision.caltech.edu/Image_Datasets/Caltech101/">CALTECH-101</a>是一个传奇般的存在。它包含来自101个不同分类中的至少7500张图片，内容分别有人物，摩托车和飞机。</p><p>从这7500多张图片中，我随机的挑选了17张。</p><p>然后，从这17张随机挑选的图片中，以几个百分点的比例随机放大/缩小并创建N张新图片。这里我们的目标是找到这些近似副本的图片——有点大海捞针的感觉。</p><p>你也想创建一个类似的数据集用于工作吗？那就下载 <a target="_blank" rel="noopener" href="http://www.vision.caltech.edu/Image_Datasets/Caltech101/">CALTECH-101</a>数据集，抽取大概17张图片即可，然后运行repo下的脚本文件gather.py。</p><p>回归正题，这些图片除了宽度和高度，其他各方面都是一样的。而且因为他们没有相同的形状，我们不能依赖简单的md5校验和。最重要的是，有相似内容的图片可能有完全不相同的md5哈希。然而，采取图片哈希，相似内容的图片也有相似的哈希指纹。</p><p>所以赶紧开始写代码为数据集建立指纹吧。创建一个新文件，命名为index.py，然后开始工作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import the necessary packages</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> imagehash</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># construct the argument parse and parse the arguments</span></span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">&quot;-d&quot;</span>, <span class="string">&quot;--dataset&quot;</span>, required = <span class="literal">True</span>,</span><br><span class="line"><span class="built_in">help</span> = <span class="string">&quot;path to input dataset of images&quot;</span>)</span><br><span class="line">ap.add_argument(<span class="string">&quot;-s&quot;</span>, <span class="string">&quot;--shelve&quot;</span>, required = <span class="literal">True</span>,</span><br><span class="line"><span class="built_in">help</span> = <span class="string">&quot;output shelve database&quot;</span>)</span><br><span class="line">args = <span class="built_in">vars</span>(ap.parse_args())</span><br></pre></td></tr></table></figure><p>要做的第一件事就是引入我们需要的包。我们将使用PIL或Pillow中的Image类载入硬盘上的图片。这个imagehash库可以被用于构建哈希算法。</p><p>Argparse库用于解析命令行参数，shelve库用作一个存储在硬盘上的简单键值对数据库（Python字典）。glob库能很容易的获取图片路径。</p><p>然后传递命令行参数。第一个，—dataset是输入图片库的路径。第二个，—shelve是shelve数据库的输出路径。</p><p>下一步，打开shelve数据库以写数据。这个db数据库存储图片哈希。更多的如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># loop over the image dataset</span></span><br><span class="line"><span class="keyword">for</span> imagePath <span class="keyword">in</span> glob.glob(args[<span class="string">&quot;dataset&quot;</span>] + <span class="string">&quot;/*.jpg&quot;</span>):</span><br><span class="line"><span class="comment"># load the image and compute the difference hash</span></span><br><span class="line">    image = Image.<span class="built_in">open</span>(imagePath)</span><br><span class="line">    h = <span class="built_in">str</span>(imagehash.dhash(image))</span><br><span class="line"></span><br><span class="line"><span class="comment"># extract the filename from the path and update the database</span></span><br><span class="line"><span class="comment"># using the hash as the key and the filename append to the</span></span><br><span class="line"><span class="comment"># list of values</span></span><br><span class="line">    filename = imagePath[imagePath.rfind(<span class="string">&quot;/&quot;</span>) + <span class="number">1</span>:]</span><br><span class="line">    db[h] = db.get(h, []) + [filename]</span><br><span class="line"></span><br><span class="line"><span class="comment"># close the shelf database</span></span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure><p>以上就是大部分工作的内容了。开始循环从硬盘读取图片，创建图片指纹并存入数据库。</p><p>现在，来看看整个范例中最重要的两行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filename = imagePath[imagePath.rfind(<span class="string">&quot;/&quot;</span>) + <span class="number">1</span>:]</span><br><span class="line">db[h] = db.get(h, []) + [filename]</span><br></pre></td></tr></table></figure><p>正如本文早些时候提到的，有相同指纹的图片被认为是一样的。</p><p>因此，如果我们的目标是找到近似图片，那就需要维护一个有相同指纹值的图片列表。</p><p>而这也正是这几行代码做的事情。</p><p>前一个代码段提取了图片的文件名。而后一个代码片段维护了一个有相同指纹值的图片列表。</p><p>为了从我们的数据库中提取图片指纹并建立哈希数据库，运行下列命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python index.py —dataset images —shelve db.shelve</span><br></pre></td></tr></table></figure><p>这个脚本会运行几秒钟，完成后，就会出现一个名为db.shelve的文件，包含了图片指纹和文件名的键值对。</p><p>这个基本算法正是几年前我为这家约会创业公司工作时使用的算法。我们获得了一个不雅图片集，为其中的每张图片构建一个图片指纹并将其存入数据库。当来一张新图片时，我只需简单地计算它的哈希值，检测数据库查看是否上传图片已被标识为非法内容。</p><p>下一步中，我将展示实际如何执行查询，判定数据库中是否存在与所给图片具有相同哈希值的图片。</p><h2 id="第二步：查询数据集"><a href="#第二步：查询数据集" class="headerlink" title="第二步：查询数据集"></a>第二步：查询数据集</h2><p>既然已经建立了一个图片指纹的数据库，那么现在就该搜索我们的数据集了。</p><p>打开一个新文件，命名为search.py，然后开始写代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import the necessary packages</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> imagehash</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line"></span><br><span class="line"><span class="comment"># construct the argument parse and parse the arguments</span></span><br><span class="line">ap = argparse.ArgumentParser()</span><br><span class="line">ap.add_argument(<span class="string">&quot;-d&quot;</span>, <span class="string">&quot;--dataset&quot;</span>, required = <span class="literal">True</span>,</span><br><span class="line">    <span class="built_in">help</span> = <span class="string">&quot;path to dataset of images&quot;</span>)</span><br><span class="line">ap.add_argument(<span class="string">&quot;-s&quot;</span>, <span class="string">&quot;--shelve&quot;</span>, required = <span class="literal">True</span>,</span><br><span class="line">    <span class="built_in">help</span> = <span class="string">&quot;output shelve database&quot;</span>)</span><br><span class="line">ap.add_argument(<span class="string">&quot;-q&quot;</span>, <span class="string">&quot;--query&quot;</span>, required = <span class="literal">True</span>,</span><br><span class="line">    <span class="built_in">help</span> = <span class="string">&quot;path to the query image&quot;</span>)</span><br><span class="line">args = <span class="built_in">vars</span>(ap.parse_args())</span><br></pre></td></tr></table></figure><p>我们需要再一次导入相关的包。然后转换命令行参数。需要三个选项，—dataset初始图片集的路径，—shelve，保存键值对的数据库的路径，—query，查询/上传图片的路径。我们的目标是对于每个查询图片，判定数据库中是否已经存在。</p><p>现在，写代码执行实际的查询：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># open the shelve database</span></span><br><span class="line">db = shelve.<span class="built_in">open</span>(args[<span class="string">&quot;shelve&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># load the query image, compute the difference image hash, and</span></span><br><span class="line"><span class="comment"># and grab the images from the database that have the same hash</span></span><br><span class="line"><span class="comment"># value</span></span><br><span class="line">query = Image.<span class="built_in">open</span>(args[<span class="string">&quot;query&quot;</span>])</span><br><span class="line">h = <span class="built_in">str</span>(imagehash.dhash(query))</span><br><span class="line">filenames = db[h]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Found %d images&quot;</span> % (<span class="built_in">len</span>(filenames))</span><br><span class="line"></span><br><span class="line"><span class="comment"># loop over the images</span></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">    image = Image.<span class="built_in">open</span>(args[<span class="string">&quot;dataset&quot;</span>] + <span class="string">&quot;/&quot;</span> + filename)</span><br><span class="line">    image.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># close the shelve database</span></span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure><p>首先打开数据库，然后载入硬盘上的图片，计算图片的指纹，找到具有相同指纹的所有图片。</p><p>如果有图片具有相同的哈希值，会遍历这些图片并展示在屏幕上。</p><p>这段代码使我们仅仅使用指纹值就能判定图片是否已在数据库中存在。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>正如本文早些时候提到的，我从CALTECH-101数据集的7500多张图片中随机选取17张，然后通过任意缩放一部分点产生N张新的图片。</p><p>这些图片在尺寸上仅仅是少数像素不同—但也是因为这一点我们不能依赖于文件的md5哈希（这一点已在“优化算法”部分进行了详尽的描述）。然而，我们可以使用图片哈希找到近似图片。</p><p>打开你的终端并执行下述命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python search.py —dataset images —shelve db.shelve —query images/84eba74d-38ae-4bf6-b8bd-79ffa1dad23a.jpg</span><br></pre></td></tr></table></figure><p>如果一切顺利你就可以看到下述结果：</p><p><img src="fingerprint_results_01.jpg"></p><p>左边是输入图片。载入这张图片，计算它的图片指纹，在数据库中搜索指纹查看是否存在有相同指纹的图片。</p><p>当然——正如右边所示，我们的数据集中有其他两张指纹相同的图片。尽管从截图中还不能十分明显的看出，这些图片，虽然有完全相同的视觉内容，也不是完全相同！这三张图片的高度宽度各不相同。</p><p>尝试一下另外一个输入图片：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python search.py —dataset images —shelve db.shelve —query images/9d355a22-3d59-465e-ad14-138a4e3880bc.jpg</span><br></pre></td></tr></table></figure><p>下面是结果：</p><p><img src="fingerprint_results_02.jpg"></p><p>左边仍然是我们的输入图片。正如右边展示的，我们的图片指纹算法能够找出具有相同指纹的三张完全相同的图片。</p><p>最后一个例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python search.py —dataset images —shelve db.shelve —query images/5134e0c2-34d3-40b6-9473-98de8be16c67.jpg</span><br></pre></td></tr></table></figure><p><img src="fingerprint_results_03.jpg"></p><p>这一次左边的输入图片是一个摩托车。拿到这张摩托车图片，计算它的图片指纹，然后在指纹数据库中查找该指纹。正如我们在右边看到的，我们也能判断出数据库中有三张图片具有相同指纹。</p><h2 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h2><p>有很多可以优化本算法的方法——但最关键性的是要考虑到相似但不相同的哈希。</p><p>比如，本文中的图片仅仅是一小部分点重组了（依比例增大或减小）。如果一张图片以一个较大的因素调整大小，或者纵横比被改变了，对应的哈希就会不同了。</p><p>然而，这些图片应该仍然是相似的。</p><p>为了找到相似但不相同的图片，我们需要计算汉明距离（Hamming distance）.汉明距离被用于计算一个哈希中的不同位数。因此，哈希中只有一位不同的两张图片自然比有10位不同的图片更相似。</p><p>然而，我们遇到了第二个问题——算法的可扩展性。</p><p>考虑一下：我们有一张输入图片，又被要求在数据库中找到所有相似图片。然后我们必须计算输入图片和数据库中的每一张图片之间的汉明距离。</p><p>随着数据库规模的增长，和数据库比对的时间也随着延长。最终，我们的哈希数据库会达到一个线性比对已经不实际的规模。</p><p>解决办法，虽然已超出本文范围，就是利用 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/K-d_tree">K-d trees</a> 和 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Vantage-point_tree">VP trees</a> 将搜索问题的复杂度从线性减小到次线性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文中我们学会了如何构建和使用图片哈希来完成相似图片的检测。这些图片哈希是使用图片的视觉内容构建的。</p><p>正如一个指纹可以识别一个人，图片哈希也能唯一的识别一张图片。</p><p>使用图片指纹的知识，我们建立了一个仅使用图片哈希就能找到和识别具有相似内容的图片的系统。</p><p>然后我们又演示了图片哈希是如何应用于快速找到有相似内容的图片。</p><p>从 <a target="_blank" rel="noopener" href="https://github.com/realpython/image-fingerprinting">repo</a> 目录下下载代码。</p><h2 id="周末学计算机视觉"><a href="#周末学计算机视觉" class="headerlink" title="周末学计算机视觉"></a>周末学计算机视觉</h2><p>如果你很喜欢本文而且还想了解更多与计算机视觉，图片处理以及建立图片搜索引擎相关的东西，那就去我的博客吧，地址是 <a target="_blank" rel="noopener" href="http://www.pyimagesearch.com/">PyImageSearch.com</a>。</p><p>祝福！</p><hr><p>译文地址：<a target="_blank" rel="noopener" href="http://www.pyimagesearch.com/">http://www.pyimagesearch.com/</a><br>原文地址：<a target="_blank" rel="noopener" href="https://realpython.com/blog/python/fingerprinting-images-for-near-duplicate-detection/">https://realpython.com/blog/python/fingerprinting-images-for-near-duplicate-detection/</a></p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time datetime="2015-05-03T09:49:00.000Z" title="5/3/2015, 9:49:00 AM">2015-05-03</time></span><span class="level-item">Updated&nbsp;<time datetime="2019-07-04T03:44:51.000Z" title="7/4/2019, 3:44:51 AM">2019-07-04</time></span><span class="level-item">15 minutes read (About 2306 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/hexo-blog/2015/05/03/%E4%BA%91%E5%B9%B3%E5%8F%B0%E4%B9%8B-SaaS-%E9%9A%8F%E6%83%B3/">云平台之 SaaS 随想</a></h1><div class="content"><blockquote><p>原文地址：<a target="_blank" rel="noopener" href="http://88250.b3log.org/saas-essay">http://88250.b3log.org/saas-essay</a></p></blockquote><h2 id="SaaS-平台"><a href="#SaaS-平台" class="headerlink" title="SaaS 平台"></a>SaaS 平台</h2><h3 id="以应用为中心"><a href="#以应用为中心" class="headerlink" title="以应用为中心"></a>以应用为中心</h3><p>“平台”本来就比较泛，再加上“SaaS”的话就更飘渺了。</p><p>我们先从一个简单的场景来看：</p><ol><li>开发者开发应用后在市场上线</li><li>用户购买应用使用</li><li>开发者通过市场反馈调整运维，为后续版本计划提供依据</li><li>新版本上线，用户升级使用</li></ol><p>这是以应用为中心的一个闭环（市场-开发-运维-市场），实现了应用的整个生命周期，我们可以把平台看成是这个场景的支撑，场景中的所有活动都是在平台上完成的，整个场景就是一个 SaaS 生态系统。</p></div><a class="article-more button is-small is-size-7" href="/hexo-blog/2015/05/03/%E4%BA%91%E5%B9%B3%E5%8F%B0%E4%B9%8B-SaaS-%E9%9A%8F%E6%83%B3/#more">Read more</a></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/hexo-blog/tags/%E8%BD%AC%E8%BD%BD/page/0/">Previous</a></div><div class="pagination-next"><a href="/hexo-blog/tags/%E8%BD%AC%E8%BD%BD/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/hexo-blog/tags/%E8%BD%AC%E8%BD%BD/">1</a></li><li><a class="pagination-link" href="/hexo-blog/tags/%E8%BD%AC%E8%BD%BD/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://www.gravatar.com/avatar/46cd15f0d49de84b6b9cd1b16032e034?s=128" alt="whypro"></figure><p class="title is-size-4 is-block" style="line-height:inherit">whypro</p><p class="is-size-6 is-block">Don&#039;t think twice, it&#039;s all right.</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shanghai</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/hexo-blog/archives"><p class="title">66</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/hexo-blog/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/hexo-blog/tags"><p class="title">72</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/whypro" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/whypro"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/Android/"><span class="tag">Android</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/Arch-Linux/"><span class="tag">Arch Linux</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/C/"><span class="tag">C</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/DDNS/"><span class="tag">DDNS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/Docker/"><span class="tag">Docker</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/Fedora/"><span class="tag">Fedora</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/GC/"><span class="tag">GC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/Golang/"><span class="tag">Golang</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/HTC/"><span class="tag">HTC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/Intel/"><span class="tag">Intel</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/K8S/"><span class="tag">K8S</span><span class="tag">16</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/Kubelet/"><span class="tag">Kubelet</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/Kubernetes/"><span class="tag">Kubernetes</span><span class="tag">16</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/Linux/"><span class="tag">Linux</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/MMap/"><span class="tag">MMap</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/Makefile/"><span class="tag">Makefile</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/NAS/"><span class="tag">NAS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/NIO/"><span class="tag">NIO</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/Openstack/"><span class="tag">Openstack</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/PaaS/"><span class="tag">PaaS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/PostgreSQL/"><span class="tag">PostgreSQL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/Power-Designer/"><span class="tag">Power Designer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/Prometheus/"><span class="tag">Prometheus</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/Python/"><span class="tag">Python</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/Ruby/"><span class="tag">Ruby</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/SSD/"><span class="tag">SSD</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/SaaS/"><span class="tag">SaaS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/Tornado/"><span class="tag">Tornado</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/Windows/"><span class="tag">Windows</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/devicemapper/"><span class="tag">devicemapper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/dnsmasq/"><span class="tag">dnsmasq</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/etcd/"><span class="tag">etcd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/hostapd/"><span class="tag">hostapd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/terraform/"><span class="tag">terraform</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E4%B8%BB%E6%9D%BF/"><span class="tag">主板</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"><span class="tag">云计算</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E4%BA%A4%E6%98%93/"><span class="tag">交易</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"><span class="tag">人工智能</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E5%88%B7%E6%9C%BA/"><span class="tag">刷机</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E5%8D%8F%E7%A8%8B/"><span class="tag">协程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"><span class="tag">原创</span><span class="tag">45</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/"><span class="tag">固态硬盘</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"><span class="tag">图像处理</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"><span class="tag">垃圾回收</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E5%AD%98%E5%82%A8/"><span class="tag">存储</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E5%AE%89%E5%8D%93/"><span class="tag">安卓</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E6%8A%95%E8%B5%84/"><span class="tag">投资</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E6%91%84%E5%BD%B1/"><span class="tag">摄影</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E6%9C%9F%E8%B4%A7/"><span class="tag">期货</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="tag">机器学习</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"><span class="tag">树莓派</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E6%B8%B8%E6%88%8F/"><span class="tag">游戏</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E7%88%AC%E8%99%AB/"><span class="tag">爬虫</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E7%A1%AC%E4%BB%B6/"><span class="tag">硬件</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E7%AC%94%E8%AE%B0/"><span class="tag">笔记</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E7%BB%B4%E4%BF%AE/"><span class="tag">维修</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="tag">编程语言</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E7%BD%91%E7%BB%9C/"><span class="tag">网络</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E8%82%A1%E7%A5%A8/"><span class="tag">股票</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E8%8A%B1%E7%94%9F%E5%A3%B3/"><span class="tag">花生壳</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95/"><span class="tag">蚁群算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E8%BD%AC%E8%BD%BD/"><span class="tag">转载</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E8%BF%90%E7%BB%B4/"><span class="tag">运维</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E8%BF%9E%E8%BF%9E%E7%9C%8B/"><span class="tag">连连看</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E9%87%91%E8%9E%8D/"><span class="tag">金融</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E9%97%AD%E5%8C%85/"><span class="tag">闭包</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E9%9D%9E%E9%98%BB%E5%A1%9E/"><span class="tag">非阻塞</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/hexo-blog/tags/%E9%BB%91%E5%AE%A2%E6%8A%80%E6%9C%AF/"><span class="tag">黑客技术</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://ppoffice.github.io/hexo-theme-icarus/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Icarus Theme</span></span><span class="level-right"><span class="level-item tag">ppoffice.github.io</span></span></a></li><li><a class="level is-mobile" href="https://github.com/whypro" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Github</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time datetime="2021-01-16T00:36:00.000Z">2021-01-16</time></p><p class="title"><a href="/hexo-blog/2021/01/16/Linux%20%E8%B7%AF%E7%94%B1%E8%A1%A8%E7%AE%80%E4%BB%8B/">Linux 路由表简介</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2020-04-20T15:49:00.000Z">2020-04-20</time></p><p class="title"><a href="/hexo-blog/2020/04/20/%E4%BA%91%E8%81%AA%E9%87%91%E8%9E%8D%E4%BA%A4%E6%98%93%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/">云聪金融交易分析入门笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2020-03-23T16:39:00.000Z">2020-03-24</time></p><p class="title"><a href="/hexo-blog/2020/03/23/%E8%A7%A3%E5%86%B3%E2%80%9CWindows%20%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F%E6%97%A0%E6%B3%95%E5%B0%86%20Windows%20%E9%85%8D%E7%BD%AE%E4%B8%BA%E5%9C%A8%E6%AD%A4%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E7%A1%AC%E4%BB%B6%E4%B8%8A%E8%BF%90%E8%A1%8C%E2%80%9D/">解决 “Windows 安装程序无法将 Windows 配置为在此计算机的硬件上运行”</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2020-03-08T12:59:00.000Z">2020-03-08</time></p><p class="title"><a href="/hexo-blog/2020/03/08/2020-%E5%B9%B4-3-%E6%9C%88%E6%89%8B%E8%AE%B0/">2020 年 3 月手记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2020-02-16T08:44:00.000Z">2020-02-16</time></p><p class="title"><a href="/hexo-blog/2020/02/16/2020-%E5%B9%B4-2-%E6%9C%88%E6%89%8B%E8%AE%B0/">2020 年 2 月手记</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/hexo-blog/archives/2021/01/"><span class="level-start"><span class="level-item">January 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2020/04/"><span class="level-start"><span class="level-item">April 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2020/03/"><span class="level-start"><span class="level-item">March 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2020/02/"><span class="level-start"><span class="level-item">February 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2020/01/"><span class="level-start"><span class="level-item">January 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2019/10/"><span class="level-start"><span class="level-item">October 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2019/09/"><span class="level-start"><span class="level-item">September 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2019/08/"><span class="level-start"><span class="level-item">August 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2019/07/"><span class="level-start"><span class="level-item">July 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2019/06/"><span class="level-start"><span class="level-item">June 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2019/05/"><span class="level-start"><span class="level-item">May 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2019/01/"><span class="level-start"><span class="level-item">January 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2018/11/"><span class="level-start"><span class="level-item">November 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2018/10/"><span class="level-start"><span class="level-item">October 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2018/07/"><span class="level-start"><span class="level-item">July 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2018/04/"><span class="level-start"><span class="level-item">April 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2018/03/"><span class="level-start"><span class="level-item">March 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2018/01/"><span class="level-start"><span class="level-item">January 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2017/12/"><span class="level-start"><span class="level-item">December 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2017/10/"><span class="level-start"><span class="level-item">October 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2017/09/"><span class="level-start"><span class="level-item">September 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2016/09/"><span class="level-start"><span class="level-item">September 2016</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2016/04/"><span class="level-start"><span class="level-item">April 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2015/10/"><span class="level-start"><span class="level-item">October 2015</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2015/07/"><span class="level-start"><span class="level-item">July 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2015/06/"><span class="level-start"><span class="level-item">June 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2015/05/"><span class="level-start"><span class="level-item">May 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2015/04/"><span class="level-start"><span class="level-item">April 2015</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2013/09/"><span class="level-start"><span class="level-item">September 2013</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2013/08/"><span class="level-start"><span class="level-item">August 2013</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2013/05/"><span class="level-start"><span class="level-item">May 2013</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2013/04/"><span class="level-start"><span class="level-item">April 2013</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2013/03/"><span class="level-start"><span class="level-item">March 2013</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2012/10/"><span class="level-start"><span class="level-item">October 2012</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2012/09/"><span class="level-start"><span class="level-item">September 2012</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2012/08/"><span class="level-start"><span class="level-item">August 2012</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2012/07/"><span class="level-start"><span class="level-item">July 2012</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2012/06/"><span class="level-start"><span class="level-item">June 2012</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/hexo-blog/archives/2012/02/"><span class="level-start"><span class="level-item">February 2012</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/hexo-blog/"><img src="/hexo-blog/img/logo.svg" alt="格里莫广场12号" height="28"></a><p class="is-size-7"><span>&copy; 2021 whypro</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/whypro"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("en")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/hexo-blog/js/column.js"></script><script src="/hexo-blog/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/hexo-blog/js/back_to_top.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load",()=>{window.cookieconsent.initialise({type:"info",theme:"edgeless",static:!1,position:"bottom-left",content:{message:"This website uses cookies to improve your experience.",dismiss:"Got it!",allow:"Allow cookies",deny:"Decline",link:"Learn more",policy:"Cookie Policy",href:"https://www.cookiesandyou.com/"},palette:{popup:{background:"#edeff5",text:"#838391"},button:{background:"#4b81e8"}}})})</script><script src="https://cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load",()=>{"function"==typeof $.fn.lightGallery&&$(".article").lightGallery({selector:".gallery-item"}),"function"==typeof $.fn.justifiedGallery&&($(".justified-gallery > p > .gallery-item").length&&$(".justified-gallery > p > .gallery-item").unwrap(),$(".justified-gallery").justifiedGallery())})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now</a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load",(function(){outdatedBrowser({bgColor:"#f25648",color:"#ffffff",lowerThan:"object-fit"})}))</script><script src="/hexo-blog/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/hexo-blog/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",(function(){loadInsight({contentUrl:"/hexo-blog/content.json"},{hint:"Type something...",untitled:"(Untitled)",posts:"Posts",pages:"Pages",categories:"Categories",tags:"Tags"})}))</script></body></html>