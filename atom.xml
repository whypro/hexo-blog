<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EVERLASTING</title>
  
  
  <link href="/hexo-blog/atom.xml" rel="self"/>
  
  <link href="http://whypro.github.io/hexo-blog/"/>
  <updated>2019-07-19T16:25:17.702Z</updated>
  <id>http://whypro.github.io/hexo-blog/</id>
  
  <author>
    <name>whypro</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019 年 7 月手记</title>
    <link href="http://whypro.github.io/hexo-blog/20190719/2019-%E5%B9%B4-7-%E6%9C%88%E6%89%8B%E8%AE%B0/"/>
    <id>http://whypro.github.io/hexo-blog/20190719/2019-年-7-月手记/</id>
    <published>2019-07-18T16:00:00.000Z</published>
    <updated>2019-07-19T16:25:17.702Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><h3 id="api-conventions"><a href="#api-conventions" class="headerlink" title="api conventions"></a>api conventions</h3><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md</a></p><h3 id="kube-node-lease"><a href="#kube-node-lease" class="headerlink" title="kube node lease"></a>kube node lease</h3><p>kube node lease 用来改善 kubelet 定时更新节点状态对 etcd 造成的压力。</p><p><a href="https://containers.goffinet.org/k8s/kubectlget.html#what-about-kube-node-lease" target="_blank" rel="noopener">https://containers.goffinet.org/k8s/kubectlget.html#what-about-kube-node-lease</a></p><p><a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/0009-node-heartbeat.md" target="_blank" rel="noopener">https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/0009-node-heartbeat.md</a></p><p><a href="https://kubernetes.io/docs/concepts/architecture/nodes/#node-controller" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/architecture/nodes/#node-controller</a></p><p><a href="https://github.com/kubernetes-sigs/kubespray/blob/master/docs/kubernetes-reliability.md" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/kubespray/blob/master/docs/kubernetes-reliability.md</a></p><a id="more"></a><h3 id="Finalizers"><a href="#Finalizers" class="headerlink" title="Finalizers"></a>Finalizers</h3><p><a href="https://book-v1.book.kubebuilder.io/beyond_basics/using_finalizers.html" target="_blank" rel="noopener">https://book-v1.book.kubebuilder.io/beyond_basics/using_finalizers.html</a></p><h3 id="controller-history"><a href="#controller-history" class="headerlink" title="controller history"></a>controller history</h3><p><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/apps/controller_history.md" target="_blank" rel="noopener">ControllerRevision</a><br>是为 StatefulSet 和 DaemonSet 保存历史的资源类型。因为设计得比较通用，第三方控制器 + CRD 也可以借助它来实现版本管理。</p><h3 id="client-go-informer"><a href="#client-go-informer" class="headerlink" title="client-go informer"></a>client-go informer</h3><p><a href="https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md" target="_blank" rel="noopener">https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md</a></p><h3 id="kubebuilder"><a href="#kubebuilder" class="headerlink" title="kubebuilder"></a>kubebuilder</h3><p><a href="https://github.com/kubernetes-sigs/kubebuilder" target="_blank" rel="noopener">kubebuilder</a> 是开发第三方<br>controller 或 operator 的代码框架生成工具。它的实现基于<br><a href="https://github.com/kubernetes-sigs/controller-runtime" target="_blank" rel="noopener">controller-runtime</a><br>这个项目。</p><h3 id="Create-Kubernetes-Cluster"><a href="#Create-Kubernetes-Cluster" class="headerlink" title="Create Kubernetes Cluster"></a>Create Kubernetes Cluster</h3><p>使用 kubeadm 快速搭建一个可用的开发集群：</p><ol><li><a href="https://kubernetes.io/docs/setup/production-environment/container-runtimes/" target="_blank" rel="noopener">Install Container<br>Runtimes</a></li></ol><ol start="2"><li><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">Get Docker CE for<br>Ubuntu</a></li></ol><ol start="3"><li><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/" target="_blank" rel="noopener">Install<br>kubeadm</a></li></ol><ol start="4"><li><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/" target="_blank" rel="noopener">Create<br>Cluster</a></li></ol><ol start="5"><li><p><a href="https://docs.projectcalico.org/v3.8/getting-started/kubernetes/" target="_blank" rel="noopener">Install CNI<br>Plugin</a></p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://docs.projectcalico.org/v3.8/manifests/calico.yaml</span><br></pre></td></tr></table></figure></li></ol><h3 id="KubeCon-2019-Videos"><a href="#KubeCon-2019-Videos" class="headerlink" title="KubeCon 2019 Videos"></a>KubeCon 2019 Videos</h3><p><a href="https://www.youtube.com/watch?v=5yKheFRMflQ&amp;list=PLj6h78yzYM2Njj5PvNc4Mtcril2YyR95d" target="_blank" rel="noopener">https://www.youtube.com/watch?v=5yKheFRMflQ&amp;list=PLj6h78yzYM2Njj5PvNc4Mtcril2YyR95d</a></p><h3 id="阿里巴巴基于多租户的虚拟集群"><a href="#阿里巴巴基于多租户的虚拟集群" class="headerlink" title="阿里巴巴基于多租户的虚拟集群"></a>阿里巴巴基于多租户的虚拟集群</h3><p><a href="https://drive.google.com/file/d/1DX3jBwueEpSRhJ6n3VcqS1S3GDVvhF1B/view" target="_blank" rel="noopener">https://drive.google.com/file/d/1DX3jBwueEpSRhJ6n3VcqS1S3GDVvhF1B/view</a></p><p><a href="https://docs.google.com/document/d/1EELeVaduYZ65j4AXg9bp3Kyn38GKDU5fAJ5LFcxt2ZU/edit" target="_blank" rel="noopener">https://docs.google.com/document/d/1EELeVaduYZ65j4AXg9bp3Kyn38GKDU5fAJ5LFcxt2ZU/edit</a></p><h3 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h3><h4 id="Flex-Volume"><a href="#Flex-Volume" class="headerlink" title="Flex Volume"></a>Flex Volume</h4><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-storage/flexvolume.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-storage/flexvolume.md</a></p><p><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/flexvolume-deployment.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/flexvolume-deployment.md</a></p><h4 id="CSI"><a href="#CSI" class="headerlink" title="CSI"></a>CSI</h4><p><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md</a></p><h3 id="Kubernetes-Handbook"><a href="#Kubernetes-Handbook" class="headerlink" title="Kubernetes Handbook"></a>Kubernetes Handbook</h3><p><a href="https://jimmysong.io/kubernetes-handbook/" target="_blank" rel="noopener">https://jimmysong.io/kubernetes-handbook/</a></p><h3 id="Kubernetes-testing"><a href="#Kubernetes-testing" class="headerlink" title="Kubernetes testing"></a>Kubernetes testing</h3><p><a href="https://jimmysong.io/kubernetes-handbook/develop/testing.html" target="_blank" rel="noopener">https://jimmysong.io/kubernetes-handbook/develop/testing.html</a></p><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/testing.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/testing.md</a></p><h4 id="integration-testing"><a href="#integration-testing" class="headerlink" title="integration testing"></a>integration testing</h4><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/integration-tests.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/integration-tests.md</a></p><h4 id="e2e-testing"><a href="#e2e-testing" class="headerlink" title="e2e testing"></a>e2e testing</h4><p><a href="https://kubernetes.io/blog/2019/03/22/kubernetes-end-to-end-testing-for-everyone/" target="_blank" rel="noopener">https://kubernetes.io/blog/2019/03/22/kubernetes-end-to-end-testing-for-everyone/</a></p><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/e2e-tests.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/e2e-tests.md</a></p><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/writing-good-e2e-tests.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/writing-good-e2e-tests.md</a></p><p><a href="https://www.cnblogs.com/jinsdu/p/7465434.html" target="_blank" rel="noopener">https://www.cnblogs.com/jinsdu/p/7465434.html</a></p><p><a href="https://github.com/onsi/ginkgo" target="_blank" rel="noopener">https://github.com/onsi/ginkgo</a></p><p><a href="http://onsi.github.io/ginkgo/" target="_blank" rel="noopener">http://onsi.github.io/ginkgo/</a></p><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/conformance-tests.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/conformance-tests.md</a></p><h4 id="可以参考的项目"><a href="#可以参考的项目" class="headerlink" title="可以参考的项目"></a>可以参考的项目</h4><ul><li><p><a href="https://github.com/kubernetes-sigs/sig-storage-local-static-provisioner" target="_blank" rel="noopener">local-static-provisioner</a></p></li><li><p><a href="https://github.com/kubernetes/kubernetes" target="_blank" rel="noopener">kubernetes</a></p></li><li><p><a href="https://github.com/openkruise/kruise" target="_blank" rel="noopener">kruise</a></p></li><li><p><a href="https://github.com/coreos/prometheus-operator" target="_blank" rel="noopener">prometheus-operator</a></p></li></ul><h3 id="deletion-and-garbage-collection"><a href="#deletion-and-garbage-collection" class="headerlink" title="deletion and garbage collection"></a>deletion and garbage collection</h3><p><a href="https://thenewstack.io/deletion-garbage-collection-kubernetes-objects/" target="_blank" rel="noopener">这篇文章</a><br>介绍了 kubernetes 的删除和垃圾回收机制。</p><h3 id="ingress"><a href="#ingress" class="headerlink" title="ingress"></a>ingress</h3><p><a href="https://traefik.io/" target="_blank" rel="noopener">https://traefik.io/</a></p><h3 id="Useful-Commands"><a href="#Useful-Commands" class="headerlink" title="Useful Commands"></a>Useful Commands</h3><h4 id="查看-control-plane-状态"><a href="#查看-control-plane-状态" class="headerlink" title="查看 control-plane 状态"></a>查看 control-plane 状态</h4><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kubectl get componentstatus</span><br><span class="line"></span><br><span class="line">kubectl get cs</span><br><span class="line"></span><br><span class="line">kubectl cluster-info</span><br></pre></td></tr></table></figure><h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><h3 id="RunC-简介"><a href="#RunC-简介" class="headerlink" title="RunC 简介"></a>RunC 简介</h3><p><a href="https://www.cnblogs.com/sparkdev/p/9032209.html" target="_blank" rel="noopener">RunC 简介</a></p><h3 id="docker-registry-self-signed-certificates"><a href="#docker-registry-self-signed-certificates" class="headerlink" title="docker registry self-signed certificates"></a>docker registry self-signed certificates</h3><p>自建 docker registry 自签名方法：</p><p><a href="https://docs.docker.com/registry/insecure/" target="_blank" rel="noopener">https://docs.docker.com/registry/insecure/</a></p><h3 id="Useful-Commands-1"><a href="#Useful-Commands-1" class="headerlink" title="Useful Commands"></a>Useful Commands</h3><h4 id="debug-container"><a href="#debug-container" class="headerlink" title="debug container"></a>debug container</h4><p>通过以下命令可以很方便的调试容器网络：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo nsenter -t &lt;container-pid&gt; -n ip addr</span><br></pre></td></tr></table></figure><h4 id="start-mongodb-locally"><a href="#start-mongodb-locally" class="headerlink" title="start mongodb locally"></a>start mongodb locally</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">docker run -p 27017:27017 -v $PWD/db:/data/db -d mongo:3.2</span><br></pre></td></tr></table></figure><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><h3 id="go-modules-vgo"><a href="#go-modules-vgo" class="headerlink" title="go modules (vgo)"></a>go modules (vgo)</h3><p>go modules 已经逐渐取代其他依赖管理工具，很多社区项目都在逐步向 go modules 迁移。</p><ul><li><p><a href="https://talks.godoc.org/github.com/myitcv/talks/2018-08-15-glug-modules/main.slide#1" target="_blank" rel="noopener">What are Go modules and how do I use<br>them?</a></p></li><li><p><a href="https://segmentfault.com/a/1190000016703769" target="_blank" rel="noopener">Go Modules使用教程</a></p></li><li><p><a href="https://xuanwo.io/2019/05/27/go-modules/" target="_blank" rel="noopener">Go Modules 内部分享</a></p></li></ul><h4 id="go-modules-with-kubernetes-的坑"><a href="#go-modules-with-kubernetes-的坑" class="headerlink" title="go modules with kubernetes 的坑"></a>go modules with kubernetes 的坑</h4><p>使用 go modules 导入 <code>k8s.io/kubernetes</code> 主库会有问题，因为主库的 <code>go.mod</code> 文件里 replace<br>了一大堆依赖，<a href="https://github.com/kubernetes/kubernetes/issues/79384#issuecomment-505725449" target="_blank" rel="noopener">官方给的建议</a><br>是在自己的 <code>go.mod</code> 文件里再次 replace 会正确的版本，或者干脆不要依赖主库。</p><h3 id="golang-内存逃逸"><a href="#golang-内存逃逸" class="headerlink" title="golang 内存逃逸"></a>golang 内存逃逸</h3><p><a href="https://www.do1618.com/archives/1328/go-%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">Go<br>内存逃逸详细分析</a></p><h3 id="golang-测试"><a href="#golang-测试" class="headerlink" title="golang 测试"></a>golang 测试</h3><p><a href="https://colobu.com/2016/07/06/dive-into-go-12/" target="_blank" rel="noopener">测试、性能测试以及代码示例的编写</a></p><h2 id="Productive"><a href="#Productive" class="headerlink" title="Productive"></a>Productive</h2><h3 id="StarUML-Crack"><a href="#StarUML-Crack" class="headerlink" title="StarUML Crack"></a>StarUML Crack</h3><p><a href="https://gist.github.com/trandaison/40b1d83618ae8e3d2da59df8c395093a#gistcomment-2723165" target="_blank" rel="noopener">https://gist.github.com/trandaison/40b1d83618ae8e3d2da59df8c395093a#gistcomment-2723165</a></p><h3 id="Dictionary-Extension"><a href="#Dictionary-Extension" class="headerlink" title="Dictionary Extension"></a>Dictionary Extension</h3><p>用 DictUnifier（已改名为<br><a href="https://github.com/jjgod/mac-dictionary-kit" target="_blank" rel="noopener">mac-dictionary-kit</a>）可以将<br><a href="http://download.huzheng.org/zh_CN/" target="_blank" rel="noopener">stardict</a> 词典格式转换为 Apple Dict 格式。</p><p>转换教程参考：</p><ul><li><a href="https://www.douban.com/group/topic/9591106/" target="_blank" rel="noopener">https://www.douban.com/group/topic/9591106/</a></li></ul><p>-<br><a href="https://github.com/tsoliangwu0130/my-macos/blob/master/misc/dictunifier-stardict.md" target="_blank" rel="noopener">https://github.com/tsoliangwu0130/my-macos/blob/master/misc/dictunifier-stardict.md</a></p><p><a href="https://github.com/ilius/pyglossary" target="_blank" rel="noopener">PyGlossary</a> 是另外一种词典转换工具，不过需要在 <a href="https://developer.apple.com/download/more/" target="_blank" rel="noopener">Apple<br>Developer Downloads</a> 单独下载<br>Additional Tools for Xcode.</p><p>词典转换后可能会有 css 显示问题，可以参考：</p><ul><li><a href="https://discussions.apple.com/thread/3736067" target="_blank" rel="noopener">https://discussions.apple.com/thread/3736067</a></li></ul><h3 id="禁用-DS-Store"><a href="#禁用-DS-Store" class="headerlink" title="禁用 .DS_Store"></a>禁用 <code>.DS_Store</code></h3><p>如果在 macOS 的 Finder 里访问网络文件系统（比如 samba），打开目录是会自动在目录下生成 <code>.DS_Store</code><br>来存储一些元信息（标签、文件夹颜色、排序等等），这个在其他系统上看起来就非常不顺眼，因此可以通过下面的命令禁用：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">defaults write com.apple.desktopservices DSDontWriteNetworkStores true</span><br></pre></td></tr></table></figure><p>但是这个命令只对网络存储有用，对于本地磁盘还是会生成 <code>.DS_Store</code> 文件，暂时没有方便的办法禁用。</p><h3 id="Jetbrains-back-forward-with-mouse"><a href="#Jetbrains-back-forward-with-mouse" class="headerlink" title="Jetbrains back/forward with mouse"></a>Jetbrains back/forward with mouse</h3><p>有的鼠标有 Button4 和 Button5 可以在浏览代码时很方便地前进和后退，macOS 系统，在 Visual Studio Code 上正常，但在<br>Jetbrains 系的 IDE 上默认却是跳转到行首和行尾，解决方法是修改 Button4 和 Button5<br>默认的键盘快捷键。可以参考<a href="https://stackoverflow.com/questions/14360112/intellij-idea-back-forward-with-mouse" target="_blank" rel="noopener">这个方法</a>修改。</p><h3 id="Vagrant-KVM"><a href="#Vagrant-KVM" class="headerlink" title="Vagrant + KVM"></a>Vagrant + KVM</h3><p>KVM 比 VirtualBox 的性能更好，在 Linux 环境下推荐使用：</p><p><a href="https://medium.com/@gauthierleonard/kvm-machines-for-vagrant-on-archlinux-1d8863344cb7" target="_blank" rel="noopener">https://medium.com/@gauthierleonard/kvm-machines-for-vagrant-on-archlinux-1d8863344cb7</a></p><p><a href="https://docs.cumulusnetworks.com/display/VX/Vagrant+and+Libvirt+with+KVM+or+QEMU" target="_blank" rel="noopener">https://docs.cumulusnetworks.com/display/VX/Vagrant+and+Libvirt+with+KVM+or+QEMU</a></p><p><a href="https://gist.github.com/yuanying/924ce2ce61b75ab818b5" target="_blank" rel="noopener">https://gist.github.com/yuanying/924ce2ce61b75ab818b5</a></p><h3 id="Windows-10-Ubuntu-18-04"><a href="#Windows-10-Ubuntu-18-04" class="headerlink" title="Windows 10 + Ubuntu 18.04"></a>Windows 10 + Ubuntu 18.04</h3><p>在 MacOS 上刻录镜像</p><p><a href="https://www.cybrary.it/0p3n/macos-terminal-create-bootable-usb-iso-using-dd/" target="_blank" rel="noopener">https://www.cybrary.it/0p3n/macos-terminal-create-bootable-usb-iso-using-dd/</a></p><p>Ubuntu Installer 无法识别 GPT 分区</p><p><a href="https://arstechnica.com/civis/viewtopic.php?p=36107737&amp;sid=108632491878b9fa937dcbc6d433765f#p36107737" target="_blank" rel="noopener">https://arstechnica.com/civis/viewtopic.php?p=36107737&amp;sid=108632491878b9fa937dcbc6d433765f#p36107737</a></p><p><a href="https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/disabling-secure-boot" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/disabling-secure-boot</a></p><p><a href="https://www.technorms.com/45538/disable-enable-secure-boot-asus-motherboard-uefi-bios-utility" target="_blank" rel="noopener">https://www.technorms.com/45538/disable-enable-secure-boot-asus-motherboard-uefi-bios-utility</a></p><h3 id="VSC-Remote"><a href="#VSC-Remote" class="headerlink" title="VSC Remote"></a>VSC Remote</h3><p>使用 <a href="https://code.visualstudio.com/docs/remote/ssh" target="_blank" rel="noopener">VSC Remote</a> 可以方便地在 Windows<br>或者 macOS 下利用 ssh 进行 Linux 环境远程开发和调试。需要安装 <a href="https://code.visualstudio.com/insiders/" target="_blank" rel="noopener">Visual Studio Code<br>insiders</a> 版本。</p><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h4 id="change-author-of-commits"><a href="#change-author-of-commits" class="headerlink" title="change author of commits"></a>change author of commits</h4><p><a href="https://makandracards.com/makandra/1717-git-change-author-of-a-commit" target="_blank" rel="noopener">https://makandracards.com/makandra/1717-git-change-author-of-a-commit</a></p><h4 id="grep-logs"><a href="#grep-logs" class="headerlink" title="grep logs"></a>grep logs</h4><p>有时候需要确认某个 PR 或者 commit 有没有合入特定版本或者分支，可以用下面的命令：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git <span class="hljs-built_in">log</span> &lt;branch-or-tag-name&gt; --since 3.weeks --grep &lt;pattern&gt;</span><br></pre></td></tr></table></figure><h3 id="Bazel"><a href="#Bazel" class="headerlink" title="Bazel"></a>Bazel</h3><p>Bazel 是 Google 的构建工具，CMake 或者 Makefile 的替代品。</p><p><a href="https://medium.com/windmill-engineering/bazel-is-the-worst-build-system-except-for-all-the-others-b369396a9e26" target="_blank" rel="noopener">https://medium.com/windmill-engineering/bazel-is-the-worst-build-system-except-for-all-the-others-b369396a9e26</a></p><h3 id="jq"><a href="#jq" class="headerlink" title="jq"></a>jq</h3><p>json 的命令行解析工具。参考：<a href="https://stedolan.github.io/jq/tutorial/" target="_blank" rel="noopener">https://stedolan.github.io/jq/tutorial/</a></p><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><h3 id="服务名与端口号映射"><a href="#服务名与端口号映射" class="headerlink" title="服务名与端口号映射"></a>服务名与端口号映射</h3><p><a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml" target="_blank" rel="noopener">https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml</a></p><h3 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h3><p><a href="https://segmentfault.com/a/1190000016901447" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016901447</a></p><p><a href="https://flink.apache.org/" target="_blank" rel="noopener">https://flink.apache.org/</a></p><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>一个学习 css<br>的网站，支持边学边练：<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/white-space" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/CSS/white-space</a></p><p>categories: []<br>toc: true</p><h2 id="date-2019-07-19-23-40-09"><a href="#date-2019-07-19-23-40-09" class="headerlink" title="date: 2019-07-19 23:40:09"></a>date: 2019-07-19 23:40:09</h2><h2 id="Kubernetes-1"><a href="#Kubernetes-1" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><h3 id="api-conventions-1"><a href="#api-conventions-1" class="headerlink" title="api conventions"></a>api conventions</h3><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md</a></p><h3 id="kube-node-lease-1"><a href="#kube-node-lease-1" class="headerlink" title="kube node lease"></a>kube node lease</h3><p>kube node lease 用来改善 kubelet 定时更新节点状态对 etcd 造成的压力。</p><p><a href="https://containers.goffinet.org/k8s/kubectlget.html#what-about-kube-node-lease" target="_blank" rel="noopener">https://containers.goffinet.org/k8s/kubectlget.html#what-about-kube-node-lease</a></p><p><a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/0009-node-heartbeat.md" target="_blank" rel="noopener">https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/0009-node-heartbeat.md</a></p><p><a href="https://kubernetes.io/docs/concepts/architecture/nodes/#node-controller" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/architecture/nodes/#node-controller</a></p><p><a href="https://github.com/kubernetes-sigs/kubespray/blob/master/docs/kubernetes-reliability.md" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/kubespray/blob/master/docs/kubernetes-reliability.md</a></p><h3 id="Finalizers-1"><a href="#Finalizers-1" class="headerlink" title="Finalizers"></a>Finalizers</h3><p><a href="https://book-v1.book.kubebuilder.io/beyond_basics/using_finalizers.html" target="_blank" rel="noopener">https://book-v1.book.kubebuilder.io/beyond_basics/using_finalizers.html</a></p><h3 id="controller-history-1"><a href="#controller-history-1" class="headerlink" title="controller history"></a>controller history</h3><p><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/apps/controller_history.md" target="_blank" rel="noopener">ControllerRevision</a> 是为 StatefulSet 和 DaemonSet 保存历史的资源类型。因为设计得比较通用，第三方控制器 + CRD 也可以借助它来实现版本管理。</p><h3 id="client-go-informer-1"><a href="#client-go-informer-1" class="headerlink" title="client-go informer"></a>client-go informer</h3><p><a href="https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md" target="_blank" rel="noopener">https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md</a></p><h3 id="kubebuilder-1"><a href="#kubebuilder-1" class="headerlink" title="kubebuilder"></a>kubebuilder</h3><p><a href="https://github.com/kubernetes-sigs/kubebuilder" target="_blank" rel="noopener">kubebuilder</a> 是开发第三方 controller 或 operator 的代码框架生成工具。它的实现基于 <a href="https://github.com/kubernetes-sigs/controller-runtime" target="_blank" rel="noopener">controller-runtime</a> 这个项目。</p><h3 id="Create-Kubernetes-Cluster-1"><a href="#Create-Kubernetes-Cluster-1" class="headerlink" title="Create Kubernetes Cluster"></a>Create Kubernetes Cluster</h3><p>使用 kubeadm 快速搭建一个可用的开发集群：</p><ol><li><p><a href="https://kubernetes.io/docs/setup/production-environment/container-runtimes/" target="_blank" rel="noopener">Install Container Runtimes</a></p></li><li><p><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">Get Docker CE for Ubuntu</a></p></li><li><p><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/" target="_blank" rel="noopener">Install kubeadm</a></p></li><li><p><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/" target="_blank" rel="noopener">Create Cluster</a></p></li><li><p><a href="https://docs.projectcalico.org/v3.8/getting-started/kubernetes/" target="_blank" rel="noopener">Install CNI Plugin</a></p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://docs.projectcalico.org/v3.8/manifests/calico.yaml</span><br></pre></td></tr></table></figure></li></ol><h3 id="KubeCon-2019-Videos-1"><a href="#KubeCon-2019-Videos-1" class="headerlink" title="KubeCon 2019 Videos"></a>KubeCon 2019 Videos</h3><p><a href="https://www.youtube.com/watch?v=5yKheFRMflQ&amp;list=PLj6h78yzYM2Njj5PvNc4Mtcril2YyR95d" target="_blank" rel="noopener">https://www.youtube.com/watch?v=5yKheFRMflQ&amp;list=PLj6h78yzYM2Njj5PvNc4Mtcril2YyR95d</a></p><h3 id="阿里巴巴基于多租户的虚拟集群-1"><a href="#阿里巴巴基于多租户的虚拟集群-1" class="headerlink" title="阿里巴巴基于多租户的虚拟集群"></a>阿里巴巴基于多租户的虚拟集群</h3><p><a href="https://drive.google.com/file/d/1DX3jBwueEpSRhJ6n3VcqS1S3GDVvhF1B/view" target="_blank" rel="noopener">https://drive.google.com/file/d/1DX3jBwueEpSRhJ6n3VcqS1S3GDVvhF1B/view</a></p><p><a href="https://docs.google.com/document/d/1EELeVaduYZ65j4AXg9bp3Kyn38GKDU5fAJ5LFcxt2ZU/edit" target="_blank" rel="noopener">https://docs.google.com/document/d/1EELeVaduYZ65j4AXg9bp3Kyn38GKDU5fAJ5LFcxt2ZU/edit</a></p><h3 id="Storage-1"><a href="#Storage-1" class="headerlink" title="Storage"></a>Storage</h3><h4 id="Flex-Volume-1"><a href="#Flex-Volume-1" class="headerlink" title="Flex Volume"></a>Flex Volume</h4><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-storage/flexvolume.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-storage/flexvolume.md</a></p><p><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/flexvolume-deployment.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/flexvolume-deployment.md</a></p><h4 id="CSI-1"><a href="#CSI-1" class="headerlink" title="CSI"></a>CSI</h4><p><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md</a></p><h3 id="Kubernetes-Handbook-1"><a href="#Kubernetes-Handbook-1" class="headerlink" title="Kubernetes Handbook"></a>Kubernetes Handbook</h3><p><a href="https://jimmysong.io/kubernetes-handbook/" target="_blank" rel="noopener">https://jimmysong.io/kubernetes-handbook/</a></p><h3 id="Kubernetes-testing-1"><a href="#Kubernetes-testing-1" class="headerlink" title="Kubernetes testing"></a>Kubernetes testing</h3><p><a href="https://jimmysong.io/kubernetes-handbook/develop/testing.html" target="_blank" rel="noopener">https://jimmysong.io/kubernetes-handbook/develop/testing.html</a></p><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/testing.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/testing.md</a></p><h4 id="integration-testing-1"><a href="#integration-testing-1" class="headerlink" title="integration testing"></a>integration testing</h4><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/integration-tests.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/integration-tests.md</a></p><h4 id="e2e-testing-1"><a href="#e2e-testing-1" class="headerlink" title="e2e testing"></a>e2e testing</h4><p><a href="https://kubernetes.io/blog/2019/03/22/kubernetes-end-to-end-testing-for-everyone/" target="_blank" rel="noopener">https://kubernetes.io/blog/2019/03/22/kubernetes-end-to-end-testing-for-everyone/</a></p><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/e2e-tests.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/e2e-tests.md</a></p><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/writing-good-e2e-tests.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/writing-good-e2e-tests.md</a></p><p><a href="https://www.cnblogs.com/jinsdu/p/7465434.html" target="_blank" rel="noopener">https://www.cnblogs.com/jinsdu/p/7465434.html</a></p><p><a href="https://github.com/onsi/ginkgo" target="_blank" rel="noopener">https://github.com/onsi/ginkgo</a></p><p><a href="http://onsi.github.io/ginkgo/" target="_blank" rel="noopener">http://onsi.github.io/ginkgo/</a></p><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/conformance-tests.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/conformance-tests.md</a></p><h4 id="可以参考的项目-1"><a href="#可以参考的项目-1" class="headerlink" title="可以参考的项目"></a>可以参考的项目</h4><ul><li><a href="https://github.com/kubernetes-sigs/sig-storage-local-static-provisioner" target="_blank" rel="noopener">local-static-provisioner</a></li><li><a href="https://github.com/kubernetes/kubernetes" target="_blank" rel="noopener">kubernetes</a></li><li><a href="https://github.com/openkruise/kruise" target="_blank" rel="noopener">kruise</a></li><li><a href="https://github.com/coreos/prometheus-operator" target="_blank" rel="noopener">prometheus-operator</a></li></ul><h3 id="deletion-and-garbage-collection-1"><a href="#deletion-and-garbage-collection-1" class="headerlink" title="deletion and garbage collection"></a>deletion and garbage collection</h3><p><a href="https://thenewstack.io/deletion-garbage-collection-kubernetes-objects/" target="_blank" rel="noopener">这篇文章</a> 介绍了 kubernetes 的删除和垃圾回收机制。</p><h3 id="ingress-1"><a href="#ingress-1" class="headerlink" title="ingress"></a>ingress</h3><p><a href="https://traefik.io/" target="_blank" rel="noopener">https://traefik.io/</a></p><h3 id="Useful-Commands-2"><a href="#Useful-Commands-2" class="headerlink" title="Useful Commands"></a>Useful Commands</h3><h4 id="查看-control-plane-状态-1"><a href="#查看-control-plane-状态-1" class="headerlink" title="查看 control-plane 状态"></a>查看 control-plane 状态</h4><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get componentstatus</span><br><span class="line">kubectl get cs</span><br><span class="line">kubectl cluster-info</span><br></pre></td></tr></table></figure><h2 id="Container-1"><a href="#Container-1" class="headerlink" title="Container"></a>Container</h2><h3 id="RunC-简介-1"><a href="#RunC-简介-1" class="headerlink" title="RunC 简介"></a>RunC 简介</h3><p><a href="https://www.cnblogs.com/sparkdev/p/9032209.html" target="_blank" rel="noopener">RunC 简介</a></p><h3 id="docker-registry-self-signed-certificates-1"><a href="#docker-registry-self-signed-certificates-1" class="headerlink" title="docker registry self-signed certificates"></a>docker registry self-signed certificates</h3><p>自建 docker registry 自签名方法：</p><p><a href="https://docs.docker.com/registry/insecure/" target="_blank" rel="noopener">https://docs.docker.com/registry/insecure/</a></p><h3 id="Useful-Commands-3"><a href="#Useful-Commands-3" class="headerlink" title="Useful Commands"></a>Useful Commands</h3><h4 id="debug-container-1"><a href="#debug-container-1" class="headerlink" title="debug container"></a>debug container</h4><p>通过以下命令可以很方便的调试容器网络：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nsenter -t &lt;container-pid&gt; -n ip addr</span><br></pre></td></tr></table></figure><h4 id="start-mongodb-locally-1"><a href="#start-mongodb-locally-1" class="headerlink" title="start mongodb locally"></a>start mongodb locally</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 27017:27017 -v $PWD/db:/data/db -d mongo:3.2</span><br></pre></td></tr></table></figure><h2 id="Golang-1"><a href="#Golang-1" class="headerlink" title="Golang"></a>Golang</h2><h3 id="go-modules-vgo-1"><a href="#go-modules-vgo-1" class="headerlink" title="go modules (vgo)"></a>go modules (vgo)</h3><p>go modules 已经逐渐取代其他依赖管理工具，很多社区项目都在逐步向 go modules 迁移。</p><ul><li><a href="https://talks.godoc.org/github.com/myitcv/talks/2018-08-15-glug-modules/main.slide#1" target="_blank" rel="noopener">What are Go modules and how do I use them?</a></li><li><a href="https://segmentfault.com/a/1190000016703769" target="_blank" rel="noopener">Go Modules使用教程</a></li><li><a href="https://xuanwo.io/2019/05/27/go-modules/" target="_blank" rel="noopener">Go Modules 内部分享</a></li></ul><h4 id="go-modules-with-kubernetes-的坑-1"><a href="#go-modules-with-kubernetes-的坑-1" class="headerlink" title="go modules with kubernetes 的坑"></a>go modules with kubernetes 的坑</h4><p>使用 go modules 导入 <code>k8s.io/kubernetes</code> 主库会有问题，因为主库的 <code>go.mod</code> 文件里 replace 了一大堆依赖，<a href="https://github.com/kubernetes/kubernetes/issues/79384#issuecomment-505725449" target="_blank" rel="noopener">官方给的建议</a> 是在自己的 <code>go.mod</code> 文件里再次 replace 会正确的版本，或者干脆不要依赖主库。</p><h3 id="golang-内存逃逸-1"><a href="#golang-内存逃逸-1" class="headerlink" title="golang 内存逃逸"></a>golang 内存逃逸</h3><p><a href="https://www.do1618.com/archives/1328/go-%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">Go 内存逃逸详细分析</a></p><h3 id="golang-测试-1"><a href="#golang-测试-1" class="headerlink" title="golang 测试"></a>golang 测试</h3><p><a href="https://colobu.com/2016/07/06/dive-into-go-12/" target="_blank" rel="noopener">测试、性能测试以及代码示例的编写</a></p><h2 id="Productive-1"><a href="#Productive-1" class="headerlink" title="Productive"></a>Productive</h2><h3 id="StarUML-Crack-1"><a href="#StarUML-Crack-1" class="headerlink" title="StarUML Crack"></a>StarUML Crack</h3><p><a href="https://gist.github.com/trandaison/40b1d83618ae8e3d2da59df8c395093a#gistcomment-2723165" target="_blank" rel="noopener">https://gist.github.com/trandaison/40b1d83618ae8e3d2da59df8c395093a#gistcomment-2723165</a></p><h3 id="Dictionary-Extension-1"><a href="#Dictionary-Extension-1" class="headerlink" title="Dictionary Extension"></a>Dictionary Extension</h3><p>用 DictUnifier（已改名为 <a href="https://github.com/jjgod/mac-dictionary-kit" target="_blank" rel="noopener">mac-dictionary-kit</a>）可以将 <a href="http://download.huzheng.org/zh_CN/" target="_blank" rel="noopener">stardict</a> 词典格式转换为 Apple Dict 格式。</p><p>转换教程参考：</p><ul><li><a href="https://www.douban.com/group/topic/9591106/" target="_blank" rel="noopener">https://www.douban.com/group/topic/9591106/</a></li><li><a href="https://github.com/tsoliangwu0130/my-macos/blob/master/misc/dictunifier-stardict.md" target="_blank" rel="noopener">https://github.com/tsoliangwu0130/my-macos/blob/master/misc/dictunifier-stardict.md</a></li></ul><p><a href="https://github.com/ilius/pyglossary" target="_blank" rel="noopener">PyGlossary</a> 是另外一种词典转换工具，不过需要在 <a href="https://developer.apple.com/download/more/" target="_blank" rel="noopener">Apple Developer Downloads</a> 单独下载 Additional Tools for Xcode.</p><p>词典转换后可能会有 css 显示问题，可以参考：</p><ul><li><a href="https://discussions.apple.com/thread/3736067" target="_blank" rel="noopener">https://discussions.apple.com/thread/3736067</a></li></ul><h3 id="禁用-DS-Store-1"><a href="#禁用-DS-Store-1" class="headerlink" title="禁用 .DS_Store"></a>禁用 <code>.DS_Store</code></h3><p>如果在 macOS 的 Finder 里访问网络文件系统（比如 samba），打开目录是会自动在目录下生成 <code>.DS_Store</code> 来存储一些元信息（标签、文件夹颜色、排序等等），这个在其他系统上看起来就非常不顺眼，因此可以通过下面的命令禁用：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.desktopservices DSDontWriteNetworkStores true</span><br></pre></td></tr></table></figure><p>但是这个命令只对网络存储有用，对于本地磁盘还是会生成 <code>.DS_Store</code> 文件，暂时没有方便的办法禁用。</p><h3 id="Jetbrains-back-forward-with-mouse-1"><a href="#Jetbrains-back-forward-with-mouse-1" class="headerlink" title="Jetbrains back/forward with mouse"></a>Jetbrains back/forward with mouse</h3><p>有的鼠标有 Button4 和 Button5 可以在浏览代码时很方便地前进和后退，macOS 系统，在 Visual Studio Code 上正常，但在 Jetbrains 系的 IDE 上默认却是跳转到行首和行尾，解决方法是修改 Button4 和 Button5 默认的键盘快捷键。可以参考<a href="https://stackoverflow.com/questions/14360112/intellij-idea-back-forward-with-mouse" target="_blank" rel="noopener">这个方法</a>修改。</p><h3 id="Vagrant-KVM-1"><a href="#Vagrant-KVM-1" class="headerlink" title="Vagrant + KVM"></a>Vagrant + KVM</h3><p>KVM 比 VirtualBox 的性能更好，在 Linux 环境下推荐使用：</p><p><a href="https://medium.com/@gauthierleonard/kvm-machines-for-vagrant-on-archlinux-1d8863344cb7" target="_blank" rel="noopener">https://medium.com/@gauthierleonard/kvm-machines-for-vagrant-on-archlinux-1d8863344cb7</a></p><p><a href="https://docs.cumulusnetworks.com/display/VX/Vagrant+and+Libvirt+with+KVM+or+QEMU" target="_blank" rel="noopener">https://docs.cumulusnetworks.com/display/VX/Vagrant+and+Libvirt+with+KVM+or+QEMU</a></p><p><a href="https://gist.github.com/yuanying/924ce2ce61b75ab818b5" target="_blank" rel="noopener">https://gist.github.com/yuanying/924ce2ce61b75ab818b5</a></p><h3 id="Windows-10-Ubuntu-18-04-1"><a href="#Windows-10-Ubuntu-18-04-1" class="headerlink" title="Windows 10 + Ubuntu 18.04"></a>Windows 10 + Ubuntu 18.04</h3><p>在 MacOS 上刻录镜像</p><p><a href="https://www.cybrary.it/0p3n/macos-terminal-create-bootable-usb-iso-using-dd/" target="_blank" rel="noopener">https://www.cybrary.it/0p3n/macos-terminal-create-bootable-usb-iso-using-dd/</a></p><p>Ubuntu Installer 无法识别 GPT 分区</p><p><a href="https://arstechnica.com/civis/viewtopic.php?p=36107737&amp;sid=108632491878b9fa937dcbc6d433765f#p36107737" target="_blank" rel="noopener">https://arstechnica.com/civis/viewtopic.php?p=36107737&amp;sid=108632491878b9fa937dcbc6d433765f#p36107737</a></p><p><a href="https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/disabling-secure-boot" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/disabling-secure-boot</a></p><p><a href="https://www.technorms.com/45538/disable-enable-secure-boot-asus-motherboard-uefi-bios-utility" target="_blank" rel="noopener">https://www.technorms.com/45538/disable-enable-secure-boot-asus-motherboard-uefi-bios-utility</a></p><h3 id="VSC-Remote-1"><a href="#VSC-Remote-1" class="headerlink" title="VSC Remote"></a>VSC Remote</h3><p>使用 <a href="https://code.visualstudio.com/docs/remote/ssh" target="_blank" rel="noopener">VSC Remote</a> 可以方便地在 Windows 或者 macOS 下利用 ssh 进行 Linux 环境远程开发和调试。需要安装 <a href="https://code.visualstudio.com/insiders/" target="_blank" rel="noopener">Visual Studio Code insiders</a> 版本。</p><h3 id="Git-1"><a href="#Git-1" class="headerlink" title="Git"></a>Git</h3><h4 id="change-author-of-commits-1"><a href="#change-author-of-commits-1" class="headerlink" title="change author of commits"></a>change author of commits</h4><p><a href="https://makandracards.com/makandra/1717-git-change-author-of-a-commit" target="_blank" rel="noopener">https://makandracards.com/makandra/1717-git-change-author-of-a-commit</a></p><h4 id="grep-logs-1"><a href="#grep-logs-1" class="headerlink" title="grep logs"></a>grep logs</h4><p>有时候需要确认某个 PR 或者 commit 有没有合入特定版本或者分支，可以用下面的命令：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="hljs-built_in">log</span> &lt;branch-or-tag-name&gt; --since 3.weeks --grep &lt;pattern&gt;</span><br></pre></td></tr></table></figure><h3 id="Bazel-1"><a href="#Bazel-1" class="headerlink" title="Bazel"></a>Bazel</h3><p>Bazel 是 Google 的构建工具，CMake 或者 Makefile 的替代品。</p><p><a href="https://medium.com/windmill-engineering/bazel-is-the-worst-build-system-except-for-all-the-others-b369396a9e26" target="_blank" rel="noopener">https://medium.com/windmill-engineering/bazel-is-the-worst-build-system-except-for-all-the-others-b369396a9e26</a></p><h3 id="jq-1"><a href="#jq-1" class="headerlink" title="jq"></a>jq</h3><p>json 的命令行解析工具。参考：<a href="https://stedolan.github.io/jq/tutorial/" target="_blank" rel="noopener">https://stedolan.github.io/jq/tutorial/</a></p><h2 id="Others-1"><a href="#Others-1" class="headerlink" title="Others"></a>Others</h2><h3 id="服务名与端口号映射-1"><a href="#服务名与端口号映射-1" class="headerlink" title="服务名与端口号映射"></a>服务名与端口号映射</h3><p><a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml" target="_blank" rel="noopener">https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml</a></p><h3 id="Flink-1"><a href="#Flink-1" class="headerlink" title="Flink"></a>Flink</h3><p><a href="https://segmentfault.com/a/1190000016901447" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016901447</a></p><p><a href="https://flink.apache.org/" target="_blank" rel="noopener">https://flink.apache.org/</a></p><h3 id="CSS-1"><a href="#CSS-1" class="headerlink" title="CSS"></a>CSS</h3><p>一个学习 css 的网站，支持边学边练：<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/white-space" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/CSS/white-space</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Kubernetes&quot;&gt;&lt;a href=&quot;#Kubernetes&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes&quot;&gt;&lt;/a&gt;Kubernetes&lt;/h2&gt;&lt;h3 id=&quot;api-conventions&quot;&gt;&lt;a href=&quot;#api-conventions&quot; class=&quot;headerlink&quot; title=&quot;api conventions&quot;&gt;&lt;/a&gt;api conventions&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md&lt;/a&gt;&lt;/p&gt;&lt;h3 id=&quot;kube-node-lease&quot;&gt;&lt;a href=&quot;#kube-node-lease&quot; class=&quot;headerlink&quot; title=&quot;kube node lease&quot;&gt;&lt;/a&gt;kube node lease&lt;/h3&gt;&lt;p&gt;kube node lease 用来改善 kubelet 定时更新节点状态对 etcd 造成的压力。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://containers.goffinet.org/k8s/kubectlget.html#what-about-kube-node-lease&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://containers.goffinet.org/k8s/kubectlget.html#what-about-kube-node-lease&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/0009-node-heartbeat.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/0009-node-heartbeat.md&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/docs/concepts/architecture/nodes/#node-controller&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://kubernetes.io/docs/concepts/architecture/nodes/#node-controller&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes-sigs/kubespray/blob/master/docs/kubernetes-reliability.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/kubernetes-sigs/kubespray/blob/master/docs/kubernetes-reliability.md&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="云计算" scheme="http://whypro.github.io/hexo-blog/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Golang" scheme="http://whypro.github.io/hexo-blog/tags/Golang/"/>
    
      <category term="Docker" scheme="http://whypro.github.io/hexo-blog/tags/Docker/"/>
    
      <category term="Kubernetes" scheme="http://whypro.github.io/hexo-blog/tags/Kubernetes/"/>
    
      <category term="K8S" scheme="http://whypro.github.io/hexo-blog/tags/K8S/"/>
    
      <category term="笔记" scheme="http://whypro.github.io/hexo-blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Kubelet PLEG 源码解析</title>
    <link href="http://whypro.github.io/hexo-blog/20190604/Kubelet-PLEG-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://whypro.github.io/hexo-blog/20190604/Kubelet-PLEG-源码解析/</id>
    <published>2019-06-04T04:48:26.000Z</published>
    <updated>2019-07-04T03:44:51.756Z</updated>
    
    <content type="html"><![CDATA[<p>PLEG (pod lifecycle event generator) 是 kubelet 中一个非常重要的模块，它主要完成以下几个目标：</p><ol><li>从 runtime 中获取 pod 当前状态，产生 pod lifecycle events</li><li>从 runtime 中获取 pod 当前状态，更新 kubelet pod cache</li></ol><p>本文我们通过分析 PLEG 模块的源码，来加深对 Kubernetes 的理解，也可以加速在使用过程对一些疑难问题的排查和处理，同时后期可以对一些问题源码进行优化，来解决一些 Kubernetes 本身的坑。</p><a id="more"></a><h2 id="PLEG-初始化"><a href="#PLEG-初始化" class="headerlink" title="PLEG 初始化"></a>PLEG 初始化</h2><p>PLEG 模块在 kubelet 实例创建时初始化，在 <code>pkg/kubelet/kubelet.go</code> 文件中：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMainKubelet</span><span class="hljs-params">(...)</span> <span class="hljs-params">(*Kubelet, error)</span></span> &#123;</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">    klet.pleg = pleg.NewGenericPLEG(klet.containerRuntime, plegChannelCapacity, plegRelistPeriod, klet.podCache, clock.RealClock&#123;&#125;)</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们简单看看 <code>NewGenericPLEG</code> 的实现，见 <code>pkg/kubelet/pleg/generic.go</code>：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// NewGenericPLEG instantiates a new GenericPLEG object and return it.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewGenericPLEG</span><span class="hljs-params">(runtime kubecontainer.Runtime, channelCapacity <span class="hljs-keyword">int</span>,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    relistPeriod time.Duration, cache kubecontainer.Cache, clock clock.Clock)</span> <span class="hljs-title">PodLifecycleEventGenerator</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> &amp;GenericPLEG&#123;</span><br><span class="line">        relistPeriod: relistPeriod,</span><br><span class="line">        runtime:      runtime,</span><br><span class="line">        eventChannel: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *PodLifecycleEvent, channelCapacity),</span><br><span class="line">        podRecords:   <span class="hljs-built_in">make</span>(podRecords),</span><br><span class="line">        cache:        cache,</span><br><span class="line">        clock:        clock,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NewGenericPLEG</code> 函数有几个重要的参数：</p><ul><li><p><code>runtime</code></p><p>实参为 <code>klet.containerRuntime</code>，负责容器运行时的管理，对 pod 或 container 状态的获取、同步和删除都通过 <code>runtime</code> 来操作。</p></li><li><p><code>channelCapacity</code></p><p>实参为 <code>plegChannelCapacity</code>，是 <code>eventChannel</code> 有缓冲 channel 的大小，默认值 <code>1000</code>，也就是单节点最大支持 1000 个 pod lifecycle event 同时触发。</p></li><li><p><code>relistPeriod</code></p><p>实参为 <code>plegRelistPeriod</code>，是 PLEG 检测的周期，默认值 <code>1s</code>。</p></li><li><p><code>cache</code></p><p>实参为 <code>klet.podCache</code>，保存着所有 pod 状态的缓存，kubelet 通过 container runtime 更新 pod 缓存。</p></li></ul><p><code>plegChannelCapacity</code> 和 <code>plegRelistPeriod</code> 这两个常量的定义在 <code>pkg/kubelet/kubelet.go</code> 文件里：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> (</span><br><span class="line">    plegChannelCapacity = <span class="hljs-number">1000</span></span><br><span class="line"></span><br><span class="line">    plegRelistPeriod = time.Second * <span class="hljs-number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="PLEG-接口定义"><a href="#PLEG-接口定义" class="headerlink" title="PLEG 接口定义"></a>PLEG 接口定义</h2><p><code>NewGenericPLEG</code> 返回的类型 <code>*GenericPLEG</code> 实现了 <code>PodLifecycleEventGenerator</code> 接口，我们暂且忽略 <code>GenericPLEG</code> 结构体的具体实现，先分析一下 <code>PodLifecycleEventGenerator</code> 接口，这个接口在 <code>pkg/kubelet/pleg/pleg.go</code> 文件中定义，包含三个方法：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// PodLifecycleEventGenerator contains functions for generating pod life cycle events.</span></span><br><span class="line"><span class="hljs-keyword">type</span> PodLifecycleEventGenerator <span class="hljs-keyword">interface</span> &#123;</span><br><span class="line">    Start()</span><br><span class="line">    Watch() <span class="hljs-keyword">chan</span> *PodLifecycleEvent</span><br><span class="line">    Healthy() (<span class="hljs-keyword">bool</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Start</code> 启动 PLEG。</li><li><code>Watch</code> 返回一个 channel，pod lifecycle events 会发送到这个 channel 里，kubelet 通过这个 channel 来获取事件，执行处理动作。</li><li><code>Healty</code> 返回 PLEG 的健康状态。kubelet 通过这个函数判断 PLEG 是否健康。</li></ul><p>我们再看看 pod lifecycle event 的定义，见 <code>pkg/kubelet/pleg/pleg.go</code> 文件：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// PodLifeCycleEventType define the event type of pod life cycle events.</span></span><br><span class="line"><span class="hljs-keyword">type</span> PodLifeCycleEventType <span class="hljs-keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> (</span><br><span class="line">    <span class="hljs-comment">// ContainerStarted - event type when the new state of container is running.</span></span><br><span class="line">    ContainerStarted PodLifeCycleEventType = <span class="hljs-string">"ContainerStarted"</span></span><br><span class="line">    <span class="hljs-comment">// ContainerDied - event type when the new state of container is exited.</span></span><br><span class="line">    ContainerDied PodLifeCycleEventType = <span class="hljs-string">"ContainerDied"</span></span><br><span class="line">    <span class="hljs-comment">// ContainerRemoved - event type when the old state of container is exited.</span></span><br><span class="line">    ContainerRemoved PodLifeCycleEventType = <span class="hljs-string">"ContainerRemoved"</span></span><br><span class="line">    <span class="hljs-comment">// PodSync is used to trigger syncing of a pod when the observed change of</span></span><br><span class="line">    <span class="hljs-comment">// the state of the pod cannot be captured by any single event above.</span></span><br><span class="line">    PodSync PodLifeCycleEventType = <span class="hljs-string">"PodSync"</span></span><br><span class="line">    <span class="hljs-comment">// ContainerChanged - event type when the new state of container is unknown.</span></span><br><span class="line">    ContainerChanged PodLifeCycleEventType = <span class="hljs-string">"ContainerChanged"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// PodLifecycleEvent is an event that reflects the change of the pod state.</span></span><br><span class="line"><span class="hljs-keyword">type</span> PodLifecycleEvent <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">    <span class="hljs-comment">// The pod ID.</span></span><br><span class="line">    ID types.UID</span><br><span class="line">    <span class="hljs-comment">// The type of the event.</span></span><br><span class="line">    Type PodLifeCycleEventType</span><br><span class="line">    <span class="hljs-comment">// The accompanied data which varies based on the event type.</span></span><br><span class="line">    <span class="hljs-comment">//   - ContainerStarted/ContainerStopped: the container name (string).</span></span><br><span class="line">    <span class="hljs-comment">//   - All other event types: unused.</span></span><br><span class="line">    Data <span class="hljs-keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PodLifecycleEvent</code> 结构保存着以下信息：</p><ul><li><p><code>ID</code>: pod ID</p></li><li><p><code>Type</code>: 事件类型</p><p><code>PodLifecycleEventType</code> 有以下几种：</p><ul><li><code>ContainerStarted</code>: 容器状态变为 <code>Running</code></li><li><code>ContainerDied</code>: 容器状态变为 <code>Exited</code></li><li><code>ContainerRemoved</code>: 容器消失</li><li><code>PodSync</code>: PLEG 中未使用</li><li><code>ContainerChanged</code>: 容器状态变为 <code>Unknown</code></li></ul></li><li><p><code>Data</code>: 容器 ID（源码注释是 container name，应该是错误）</p></li></ul><h2 id="PLEG-接口调用"><a href="#PLEG-接口调用" class="headerlink" title="PLEG 接口调用"></a>PLEG 接口调用</h2><p>下面我们看看 kubelet 是在哪里使用 <code>PodLifecycleEventGenerator</code> 接口里的三个方法的。</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>kubelet 在 <code>Run</code> 函数中执行 <code>Start</code>，启动 PLEG。</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Run starts the kubelet reacting to config updates</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *Kubelet)</span> <span class="hljs-title">Run</span><span class="hljs-params">(updates &lt;-<span class="hljs-keyword">chan</span> kubetypes.PodUpdate)</span></span> &#123;</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Start the pod lifecycle event generator.</span></span><br><span class="line">    kl.pleg.Start()</span><br><span class="line">    kl.syncLoop(updates, kl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>最后在 <code>syncLoop</code> 中执行 <code>Watch</code>，获取到这个关键的 channel <code>plegCh</code>，然后在 <code>syncLoopIteration</code> 函数中从 channel 中获取事件，进行处理。</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// syncLoop is the main loop for processing changes. It watches for changes from</span></span><br><span class="line"><span class="hljs-comment">// three channels (file, apiserver, and http) and creates a union of them. For</span></span><br><span class="line"><span class="hljs-comment">// any new change seen, will run a sync against desired state and running state. If</span></span><br><span class="line"><span class="hljs-comment">// no changes are seen to the configuration, will synchronize the last known desired</span></span><br><span class="line"><span class="hljs-comment">// state every sync-frequency seconds. Never returns.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *Kubelet)</span> <span class="hljs-title">syncLoop</span><span class="hljs-params">(updates &lt;-<span class="hljs-keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler)</span></span> &#123;</span><br><span class="line">    klog.Info(<span class="hljs-string">"Starting kubelet main sync loop."</span>)</span><br><span class="line">    <span class="hljs-comment">// The syncTicker wakes up kubelet to checks if there are any pod workers</span></span><br><span class="line">    <span class="hljs-comment">// that need to be sync'd. A one-second period is sufficient because the</span></span><br><span class="line">    <span class="hljs-comment">// sync interval is defaulted to 10s.</span></span><br><span class="line">    syncTicker := time.NewTicker(time.Second)</span><br><span class="line">    <span class="hljs-keyword">defer</span> syncTicker.Stop()</span><br><span class="line">    housekeepingTicker := time.NewTicker(housekeepingPeriod)</span><br><span class="line">    <span class="hljs-keyword">defer</span> housekeepingTicker.Stop()</span><br><span class="line">    plegCh := kl.pleg.Watch()</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">    <span class="hljs-keyword">for</span> &#123;</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">        <span class="hljs-keyword">if</span> !kl.syncLoopIteration(updates, handler, syncTicker.C, housekeepingTicker.C, plegCh) &#123;</span><br><span class="line">            <span class="hljs-keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>syncLoopIteration</code> 是 kubelet 事件处理的核心函数，它的职责是从多个不同类型的 channel 中获取事件，然后分发给不同的 handler 去处理。</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// syncLoopIteration reads from various channels and dispatches pods to the</span></span><br><span class="line"><span class="hljs-comment">// given handler.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *Kubelet)</span> <span class="hljs-title">syncLoopIteration</span><span class="hljs-params">(configCh &lt;-<span class="hljs-keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    syncCh &lt;-<span class="hljs-keyword">chan</span> time.Time, housekeepingCh &lt;-<span class="hljs-keyword">chan</span> time.Time, plegCh &lt;-<span class="hljs-keyword">chan</span> *pleg.PodLifecycleEvent)</span> <span class="hljs-title">bool</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">select</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">case</span> u, open := &lt;-configCh:</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    <span class="hljs-keyword">case</span> e := &lt;-plegCh:</span><br><span class="line">        <span class="hljs-keyword">if</span> isSyncPodWorthy(e) &#123;</span><br><span class="line">            <span class="hljs-comment">// PLEG event for a pod; sync it.</span></span><br><span class="line">            <span class="hljs-keyword">if</span> pod, ok := kl.podManager.GetPodByUID(e.ID); ok &#123;</span><br><span class="line">                klog.V(<span class="hljs-number">2</span>).Infof(<span class="hljs-string">"SyncLoop (PLEG): %q, event: %#v"</span>, format.Pod(pod), e)</span><br><span class="line">                handler.HandlePodSyncs([]*v1.Pod&#123;pod&#125;)</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                <span class="hljs-comment">// If the pod no longer exists, ignore the event.</span></span><br><span class="line">                klog.V(<span class="hljs-number">4</span>).Infof(<span class="hljs-string">"SyncLoop (PLEG): ignore irrelevant event: %#v"</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> e.Type == pleg.ContainerDied &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> containerID, ok := e.Data.(<span class="hljs-keyword">string</span>); ok &#123;</span><br><span class="line">                kl.cleanUpContainersInPod(e.ID, containerID)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="hljs-keyword">case</span> &lt;-syncCh:</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    <span class="hljs-keyword">case</span> update := &lt;-kl.livenessManager.Updates():</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    <span class="hljs-keyword">case</span> &lt;-housekeepingCh:</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>configCh</code> 负责获取 pod 配置更新事件。</li><li><code>syncCh</code> 是一个定时器，定时获取 pod sync 事件，对需要的 pod 进行同步，默认是 <code>1s</code>。</li><li><code>housekeepingCh</code> 也是一个定时器，定时获取 pod Cleanup 事件，对需要的 pod 进行清理，默认值是 <code>2s</code></li><li><code>plegCh</code> 负责获取 pod lifecycle 事件</li><li><code>livenessManager.Updates</code> 负责获取 liveness probe 事件</li><li><code>handler</code> 是个事件处理接口 (<code>SyncHandler</code>)，获取到上面的时间后调用对应的事件处理方法，kubelet 主类本身默认实现了这个接口。</li></ul><p>在这里我们只关心对 pod lifecycle 事件的处理：从代码上看，kubelet 收到 pod lifecycle 事件之后，首先判断事件类型是不是值得触发 pod 同步，如果是 <code>ContainerRemoved</code>，则忽略该事件。如果是其他事件，且 pod 信息还没有被删除，调用 <code>HandlePodSyncs</code> 产生 UpdatePod 事件，交给 kubelet pod Worker 进行异步更新。最后，如果是 <code>ContainerDied</code> 事件，为了防止退出容器堆积，会按照一定的策略移除已退出的容器。</p><h3 id="健康检测"><a href="#健康检测" class="headerlink" title="健康检测"></a>健康检测</h3><p>kubelet 对 PLEG 模块的健康检测，通过 runtimeState 来管理，kubelet 在初始化 PLEG 后通过 <code>addHealthCheck</code> 将 <code>klet.pleg.Healthy</code> 健康监测方法注册至 runtimeState，runtimeState 定时调用 <code>Healthy</code> 方法检查 PLEG 的健康状态。参见 <code>pkg/kubelet/kubelet.go</code>：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMainKubelet</span><span class="hljs-params">(...)</span> <span class="hljs-params">(*Kubelet, error)</span></span> &#123;</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">    klet.runtimeState.addHealthCheck(<span class="hljs-string">"PLEG"</span>, klet.pleg.Healthy)</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addHealthCheck</code> 实现在 <code>pkg/kubelet/runtime.go</code> 中：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *runtimeState)</span> <span class="hljs-title">addHealthCheck</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, f healthCheckFnType)</span></span> &#123;</span><br><span class="line">    s.Lock()</span><br><span class="line">    <span class="hljs-keyword">defer</span> s.Unlock()</span><br><span class="line">    s.healthChecks = <span class="hljs-built_in">append</span>(s.healthChecks, &amp;healthCheck&#123;name: name, fn: f&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>syncLoop</code> 中定时执行 <code>runtimeErrors</code>，这里 <code>syncLoop</code> 采用了简单的 backoff 机制，如果 runtimeState 各个模块状态都正常，则每次循环默认 sleep <code>100ms</code>，如果出现异常状态，则 sleep duration * 2，最大变为 <code>5s</code>，参见 <code>pkg/kubelet/kubelet.go</code>：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *Kubelet)</span> <span class="hljs-title">syncLoop</span><span class="hljs-params">(updates &lt;-<span class="hljs-keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler)</span></span> &#123;</span><br><span class="line">    klog.Info(<span class="hljs-string">"Starting kubelet main sync loop."</span>)</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">    <span class="hljs-keyword">const</span> (</span><br><span class="line">        base   = <span class="hljs-number">100</span> * time.Millisecond</span><br><span class="line">        max    = <span class="hljs-number">5</span> * time.Second</span><br><span class="line">        factor = <span class="hljs-number">2</span></span><br><span class="line">    )</span><br><span class="line">    duration := base</span><br><span class="line">    <span class="hljs-keyword">for</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> err := kl.runtimeState.runtimeErrors(); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">            klog.Infof(<span class="hljs-string">"skipping pod synchronization - %v"</span>, err)</span><br><span class="line">            <span class="hljs-comment">// exponential backoff</span></span><br><span class="line">            time.Sleep(duration)</span><br><span class="line">            duration = time.Duration(math.Min(<span class="hljs-keyword">float64</span>(max), factor*<span class="hljs-keyword">float64</span>(duration)))</span><br><span class="line">            <span class="hljs-keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// reset backoff if we have a success</span></span><br><span class="line">        duration = base</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runtimeErrors</code> 实现在 <code>pkg/kubelet/runtime.go</code> 中：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *runtimeState)</span> <span class="hljs-title">runtimeErrors</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line">    s.RLock()</span><br><span class="line">    <span class="hljs-keyword">defer</span> s.RUnlock()</span><br><span class="line">    errs := []error&#123;&#125;</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">    <span class="hljs-keyword">for</span> _, hc := <span class="hljs-keyword">range</span> s.healthChecks &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> ok, err := hc.fn(); !ok &#123;</span><br><span class="line">            errs = <span class="hljs-built_in">append</span>(errs, fmt.Errorf(<span class="hljs-string">"%s is not healthy: %v"</span>, hc.name, err))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> utilerrors.NewAggregate(errs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也是依次执行各个模块事先注册的 healthy check 函数，如果任何一个模块返回 false，则认为整个 runtimeState 的状态为 unhealthy。</p><h2 id="Generic-PLEG-实现"><a href="#Generic-PLEG-实现" class="headerlink" title="Generic PLEG 实现"></a>Generic PLEG 实现</h2><p>我们再回到 <code>PodLifecycleEventGenerator</code> 接口的实现 —— <code>GenericPLEG</code> 的定义，见 <code>pkg/kubelet/pleg/generic.go</code> 文件：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> GenericPLEG <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">    <span class="hljs-comment">// The period for relisting.</span></span><br><span class="line">    relistPeriod time.Duration</span><br><span class="line">    <span class="hljs-comment">// The container runtime.</span></span><br><span class="line">    runtime kubecontainer.Runtime</span><br><span class="line">    <span class="hljs-comment">// The channel from which the subscriber listens events.</span></span><br><span class="line">    eventChannel <span class="hljs-keyword">chan</span> *PodLifecycleEvent</span><br><span class="line">    <span class="hljs-comment">// The internal cache for pod/container information.</span></span><br><span class="line">    podRecords podRecords</span><br><span class="line">    <span class="hljs-comment">// Time of the last relisting.</span></span><br><span class="line">    relistTime atomic.Value</span><br><span class="line">    <span class="hljs-comment">// Cache for storing the runtime states required for syncing pods.</span></span><br><span class="line">    cache kubecontainer.Cache</span><br><span class="line">    <span class="hljs-comment">// For testability.</span></span><br><span class="line">    clock clock.Clock</span><br><span class="line">    <span class="hljs-comment">// Pods that failed to have their status retrieved during a relist. These pods will be</span></span><br><span class="line">    <span class="hljs-comment">// retried during the next relisting.</span></span><br><span class="line">    podsToReinspect <span class="hljs-keyword">map</span>[types.UID]*kubecontainer.Pod</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>relistPeriod</code> 是 PLEG 检测周期，默认为 <code>1s</code></li><li><code>runtime</code> 是 container runtime，负责获取 pod 和 container 的状态信息</li><li><code>podRecords</code> 缓存 pod 以及 Container 的基本信息</li><li><code>cache</code> 缓存 pod 的运行时状态</li><li><code>eventChannel</code> 是 PLEG 通过对比 pod 缓存信息和当前信息，生成 pod lifecycle events 的 channel</li><li><code>relistTime</code> 是上一次执行完 PLEG 检测的时刻</li><li><code>podsToReinspect</code> 保存 PLEG 检测失败的 Pod，以便下次再次检测</li><li><code>clock</code> 是一个时间管理对象，作用是获取当前时间</li></ul><p>然后我们基于接口方法，来分析 <code>GenericPLEG</code> 的实现：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Start spawns a goroutine to relist periodically.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *GenericPLEG)</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">go</span> wait.Until(g.relist, g.relistPeriod, wait.NeverStop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Start</code> 启动了一个 goroutine，以 <code>1s</code> 的间隔无限执行 <code>relist</code> 函数。这里要注意 <code>wait.Until</code> 的行为，如果 <code>relist</code> 执行时间大于 period 设置的值，则时间窗会滑动至 relist 执行完毕的那一时刻。也就是说如果 period 是 <code>1s</code>，relist 从第 <code>0s</code> 开始，花了 <code>10s</code>，结束时是第 <code>10s</code>，那么下一次 relist 会从第 <code>11s</code> 开始执行。</p><p>relist 函数的实现如下：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// relist queries the container runtime for list of pods/containers, compare</span></span><br><span class="line"><span class="hljs-comment">// with the internal pods/containers, and generates events accordingly.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *GenericPLEG)</span> <span class="hljs-title">relist</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    klog.V(<span class="hljs-number">5</span>).Infof(<span class="hljs-string">"GenericPLEG: Relisting"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> lastRelistTime := g.getRelistTime(); !lastRelistTime.IsZero() &#123;</span><br><span class="line">        metrics.PLEGRelistInterval.Observe(metrics.SinceInSeconds(lastRelistTime))</span><br><span class="line">        metrics.DeprecatedPLEGRelistInterval.Observe(metrics.SinceInMicroseconds(lastRelistTime))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timestamp := g.clock.Now()</span><br><span class="line">    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">        metrics.PLEGRelistDuration.Observe(metrics.SinceInSeconds(timestamp))</span><br><span class="line">        metrics.DeprecatedPLEGRelistLatency.Observe(metrics.SinceInMicroseconds(timestamp))</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Get all the pods.</span></span><br><span class="line">    podList, err := g.runtime.GetPods(<span class="hljs-literal">true</span>)</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="hljs-string">"GenericPLEG: Unable to retrieve pods: %v"</span>, err)</span><br><span class="line">        <span class="hljs-keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.updateRelistTime(timestamp)</span><br><span class="line"></span><br><span class="line">    pods := kubecontainer.Pods(podList)</span><br><span class="line">    g.podRecords.setCurrent(pods)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Compare the old and the current pods, and generate events.</span></span><br><span class="line">    eventsByPodID := <span class="hljs-keyword">map</span>[types.UID][]*PodLifecycleEvent&#123;&#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> pid := <span class="hljs-keyword">range</span> g.podRecords &#123;</span><br><span class="line">        oldPod := g.podRecords.getOld(pid)</span><br><span class="line">        pod := g.podRecords.getCurrent(pid)</span><br><span class="line">        <span class="hljs-comment">// Get all containers in the old and the new pod.</span></span><br><span class="line">        allContainers := getContainersFromPods(oldPod, pod)</span><br><span class="line">        <span class="hljs-keyword">for</span> _, container := <span class="hljs-keyword">range</span> allContainers &#123;</span><br><span class="line">            events := computeEvents(oldPod, pod, &amp;container.ID)</span><br><span class="line">            <span class="hljs-keyword">for</span> _, e := <span class="hljs-keyword">range</span> events &#123;</span><br><span class="line">                updateEvents(eventsByPodID, e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">var</span> needsReinspection <span class="hljs-keyword">map</span>[types.UID]*kubecontainer.Pod</span><br><span class="line">    <span class="hljs-keyword">if</span> g.cacheEnabled() &#123;</span><br><span class="line">        needsReinspection = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[types.UID]*kubecontainer.Pod)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// If there are events associated with a pod, we should update the</span></span><br><span class="line">    <span class="hljs-comment">// podCache.</span></span><br><span class="line">    <span class="hljs-keyword">for</span> pid, events := <span class="hljs-keyword">range</span> eventsByPodID &#123;</span><br><span class="line">        pod := g.podRecords.getCurrent(pid)</span><br><span class="line">        <span class="hljs-keyword">if</span> g.cacheEnabled() &#123;</span><br><span class="line">            <span class="hljs-comment">// updateCache() will inspect the pod and update the cache. If an</span></span><br><span class="line">            <span class="hljs-comment">// error occurs during the inspection, we want PLEG to retry again</span></span><br><span class="line">            <span class="hljs-comment">// in the next relist. To achieve this, we do not update the</span></span><br><span class="line">            <span class="hljs-comment">// associated podRecord of the pod, so that the change will be</span></span><br><span class="line">            <span class="hljs-comment">// detect again in the next relist.</span></span><br><span class="line">            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> If many pods changed during the same relist period,</span></span><br><span class="line">            <span class="hljs-comment">// inspecting the pod and getting the PodStatus to update the cache</span></span><br><span class="line">            <span class="hljs-comment">// serially may take a while. We should be aware of this and</span></span><br><span class="line">            <span class="hljs-comment">// parallelize if needed.</span></span><br><span class="line">            <span class="hljs-keyword">if</span> err := g.updateCache(pod, pid); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">                <span class="hljs-comment">// Rely on updateCache calling GetPodStatus to log the actual error.</span></span><br><span class="line">                klog.V(<span class="hljs-number">4</span>).Infof(<span class="hljs-string">"PLEG: Ignoring events for pod %s/%s: %v"</span>, pod.Name, pod.Namespace, err)</span><br><span class="line"></span><br><span class="line">                <span class="hljs-comment">// make sure we try to reinspect the pod during the next relisting</span></span><br><span class="line">                needsReinspection[pid] = pod</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">continue</span></span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> _, found := g.podsToReinspect[pid]; found &#123;</span><br><span class="line">                <span class="hljs-comment">// this pod was in the list to reinspect and we did so because it had events, so remove it</span></span><br><span class="line">                <span class="hljs-comment">// from the list (we don't want the reinspection code below to inspect it a second time in</span></span><br><span class="line">                <span class="hljs-comment">// this relist execution)</span></span><br><span class="line">                <span class="hljs-built_in">delete</span>(g.podsToReinspect, pid)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// Update the internal storage and send out the events.</span></span><br><span class="line">        g.podRecords.update(pid)</span><br><span class="line">        <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> events &#123;</span><br><span class="line">            <span class="hljs-comment">// Filter out events that are not reliable and no other components use yet.</span></span><br><span class="line">            <span class="hljs-keyword">if</span> events[i].Type == ContainerChanged &#123;</span><br><span class="line">                <span class="hljs-keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">select</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">case</span> g.eventChannel &lt;- events[i]:</span><br><span class="line">            <span class="hljs-keyword">default</span>:</span><br><span class="line">                metrics.PLEGDiscardEvents.WithLabelValues().Inc()</span><br><span class="line">                klog.Error(<span class="hljs-string">"event channel is full, discard this relist() cycle event"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> g.cacheEnabled() &#123;</span><br><span class="line">        <span class="hljs-comment">// reinspect any pods that failed inspection during the previous relist</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(g.podsToReinspect) &gt; <span class="hljs-number">0</span> &#123;</span><br><span class="line">            klog.V(<span class="hljs-number">5</span>).Infof(<span class="hljs-string">"GenericPLEG: Reinspecting pods that previously failed inspection"</span>)</span><br><span class="line">            <span class="hljs-keyword">for</span> pid, pod := <span class="hljs-keyword">range</span> g.podsToReinspect &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> err := g.updateCache(pod, pid); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">                    <span class="hljs-comment">// Rely on updateCache calling GetPodStatus to log the actual error.</span></span><br><span class="line">                    klog.V(<span class="hljs-number">5</span>).Infof(<span class="hljs-string">"PLEG: pod %s/%s failed reinspection: %v"</span>, pod.Name, pod.Namespace, err)</span><br><span class="line">                    needsReinspection[pid] = pod</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// Update the cache timestamp.  This needs to happen *after*</span></span><br><span class="line">        <span class="hljs-comment">// all pods have been properly updated in the cache.</span></span><br><span class="line">        g.cache.UpdateTime(timestamp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// make sure we retain the list of pods that need reinspecting the next time relist is called</span></span><br><span class="line">    g.podsToReinspect = needsReinspection</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>relist 中 export 了两个监控指标：<code>relist_interval</code> 和 <code>relist_latency</code>，它们俩的关系是：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">relist_interval = relist_latency + relist_period</span><br></pre></td></tr></table></figure><p>整个 relist 的流程大致为：</p><ol><li>从 container runtime 获取所有 Pod，更新至 podRecords 的 current state</li><li>遍历 podRecords，对比 current state 和 old state，产生 lifecycle events 并按照 pod 分组</li><li>遍历 pod 和 对应的 events，从 container runtime 获取 pod status 更新 cache（记录失败的 Pod，准备下次重试），并将 PLEG event （除了 ContainerChanged 事件）放入 eventChannel</li><li>遍历上次 relist 更新 cache 失败的 Pod，尝试再次获取 pod status 更新 cache</li></ol><p>relist 函数通过访问 container runtime 将 pod 和 container 的实际状态更新至 kubelet 的 pod cache。其他模块 (pod worker) 使用的 pod cache，都由 PLEG 模块更新。</p><p>pod lifecycle event 的生成通过 <code>generateEvents</code> 函数比较 old state 和 new state 来实现：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateEvents</span><span class="hljs-params">(podID types.UID, cid <span class="hljs-keyword">string</span>, oldState, newState plegContainerState)</span> []*<span class="hljs-title">PodLifecycleEvent</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> newState == oldState &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">klog.V(<span class="hljs-number">4</span>).Infof(<span class="hljs-string">"GenericPLEG: %v/%v: %v -&gt; %v"</span>, podID, cid, oldState, newState)</span><br><span class="line"><span class="hljs-keyword">switch</span> newState &#123;</span><br><span class="line"><span class="hljs-keyword">case</span> plegContainerRunning:</span><br><span class="line"><span class="hljs-keyword">return</span> []*PodLifecycleEvent&#123;&#123;ID: podID, Type: ContainerStarted, Data: cid&#125;&#125;</span><br><span class="line"><span class="hljs-keyword">case</span> plegContainerExited:</span><br><span class="line"><span class="hljs-keyword">return</span> []*PodLifecycleEvent&#123;&#123;ID: podID, Type: ContainerDied, Data: cid&#125;&#125;</span><br><span class="line"><span class="hljs-keyword">case</span> plegContainerUnknown:</span><br><span class="line"><span class="hljs-keyword">return</span> []*PodLifecycleEvent&#123;&#123;ID: podID, Type: ContainerChanged, Data: cid&#125;&#125;</span><br><span class="line"><span class="hljs-keyword">case</span> plegContainerNonExistent:</span><br><span class="line"><span class="hljs-keyword">switch</span> oldState &#123;</span><br><span class="line"><span class="hljs-keyword">case</span> plegContainerExited:</span><br><span class="line"><span class="hljs-comment">// We already reported that the container died before.</span></span><br><span class="line"><span class="hljs-keyword">return</span> []*PodLifecycleEvent&#123;&#123;ID: podID, Type: ContainerRemoved, Data: cid&#125;&#125;</span><br><span class="line"><span class="hljs-keyword">default</span>:</span><br><span class="line"><span class="hljs-keyword">return</span> []*PodLifecycleEvent&#123;&#123;ID: podID, Type: ContainerDied, Data: cid&#125;, &#123;ID: podID, Type: ContainerRemoved, Data: cid&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">default</span>:</span><br><span class="line"><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">"unrecognized container state: %v"</span>, newState))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便看看 Container Runtime 接口，对于 Container Runtime，我们主要关注 PLEG 用到的两个方法 <code>GetPods</code> 和 <code>GetPodStatus</code>，参照 <code>pkg/kubelet/container/runtime.go</code> 文件：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Runtime interface defines the interfaces that should be implemented</span></span><br><span class="line"><span class="hljs-comment">// by a container runtime.</span></span><br><span class="line"><span class="hljs-comment">// Thread safety is required from implementations of this interface.</span></span><br><span class="line"><span class="hljs-keyword">type</span> Runtime <span class="hljs-keyword">interface</span> &#123;</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">    <span class="hljs-comment">// GetPods returns a list of containers grouped by pods. The boolean parameter</span></span><br><span class="line">    <span class="hljs-comment">// specifies whether the runtime returns all containers including those already</span></span><br><span class="line">    <span class="hljs-comment">// exited and dead containers (used for garbage collection).</span></span><br><span class="line">    GetPods(all <span class="hljs-keyword">bool</span>) ([]*Pod, error)</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">    <span class="hljs-comment">// GetPodStatus retrieves the status of the pod, including the</span></span><br><span class="line">    <span class="hljs-comment">// information of all containers in the pod that are visible in Runtime.</span></span><br><span class="line">    GetPodStatus(uid types.UID, name, namespace <span class="hljs-keyword">string</span>) (*PodStatus, error)</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GetPods</code> 主要是获取 pod 列表和 pod/container 的基本信息，<code>GetPodStatus</code> 则获取单个 pod 内所有容器的详细状态信息（包括 pod IP 和 runtime 返回的一些状态）。</p><p>关于事件通知，上面提到 PLEG 会将 pod lifecycle events 放入一个 channel，<code>Watch</code> 方法返回了这个 channel。</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Watch returns a channel from which the subscriber can receive PodLifecycleEvent</span></span><br><span class="line"><span class="hljs-comment">// events.</span></span><br><span class="line"><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> support multiple subscribers.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *GenericPLEG)</span> <span class="hljs-title">Watch</span><span class="hljs-params">()</span> <span class="hljs-title">chan</span> *<span class="hljs-title">PodLifecycleEvent</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> g.eventChannel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 PLEG 如何判断自己工作是否正常呢？通过暴露 <code>Healthy</code> 方法，<code>GenericPLEG</code> 保存了上一次开始执行 relist 的时间戳，<code>Healthy</code> 方法判断与当前时间的间隔，只要大于阈值，则认为 PLEG unhealthy。</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Healthy check if PLEG work properly.</span></span><br><span class="line"><span class="hljs-comment">// relistThreshold is the maximum interval between two relist.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *GenericPLEG)</span> <span class="hljs-title">Healthy</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">    relistTime := g.getRelistTime()</span><br><span class="line">    <span class="hljs-keyword">if</span> relistTime.IsZero() &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, fmt.Errorf(<span class="hljs-string">"pleg has yet to be successful"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    elapsed := g.clock.Since(relistTime)</span><br><span class="line">    <span class="hljs-keyword">if</span> elapsed &gt; relistThreshold &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, fmt.Errorf(<span class="hljs-string">"pleg was last seen active %v ago; threshold is %v"</span>, elapsed, relistThreshold)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个阈值在 <code>pkg/kubelet/pleg/generic.go</code> 中定义：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> (</span><br><span class="line">    <span class="hljs-comment">// The threshold needs to be greater than the relisting period + the</span></span><br><span class="line">    <span class="hljs-comment">// relisting time, which can vary significantly. Set a conservative</span></span><br><span class="line">    <span class="hljs-comment">// threshold to avoid flipping between healthy and unhealthy.</span></span><br><span class="line">    relistThreshold = <span class="hljs-number">3</span> * time.Minute</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>默认是 <code>3m</code>，也就是说只要 relist 执行时间超过 3 分钟，则认为 PLEG unhealthy。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后我们总结一下整个流程：</p><ol><li>kubelet 创建并启动 PLEG 模块，watch pod lifecycle event</li><li>PLEG 模块每隔 <code>1s</code> 执行 relist，relist 完成两个目标：<ol><li>获取 pod list，对比 pod 的 old state 和 new state，产生 PLEG events</li><li>依次获取 pod status，并更新 pod cache</li></ol></li><li>kubelet watch 到 pod lifecycle events，产生 update pod 事件通知 pod worker 执行 sync pod 操作</li><li>kubelet 持续检查 runtime state (PLEG) 的健康状态</li></ol><p>本文对下面几个方面没有深入介绍，后面有空会写单独的文章将源码解析分享出来：</p><ul><li>kubelet sync loop iteration</li><li>pod worker 的 sync pod 机制</li><li>container runtime</li><li>node status 节点状态控制</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PLEG (pod lifecycle event generator) 是 kubelet 中一个非常重要的模块，它主要完成以下几个目标：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;从 runtime 中获取 pod 当前状态，产生 pod lifecycle events&lt;/li&gt;&lt;li&gt;从 runtime 中获取 pod 当前状态，更新 kubelet pod cache&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;本文我们通过分析 PLEG 模块的源码，来加深对 Kubernetes 的理解，也可以加速在使用过程对一些疑难问题的排查和处理，同时后期可以对一些问题源码进行优化，来解决一些 Kubernetes 本身的坑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="云计算" scheme="http://whypro.github.io/hexo-blog/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Kubernetes" scheme="http://whypro.github.io/hexo-blog/tags/Kubernetes/"/>
    
      <category term="K8S" scheme="http://whypro.github.io/hexo-blog/tags/K8S/"/>
    
      <category term="Kubelet" scheme="http://whypro.github.io/hexo-blog/tags/Kubelet/"/>
    
  </entry>
  
  <entry>
    <title>二叉树两个节点之间的最大距离</title>
    <link href="http://whypro.github.io/hexo-blog/20190523/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB/"/>
    <id>http://whypro.github.io/hexo-blog/20190523/二叉树两个节点之间的最大距离/</id>
    <published>2019-05-23T13:01:16.000Z</published>
    <updated>2019-06-02T09:10:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，求它两个节点之间的最大距离。</p><p>比如二叉树：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p>的最大距离为 3。</p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>刚看到这个题目时有点懵，仔细分析了一下，求根节点为 Root 的二叉树中两个节点的最大距离，需要分两种情况考虑：</p><h3 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h3><p>如果最大距离经过了 Root，则最大距离：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MaxDistance(root) = MaxDepth(root.Left) + MaxDepth(root.Right) + 2</span><br></pre></td></tr></table></figure><p>假设 <code>root</code> 节点为 <code>1</code>，示例图为：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">  // \\</span><br><span class="line">  2   3</span><br><span class="line">// \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><h3 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h3><p>如果最大距离没有经过 Root，则最大距离：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MaxDistance(root) = max(MaxDistance(root.Left), MaxDistance(root.Right))</span><br></pre></td></tr></table></figure><p>假设 <code>root</code> 节点为 <code>1</code>，示例图为：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     /</span><br><span class="line">    2</span><br><span class="line">  // \\</span><br><span class="line">  3   4</span><br><span class="line">//     \\</span><br><span class="line">5       6</span><br></pre></td></tr></table></figure><p>想必大家已经通过公式看出规律来了，父节点的 <code>maxDistance</code> 可以通过两个子节点的 <code>maxDistance</code> 和 <code>maxDepth</code> 求出，合并 <code>1</code> <code>2</code> 两种情况，最终的状态转移方程如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MaxDistance(root) = max(max(MaxDistance(root.Left), MaxDistance(root.Right)), MaxDepth(root.Left) + MaxDepth(root.Right) + 2)</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们需要有个数据结构保存中间结果，即 <code>maxDepth</code> 和 <code>maxDistance</code>。</p><p>另外，这里我们确定 <code>root</code> 节点的深度为 <code>0</code>，因此将 <code>nil</code> 节点的深度初始化为 <code>-1</code>。</p><p>整个算法使用了递归方式。</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> TreeNode <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="hljs-keyword">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">type</span> result <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">    maxDepth    <span class="hljs-keyword">int</span></span><br><span class="line">    maxDistance <span class="hljs-keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMaxDistance</span><span class="hljs-params">(root *TreeNode)</span> *<span class="hljs-title">result</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> &amp;result&#123;</span><br><span class="line">            maxDepth:    <span class="hljs-number">-1</span>,</span><br><span class="line">            maxDistance: <span class="hljs-number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    left := getMaxDistance(root.Left)</span><br><span class="line">    right := getMaxDistance(root.Right)</span><br><span class="line">    maxDepth := max(left.maxDepth+<span class="hljs-number">1</span>, right.maxDepth+<span class="hljs-number">1</span>)</span><br><span class="line">    maxDistance := max(max(left.maxDistance, right.maxDistance), left.maxDepth+right.maxDepth+<span class="hljs-number">2</span>)</span><br><span class="line">    <span class="hljs-keyword">return</span> &amp;result&#123;</span><br><span class="line">        maxDepth:    maxDepth,</span><br><span class="line">        maxDistance: maxDistance,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetMaxDistance</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line">    result := getMaxDistance(root)</span><br><span class="line">    <span class="hljs-keyword">return</span> result.maxDistance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在这里在线运行：<a href="https://play.golang.org/p/CwIvHaBJwP-" target="_blank" rel="noopener">https://play.golang.org/p/CwIvHaBJwP-</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个二叉树，求它两个节点之间的最大距离。&lt;/p&gt;&lt;p&gt;比如二叉树：&lt;/p&gt;&lt;figure class=&quot;highlight plain hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2   3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4   5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;的最大距离为 3。&lt;/p&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="算法" scheme="http://whypro.github.io/hexo-blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>有序数组的不同绝对值个数</title>
    <link href="http://whypro.github.io/hexo-blog/20190523/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8D%E5%90%8C%E7%BB%9D%E5%AF%B9%E5%80%BC%E4%B8%AA%E6%95%B0/"/>
    <id>http://whypro.github.io/hexo-blog/20190523/有序数组的不同绝对值个数/</id>
    <published>2019-05-23T11:11:28.000Z</published>
    <updated>2019-06-02T09:10:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个有序数组，求它的元素不同的绝对值个数。</p><p>比如</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-3, -1, 0, 0, 1, 1, 2, 5]</span><br></pre></td></tr></table></figure><p>返回</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>首先一个循环将数组所有的负数转换为正数，然后对整个数组进行排序。</p><p>但循环一遍的时间复杂度为 <code>O(n)</code>，排序如果用堆排序，平均时间复杂度为 <code>O(nlogn)</code>，空间复杂度为 <code>O(1)</code>。因此整体的时间复杂度为 <code>O(nlogn)</code>，空间复杂度为 <code>O(1)</code>。而既然题目已经保证了有序数组，那有没有更快的方法呢？</p><h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><p>我们可以用两个索引，索引 i 和 索引 j 分别从数组两端向中间移动，如果当前元素和下一个元素相等则跳过，如果右边的绝对值大于左边的绝对值，则索引 j 左移，如果左边的绝对值大于右边的绝对值，则索引 i 右移，如果两边绝对值相等，则索引同时左移和右移，每次移动计数加一。直到索引相遇时结束，如果相遇后索引刚好相等，则计数最后再加一。</p><p>这样时间复杂度就为 <code>O(n)</code>，空间复杂度为 <code>O(1)</code>。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>使用 Golang 实现的源码如下：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getDistinctAbsCount</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line">    i := <span class="hljs-number">0</span></span><br><span class="line">    j := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span></span><br><span class="line">    count := <span class="hljs-number">0</span></span><br><span class="line">    <span class="hljs-keyword">for</span> i &lt; j &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span> &amp;&amp; nums[i] == nums[i+<span class="hljs-number">1</span>] &#123;</span><br><span class="line">            <span class="hljs-comment">// skip duplicated</span></span><br><span class="line">            i += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> j &gt; <span class="hljs-number">0</span> &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>] &#123;</span><br><span class="line">            <span class="hljs-comment">// skip duplicated</span></span><br><span class="line">            j -= <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum := nums[i] + nums[j]</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> sum &gt; <span class="hljs-number">0</span> &#123;</span><br><span class="line">            <span class="hljs-comment">// abs(nums[i]) &lt; abs(nums[j])</span></span><br><span class="line">            j -= <span class="hljs-number">1</span></span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> sum &lt; <span class="hljs-number">0</span> &#123;</span><br><span class="line">            <span class="hljs-comment">// abs(nums[i]) &gt; abs(nums[j])</span></span><br><span class="line">            i += <span class="hljs-number">1</span></span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-comment">// abs(nums[i]) == abs(nums[j])</span></span><br><span class="line">            i += <span class="hljs-number">1</span></span><br><span class="line">            j -= <span class="hljs-number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        count += <span class="hljs-number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> i == j &#123;</span><br><span class="line">        count += <span class="hljs-number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可在这里在线运行：<a href="https://play.golang.org/p/lmOI5ZNkMNf" target="_blank" rel="noopener">https://play.golang.org/p/lmOI5ZNkMNf</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个有序数组，求它的元素不同的绝对值个数。&lt;/p&gt;&lt;p&gt;比如&lt;/p&gt;&lt;figure class=&quot;highlight plain hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[-3, -1, 0, 0, 1, 1, 2, 5]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;返回&lt;/p&gt;&lt;figure class=&quot;highlight plain hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="算法" scheme="http://whypro.github.io/hexo-blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>从零开始实现一个 terraform plugin</title>
    <link href="http://whypro.github.io/hexo-blog/20190522/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-terraform-plugin/"/>
    <id>http://whypro.github.io/hexo-blog/20190522/从零开始实现一个-terraform-plugin/</id>
    <published>2019-05-22T06:13:02.000Z</published>
    <updated>2019-06-02T09:10:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>terraform 作为一个优秀的开源基础设施管理、构建工具，官方或第三方提供了很多 plugin 来对接各种云平台（IaaS）。然而在我们平时开发和测试过程中，需要使用内部的 IaaS 服务频繁创建和删除 VM，而目前人工操作的方式比较费时费力，且没有现成的 plugin 可以使用。为了更方便地利用 terraform 工具来对内部 IaaS 资源进行管理和操作，我们决定自己开发一个 terraform plugin。</p><a id="more"></a><h2 id="定义-Provider-Schema"><a href="#定义-Provider-Schema" class="headerlink" title="定义 Provider Schema"></a>定义 Provider Schema</h2><p>首先，我们定义入口文件 <code>main.go</code>：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line">    <span class="hljs-string">"github.com/hashicorp/terraform/plugin"</span></span><br><span class="line">    qvm <span class="hljs-string">"qiniu.com/kirk-deploy/pkg/qvm/terraform"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    plugin.Serve(&amp;plugin.ServeOpts&#123;</span><br><span class="line">        ProviderFunc: qvm.Provider,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>qvm.Provider</code> 函数负责创建一个 provider resource。</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Provider</span><span class="hljs-params">()</span> <span class="hljs-title">terraform</span>.<span class="hljs-title">ResourceProvider</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> &amp;schema.Provider&#123;</span><br><span class="line">        Schema: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*schema.Schema&#123;</span><br><span class="line">            <span class="hljs-string">"url"</span>: &#123;</span><br><span class="line">                Type:        schema.TypeString,</span><br><span class="line">                Optional:    <span class="hljs-literal">true</span>,</span><br><span class="line">                DefaultFunc: schema.EnvDefaultFunc(<span class="hljs-string">"QVM_URL"</span>, <span class="hljs-string">""</span>),</span><br><span class="line">                Description: descriptions[<span class="hljs-string">"url"</span>],</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="hljs-string">"ak"</span>: &#123;</span><br><span class="line">                Type:        schema.TypeString,</span><br><span class="line">                Optional:    <span class="hljs-literal">true</span>,</span><br><span class="line">                DefaultFunc: schema.EnvDefaultFunc(<span class="hljs-string">"QVM_AK"</span>, <span class="hljs-string">""</span>),</span><br><span class="line">                Description: descriptions[<span class="hljs-string">"ak"</span>],</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="hljs-string">"sk"</span>: &#123;</span><br><span class="line">                Type:        schema.TypeString,</span><br><span class="line">                Optional:    <span class="hljs-literal">true</span>,</span><br><span class="line">                DefaultFunc: schema.EnvDefaultFunc(<span class="hljs-string">"QVM_SK"</span>, <span class="hljs-string">""</span>),</span><br><span class="line">                Description: descriptions[<span class="hljs-string">"sk"</span>],</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        ResourcesMap: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*schema.Resource&#123;</span><br><span class="line">            <span class="hljs-string">"compute_instance"</span>: resourceComputeInstance(),</span><br><span class="line">        &#125;,</span><br><span class="line">        ConfigureFunc: configureProvider,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Schema</code> 声明了 provider 配置文件的定义，对应的 <code>tf</code> 文件这样写：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">provider qvm &#123;</span><br><span class="line">    url = &quot;https://qvm.qiniuapi.com&quot;</span><br><span class="line">    ak = &quot;your app key&quot;</span><br><span class="line">    sk = &quot;your app secret&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不在 <code>tf</code> 文件里指定 <code>ak</code> 和 <code>sk</code>，则 terraform 会根据 <code>DefaultFunc</code>，从环境变量 <code>QVM_AK</code> 和 <code>QVM_SK</code> 中获取。<code>Optional</code> 代表字段是可选的，即使用户没有填也不会报错。</p><p><code>ResourcesMap</code> 声明了 provider 支持的资源和对应资源的工厂函数，例如这里我们只实现了计算资源，工厂函数的定义我们稍后再解释。</p><h2 id="定义-Resource-Schema"><a href="#定义-Resource-Schema" class="headerlink" title="定义 Resource Schema"></a>定义 Resource Schema</h2><p>上面提到的 <code>resourceComputeInstance</code> 负责创建一个 compute instance resource，对于计算资源我们可以这样定义：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">resourceComputeInstance</span><span class="hljs-params">()</span> *<span class="hljs-title">schema</span>.<span class="hljs-title">Resource</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> &amp;schema.Resource&#123;</span><br><span class="line">        Create: resourceComputeInstanceCreate,</span><br><span class="line">        Read:   resourceComputeInstanceRead,</span><br><span class="line">        Update: resourceComputeInstanceUpdate,</span><br><span class="line">        Delete: resourceComputeInstanceDelete,</span><br><span class="line">        Timeouts: &amp;schema.ResourceTimeout&#123;</span><br><span class="line">            Create: schema.DefaultTimeout(<span class="hljs-number">30</span> * time.Minute),</span><br><span class="line">            Update: schema.DefaultTimeout(<span class="hljs-number">30</span> * time.Minute),</span><br><span class="line">            Delete: schema.DefaultTimeout(<span class="hljs-number">30</span> * time.Minute),</span><br><span class="line">        &#125;,</span><br><span class="line">        Schema: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*schema.Schema&#123;</span><br><span class="line">            <span class="hljs-string">"image_id"</span>: &#123;</span><br><span class="line">                Type:     schema.TypeString,</span><br><span class="line">                Optional: <span class="hljs-literal">true</span>,</span><br><span class="line">                ForceNew: <span class="hljs-literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="hljs-string">"instance_name"</span>: &#123;</span><br><span class="line">                Type:     schema.TypeString,</span><br><span class="line">                Optional: <span class="hljs-literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="hljs-string">"system_disk"</span>: &#123;</span><br><span class="line">                Type:     schema.TypeList,</span><br><span class="line">                Required: <span class="hljs-literal">true</span>,</span><br><span class="line">                MaxItems: <span class="hljs-number">1</span>,</span><br><span class="line">                Elem: &amp;schema.Resource&#123;</span><br><span class="line">                    Schema: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*schema.Schema&#123;</span><br><span class="line">                        <span class="hljs-string">"category"</span>: &#123;</span><br><span class="line">                            Type:     schema.TypeString,</span><br><span class="line">                            Optional: <span class="hljs-literal">true</span>,</span><br><span class="line">                            Default:  enums.DiskCategoryCloudEfficiency,</span><br><span class="line">                            ForceNew: <span class="hljs-literal">true</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="hljs-string">"size"</span>: &#123;</span><br><span class="line">                            Type:     schema.TypeInt,</span><br><span class="line">                            Optional: <span class="hljs-literal">true</span>,</span><br><span class="line">                            Default:  <span class="hljs-number">40</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="hljs-string">"data_disk"</span>: &#123;</span><br><span class="line">                Type:     schema.TypeList,</span><br><span class="line">                Optional: <span class="hljs-literal">true</span>,</span><br><span class="line">                MinItems: <span class="hljs-number">1</span>,</span><br><span class="line">                MaxItems: <span class="hljs-number">15</span>,</span><br><span class="line">                Elem: &amp;schema.Resource&#123;</span><br><span class="line">                    Schema: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*schema.Schema&#123;</span><br><span class="line">                        <span class="hljs-string">"category"</span>: &#123;</span><br><span class="line">                            Type:     schema.TypeString,</span><br><span class="line">                            Optional: <span class="hljs-literal">true</span>,</span><br><span class="line">                            Default:  enums.DiskCategoryCloudEfficiency,</span><br><span class="line">                            ForceNew: <span class="hljs-literal">true</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="hljs-string">"size"</span>: &#123;</span><br><span class="line">                            Type:     schema.TypeInt,</span><br><span class="line">                            Optional: <span class="hljs-literal">true</span>,</span><br><span class="line">                            Default:  <span class="hljs-number">40</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Create</code> <code>Read</code> <code>Update</code> <code>Delete</code> 分别是管理资源的回调函数，terraform 框架会在合适的时间调用这几个函数，<code>Timeouts</code> 定义了每个操作的超时时间，<code>Schema</code> 与上面一样，是定义 <code>tf</code> 文件的具体结构。</p><p><code>ForceNew</code> 代表一旦这个字段改变，则 terraform 会删除并重新创建该资源。<code>TypeList</code> 定义了一个列表，如果 <code>MaxItems: 1</code> 时，列表退化为单个资源。</p><p>为了简化起见，<code>Schema</code> 我们省略了很多字段，对应的 <code>tf</code> 文件可以这样写：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;compute_instance&quot; &quot;test&quot; &#123;</span><br><span class="line">    count = &quot;$&#123;var.count&#125;&quot;</span><br><span class="line">    provider = &quot;qvm&quot;</span><br><span class="line">    image_id = &quot;$&#123;var.image&#125;&quot;</span><br><span class="line">    instance_name = &quot;$&#123;var.instance_name&#125;-$&#123;count.index&#125;&quot;</span><br><span class="line">    system_disk &#123;</span><br><span class="line">        category = &quot;efficiency&quot;</span><br><span class="line">        size = 40</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>${var.}</code> 代表在 varaibles.tf 文件里定义的变量，具体可以用法可以参考 terraform 官方文档，这里不过多地介绍。</p><h2 id="定义-Resource-Operation-Function"><a href="#定义-Resource-Operation-Function" class="headerlink" title="定义 Resource Operation Function"></a>定义 Resource Operation Function</h2><h3 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h3><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">resourceComputeInstanceCreate</span><span class="hljs-params">(d *schema.ResourceData, meta <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line">    config := meta.(*Config)</span><br><span class="line">    client, err := config.computeClient()</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    systemDisk := d.Get(<span class="hljs-string">"system_disk"</span>).([]<span class="hljs-keyword">interface</span>&#123;&#125;)[<span class="hljs-number">0</span>].(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    systemDiskParameters := params.CreateInstanceSystemDiskParameters&#123;</span><br><span class="line">        Category: enums.DiskCategory(systemDisk[<span class="hljs-string">"category"</span>].(<span class="hljs-keyword">string</span>)),</span><br><span class="line">        Size:     systemDisk[<span class="hljs-string">"size"</span>].(<span class="hljs-keyword">int</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parameters := &amp;params.CreateInstanceParameters&#123;</span><br><span class="line">        ImageId:            d.Get(<span class="hljs-string">"image_id"</span>).(<span class="hljs-keyword">string</span>),</span><br><span class="line">        SystemDisk:         systemDiskParameters,</span><br><span class="line">        InstanceName:       enums.InstanceName(d.Get(<span class="hljs-string">"instance_name"</span>).(<span class="hljs-keyword">string</span>)),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="hljs-string">"[DEBUG] CreateInstanceParameters: %#v"</span>, parameters)</span><br><span class="line">    rsp, err := client.CreateInstance(parameters)</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="hljs-string">"[ERROR] create instance error, %v"</span>, err)</span><br><span class="line">        <span class="hljs-keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="hljs-string">"[INFO] Instance ID: %s"</span>, rsp.Data.InstanceId)</span><br><span class="line">    d.SetId(rsp.Data.InstanceId)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> resourceComputeInstanceRead(d, meta)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Create</code> 的实现最重要的一个操作是 <code>SetId</code>，如果服务端资源创建成功，会返回一个 InstanceId，<code>SetId</code> 会将这个 InstanceId 保存，作为以后判断资源是否更新的 key。</p><p>return 前又进行了一次 <code>Read</code> 操作，是为了防止有些状态字段没有通过 CreateResponse 返回，再尝试通过一次 Read 来获取这些状态信息。</p><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">resourceComputeInstanceDelete</span><span class="hljs-params">(d *schema.ResourceData, meta <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line">    config := meta.(*Config)</span><br><span class="line">    client, err := config.computeClient()</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p := &amp;params.DeleteInstanceParameters&#123;</span><br><span class="line">        InstanceId: d.Id(),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _, err = client.DeleteInstance(p)</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">resourceComputeInstanceUpdate</span><span class="hljs-params">(d *schema.ResourceData, meta <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> resourceComputeInstanceRead(d, meta)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们暂时不实现 <code>Update</code> 操作，因此这里只是简单地返回 Read。</p><h3 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h3><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">resourceComputeInstanceRead</span><span class="hljs-params">(d *schema.ResourceData, meta <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line">    config := meta.(*Config)</span><br><span class="line">    client, err := config.computeClient()</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p := &amp;params.DescribeInstanceParameters&#123;</span><br><span class="line">        InstanceId: d.Id(),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rsp, err := client.GetInstance(p)</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    instance := &amp;rsp.Data</span><br><span class="line">    d.Set(<span class="hljs-string">"image_id"</span>, instance.ImageId)</span><br><span class="line">    d.Set(<span class="hljs-string">"instance_name"</span>, instance.InstanceName)</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Read</code> 通过 InstanceId 对资源状态进行查询，保存至 resource data。</p><h2 id="编译和构建"><a href="#编译和构建" class="headerlink" title="编译和构建"></a>编译和构建</h2><p>上面基本代码框架实现后，我们就可以对 plugin 进行编译和构建了：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -o terraform-provider-qvm</span><br></pre></td></tr></table></figure><p>二进制文件的命名必须遵守以下命名规则：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform-provider-&lt;NAME&gt;</span><br></pre></td></tr></table></figure><p>构建后，我们手动将二进制拷贝至 terraform 默认的插件目录：<code>${HOME}/.terraform/plguins</code>。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>进入工作目录，即 <code>tf</code> 文件保存的目录，假设这个目录的结构为：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">terraform/qvm</span><br><span class="line">├── provider.tf</span><br><span class="line">├── resources.tf</span><br><span class="line">├── variables.tf</span><br><span class="line">└── terraform.tfvars</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform init</span><br></pre></td></tr></table></figure><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>可以通过 <code>export</code> 或创建 <code>.tfvars</code> 文件，对配置进行修改：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export QVM_AK=</span><br><span class="line">export QVM_SK=</span><br></pre></td></tr></table></figure><p>创建 <code>terraform.tfvars</code> 文件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">instance_name = &quot;&quot;</span><br><span class="line">count = 1</span><br><span class="line">image = &quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="查看更改"><a href="#查看更改" class="headerlink" title="查看更改"></a>查看更改</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform plan</span><br></pre></td></tr></table></figure><p>执行后 terraform 会对配置进行合法性校验。</p><h3 id="应用更改"><a href="#应用更改" class="headerlink" title="应用更改"></a>应用更改</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform apply</span><br></pre></td></tr></table></figure><p>或者指定 <code>.tfvars</code> 文件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform apply -var-file=&quot;terraform.tfvars&quot;</span><br></pre></td></tr></table></figure><h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform destroy</span><br></pre></td></tr></table></figure><p>或者指定 <code>.tfvars</code> 文件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform destroy -var-file=&quot;terraform.tfvars&quot;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.terraform.io/docs/extend/writing-custom-providers.html" target="_blank" rel="noopener">https://www.terraform.io/docs/extend/writing-custom-providers.html</a></p><p><a href="https://www.terraform.io/docs/extend/how-terraform-works.html" target="_blank" rel="noopener">https://www.terraform.io/docs/extend/how-terraform-works.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;terraform 作为一个优秀的开源基础设施管理、构建工具，官方或第三方提供了很多 plugin 来对接各种云平台（IaaS）。然而在我们平时开发和测试过程中，需要使用内部的 IaaS 服务频繁创建和删除 VM，而目前人工操作的方式比较费时费力，且没有现成的 plugin 可以使用。为了更方便地利用 terraform 工具来对内部 IaaS 资源进行管理和操作，我们决定自己开发一个 terraform plugin。&lt;/p&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="Golang" scheme="http://whypro.github.io/hexo-blog/tags/Golang/"/>
    
      <category term="terraform" scheme="http://whypro.github.io/hexo-blog/tags/terraform/"/>
    
  </entry>
  
  <entry>
    <title>使用 Devstack 搭建 Openstack 集群</title>
    <link href="http://whypro.github.io/hexo-blog/20190107/%E4%BD%BF%E7%94%A8-Devstack-%E6%90%AD%E5%BB%BA-Openstack-%E9%9B%86%E7%BE%A4/"/>
    <id>http://whypro.github.io/hexo-blog/20190107/使用-Devstack-搭建-Openstack-集群/</id>
    <published>2019-01-07T07:22:00.000Z</published>
    <updated>2019-06-02T09:10:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>多节点搭建步骤：</p><p><a href="https://docs.openstack.org/devstack/rocky/guides/multinode-lab.html" target="_blank" rel="noopener">https://docs.openstack.org/devstack/rocky/guides/multinode-lab.html</a></p><p>要配置 kvm，否则使用默认的 qemu 跑 vm 性能会很差：</p><p><a href="https://docs.openstack.org/devstack/rocky/guides/devstack-with-nested-kvm.html" target="_blank" rel="noopener">https://docs.openstack.org/devstack/rocky/guides/devstack-with-nested-kvm.html</a></p><a id="more"></a><p>control 节点配置:</p><figure class="highlight ini hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">[[local|localrc]]</span></span><br><span class="line"><span class="hljs-attr">HOST_IP</span>=<span class="hljs-number">10.20</span>.<span class="hljs-number">102.37</span></span><br><span class="line"><span class="hljs-attr">FLAT_INTERFACE</span>=bond0</span><br><span class="line"><span class="hljs-attr">FIXED_RANGE</span>=<span class="hljs-number">10.4</span>.<span class="hljs-number">128.0</span>/<span class="hljs-number">20</span></span><br><span class="line"><span class="hljs-attr">FIXED_NETWORK_SIZE</span>=<span class="hljs-number">4096</span></span><br><span class="line"><span class="hljs-attr">FLOATING_RANGE</span>=<span class="hljs-number">10.20</span>.<span class="hljs-number">102.223</span>/<span class="hljs-number">27</span></span><br><span class="line"><span class="hljs-attr">MULTI_HOST</span>=<span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-attr">LOGFILE</span>=/opt/stack/logs/stack.sh.log</span><br><span class="line"><span class="hljs-attr">ADMIN_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">DATABASE_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">RABBIT_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">SERVICE_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">LIBVIRT_TYPE</span>=kvm</span><br><span class="line"><span class="hljs-attr">IP_VERSION</span>=<span class="hljs-number">4</span></span><br></pre></td></tr></table></figure><p>compute 节点配置:</p><figure class="highlight ini hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">[[local|localrc]]</span></span><br><span class="line"><span class="hljs-attr">HOST_IP</span>=<span class="hljs-number">10.20</span>.<span class="hljs-number">102.38</span> # change this per compute node</span><br><span class="line"><span class="hljs-attr">FLAT_INTERFACE</span>=bond0</span><br><span class="line"><span class="hljs-attr">FIXED_RANGE</span>=<span class="hljs-number">10.4</span>.<span class="hljs-number">128.0</span>/<span class="hljs-number">20</span></span><br><span class="line"><span class="hljs-attr">FIXED_NETWORK_SIZE</span>=<span class="hljs-number">4096</span></span><br><span class="line"><span class="hljs-attr">FLOATING_RANGE</span>=<span class="hljs-number">10.20</span>.<span class="hljs-number">102.223</span>/<span class="hljs-number">27</span></span><br><span class="line"><span class="hljs-attr">MULTI_HOST</span>=<span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-attr">LOGFILE</span>=/opt/stack/logs/stack.sh.log</span><br><span class="line"><span class="hljs-attr">ADMIN_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">DATABASE_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">RABBIT_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">SERVICE_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">DATABASE_TYPE</span>=mysql</span><br><span class="line"><span class="hljs-attr">SERVICE_HOST</span>=<span class="hljs-number">10.20</span>.<span class="hljs-number">102.37</span></span><br><span class="line"><span class="hljs-attr">MYSQL_HOST</span>=<span class="hljs-variable">$SERVICE_HOST</span></span><br><span class="line"><span class="hljs-attr">RABBIT_HOST</span>=<span class="hljs-variable">$SERVICE_HOST</span></span><br><span class="line"><span class="hljs-attr">GLANCE_HOSTPORT</span>=<span class="hljs-variable">$SERVICE_HOST</span>:<span class="hljs-number">9292</span></span><br><span class="line"><span class="hljs-attr">ENABLED_SERVICES</span>=n-cpu,q-agt,n-api-meta,c-vol,placement-client</span><br><span class="line"><span class="hljs-attr">NOVA_VNC_ENABLED</span>=<span class="hljs-literal">True</span></span><br><span class="line"><span class="hljs-attr">NOVNCPROXY_URL</span>=<span class="hljs-string">"http://$SERVICE_HOST:6080/vnc_auto.html"</span></span><br><span class="line"><span class="hljs-attr">VNCSERVER_LISTEN</span>=<span class="hljs-variable">$HOST_IP</span></span><br><span class="line"><span class="hljs-attr">VNCSERVER_PROXYCLIENT_ADDRESS</span>=<span class="hljs-variable">$VNCSERVER_LISTEN</span></span><br><span class="line"><span class="hljs-attr">LIBVIRT_TYPE</span>=kvm</span><br><span class="line"><span class="hljs-attr">IP_VERSION</span>=<span class="hljs-number">4</span></span><br></pre></td></tr></table></figure><ul><li><code>FIXED_RANGE</code> 是 vm 实例的内网地址，供 vm 之间访问，vm 创建时便会分配一个，创建后一般不能更改。</li><li><code>FLOATING_RANGE</code> 是 vm 实例的外网地址，供物理机访问 vm，以及 vm 访问物理机，可以在实例创建后进行绑定和解绑。这个网段一般设置为物理机 IP 的子网段。</li></ul><p>如果需要 ipv6，则需要修改以下参数：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">net.ipv6.conf.all.disable_ipv6=0</span><br><span class="line">net.ipv6.conf.default.disable_ipv6=0</span><br><span class="line">net.ipv6.conf.lo.disable_ipv6=0</span><br><span class="line"></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>不要按照 devstack 官方文档创建 <code>local.sh</code>。因为 openstack rocky 已经默认使用 neutron 了，这个脚本对 neutron 没有什么作用。<a href="https://bugs.launchpad.net/devstack/+bug/1783576" target="_blank" rel="noopener">https://bugs.launchpad.net/devstack/+bug/1783576</a></p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `seq 2 10`; <span class="hljs-keyword">do</span> /opt/stack/nova/bin/nova-manage fixed reserve 10.4.128.<span class="hljs-variable">$i</span>; <span class="hljs-keyword">done</span></span><br></pre></td></tr></table></figure><p>多节点如果出现调度错误，需要执行：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./tools/discover_hosts.sh</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nova-manage cell_v2 discover_hosts --verbose</span><br></pre></td></tr></table></figure><p>如果如果遇到一些未知的问题，尝试拆除环境，清除所有资源后重试：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./unstack.sh</span><br><span class="line">./clean.sh</span><br><span class="line">./stack.sh</span><br></pre></td></tr></table></figure><h2 id="镜像创建"><a href="#镜像创建" class="headerlink" title="镜像创建"></a>镜像创建</h2><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openstack image create --public --disk-format qcow2 --container-format bare --file xenial-server-cloudimg-amd64-disk1.img ubuntu-xenial-server-amd64</span><br></pre></td></tr></table></figure><h2 id="实例创建"><a href="#实例创建" class="headerlink" title="实例创建"></a>实例创建</h2><p>首先进行 admin 认证鉴权：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo su - stack</span><br><span class="line"><span class="hljs-built_in">cd</span> /opt/stack/devstack</span><br><span class="line"><span class="hljs-built_in">source</span> openrc</span><br></pre></td></tr></table></figure><p>创建安全组规则，允许 ping 和 ssh：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openstack security group rule create --proto icmp default</span><br><span class="line">openstack security group rule create --proto tcp --dst-port 22 default</span><br></pre></td></tr></table></figure><p>创建测试实例：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openstack server create --flavor m1.tiny \</span><br><span class="line">--image $(openstack image list | grep cirros | cut -f3 -d <span class="hljs-string">'|'</span>) \</span><br><span class="line">--nic net-id=$(openstack network list | grep private | cut -f2 -d <span class="hljs-string">'|'</span> | tr -d <span class="hljs-string">' '</span>) \</span><br><span class="line">--security-group default vm</span><br></pre></td></tr></table></figure><p>创建 floating IP：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openstack floating ip create public</span><br></pre></td></tr></table></figure><p>将 floating IP 与实例绑定：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openstack server add floating ip vm 10.20.102.238</span><br></pre></td></tr></table></figure><p>就可以通过 floating IP 登录 vm 实例了，用户名密码是：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cirros</span><br><span class="line">cubswin:)</span><br></pre></td></tr></table></figure><p>vm 如果需要上外网，需要配置 nat。在物理机上执行：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#ifconfig br-ex 10.20.102.223/27</span></span><br><span class="line">iptables -t nat -I POSTROUTING -s 10.20.102.223/27 -j MASQUERADE</span><br><span class="line">iptables -I FORWARD -s 10.20.102.223/27 -j ACCEPT</span><br><span class="line">iptables -I FORWARD -d 10.20.102.223/27 -j ACCEPT</span><br></pre></td></tr></table></figure><h2 id="配置卷类型"><a href="#配置卷类型" class="headerlink" title="配置卷类型"></a>配置卷类型</h2><p>创建 pv 和 vg：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pvcreate /dev/sdb1</span><br><span class="line">vgcreate stack-volumes-hdd /dev/sdb1</span><br></pre></td></tr></table></figure><p>配置 cinder：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/cinder/cinder.conf</span><br></pre></td></tr></table></figure><figure class="highlight ini hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">[DEFAULT]</span></span><br><span class="line"><span class="hljs-attr">default_volume_type</span> = hdd</span><br><span class="line"><span class="hljs-attr">enabled_backends</span> = hdd,ssd</span><br><span class="line"></span><br><span class="line"><span class="hljs-section">[hdd]</span></span><br><span class="line"><span class="hljs-attr">image_volume_cache_enabled</span> = <span class="hljs-literal">True</span></span><br><span class="line"><span class="hljs-attr">volume_clear</span> = zero</span><br><span class="line"><span class="hljs-attr">lvm_type</span> = auto</span><br><span class="line"><span class="hljs-attr">target_helper</span> = tgtadm</span><br><span class="line"><span class="hljs-attr">volume_group</span> = stack-volumes-hdd</span><br><span class="line"><span class="hljs-attr">volume_driver</span> = cinder.volume.drivers.lvm.LVMVolumeDriver</span><br><span class="line"><span class="hljs-attr">volume_backend_name</span> = hdd</span><br></pre></td></tr></table></figure><p>重启 openstack：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart devstack@*</span><br></pre></td></tr></table></figure><p>创建卷类型：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openstack volume <span class="hljs-built_in">type</span> create hdd</span><br><span class="line">openstack volume <span class="hljs-built_in">type</span> <span class="hljs-built_in">set</span> hdd --property volume_backend_name=hdd</span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="volume-无法创建"><a href="#volume-无法创建" class="headerlink" title="volume 无法创建"></a>volume 无法创建</h3><ul><li>排查</li></ul><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo journalctl -f --unit devstack@c-vol</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mar 06 14:59:18 kirk-system cinder-volume[27813]: ERROR oslo_service.service [None req-e1391562-6252-4b98-ba3a-6420edbafffe None None] Error starting thread.: DetachedInstanceError: Parent instance &lt;VolumeAttachment at 0x7f6455ffee90&gt; is not bound to a Session; lazy load operation of attribute &apos;volume&apos; cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)</span><br></pre></td></tr></table></figure><ul><li>解决</li></ul><p><a href="https://ask.openstack.org/en/question/103315/cinder-volume-attached-to-a-terminated-server-now-i-cant-delete-it/" target="_blank" rel="noopener">https://ask.openstack.org/en/question/103315/cinder-volume-attached-to-a-terminated-server-now-i-cant-delete-it/</a></p><h3 id="ubuntu-18-04-切换到-etc-network-interface"><a href="#ubuntu-18-04-切换到-etc-network-interface" class="headerlink" title="ubuntu 18.04 切换到 /etc/network/interface"></a>ubuntu 18.04 切换到 /etc/network/interface</h3><p><a href="https://askubuntu.com/questions/1031709/ubuntu-18-04-switch-back-to-etc-network-interfaces" target="_blank" rel="noopener">https://askubuntu.com/questions/1031709/ubuntu-18-04-switch-back-to-etc-network-interfaces</a></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><p>golang SDK：<a href="http://gophercloud.io/docs/compute/#servers" target="_blank" rel="noopener">http://gophercloud.io/docs/compute/#servers</a></p></li><li><p>terraform：<a href="https://www.terraform.io/docs/providers/openstack/" target="_blank" rel="noopener">https://www.terraform.io/docs/providers/openstack/</a></p></li><li><p>获取 Openstack 镜像：<a href="https://docs.openstack.org/image-guide/obtain-images.html" target="_blank" rel="noopener">https://docs.openstack.org/image-guide/obtain-images.html</a></p></li><li><p>使用 systemd 管理 devstack：<a href="https://docs.openstack.org/devstack/rocky/systemd.html" target="_blank" rel="noopener">https://docs.openstack.org/devstack/rocky/systemd.html</a></p></li><li><p>devstack networking：</p><ul><li><a href="https://docs.openstack.org/devstack/rocky/networking.html" target="_blank" rel="noopener">https://docs.openstack.org/devstack/rocky/networking.html</a></li><li><a href="https://wiki.openstack.org/wiki/OpsGuide-Network-Troubleshooting" target="_blank" rel="noopener">https://wiki.openstack.org/wiki/OpsGuide-Network-Troubleshooting</a></li></ul></li><li><p>neutron 相关：</p><ul><li><a href="https://docs.openstack.org/devstack/rocky/guides/neutron.html" target="_blank" rel="noopener">https://docs.openstack.org/devstack/rocky/guides/neutron.html</a></li><li><a href="https://www.ibm.com/developerworks/cn/cloud/library/1402_chenhy_openstacknetwork/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/cloud/library/1402_chenhy_openstacknetwork/</a></li></ul></li></ul><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>neutron+vlan 模式配置：</p><figure class="highlight ini hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">[[local|localrc]]</span></span><br><span class="line"><span class="hljs-attr">HOST_IP</span>=<span class="hljs-number">10.20</span>.<span class="hljs-number">102.37</span></span><br><span class="line"><span class="hljs-attr">PUBLIC_INTERFACE</span>=bond1</span><br><span class="line"><span class="hljs-attr">LOGFILE</span>=/opt/stack/logs/stack.sh.log</span><br><span class="line"><span class="hljs-attr">ADMIN_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">DATABASE_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">RABBIT_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">SERVICE_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">LIBVIRT_TYPE</span>=kvm</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">## Neutron options</span></span><br><span class="line"><span class="hljs-attr">IP_VERSION</span>=<span class="hljs-number">4</span></span><br><span class="line"><span class="hljs-attr">Q_USE_SECGROUP</span>=<span class="hljs-literal">True</span></span><br><span class="line"><span class="hljs-attr">ENABLE_TENANT_VLANS</span>=<span class="hljs-literal">True</span></span><br><span class="line"><span class="hljs-attr">TENANT_VLAN_RANGE</span>=<span class="hljs-number">3001</span>:<span class="hljs-number">4000</span></span><br><span class="line"><span class="hljs-attr">PHYSICAL_NETWORK</span>=default</span><br><span class="line"><span class="hljs-attr">OVS_PHYSICAL_BRIDGE</span>=br-ex</span><br><span class="line"><span class="hljs-attr">Q_USE_PROVIDER_NETWORKING</span>=<span class="hljs-literal">True</span></span><br><span class="line">disable_service q-l3</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">## Neutron Networking options used to create Neutron Subnets</span></span><br><span class="line"><span class="hljs-attr">IPV4_ADDRS_SAFE_TO_USE</span>=<span class="hljs-string">"203.0.113.0/24"</span></span><br><span class="line"><span class="hljs-attr">NETWORK_GATEWAY</span>=<span class="hljs-number">203.0</span>.<span class="hljs-number">113.1</span></span><br><span class="line"><span class="hljs-attr">PROVIDER_SUBNET_NAME</span>=<span class="hljs-string">"provider_net"</span></span><br><span class="line"><span class="hljs-attr">PROVIDER_NETWORK_TYPE</span>=<span class="hljs-string">"vlan"</span></span><br><span class="line"><span class="hljs-attr">SEGMENTATION_ID</span>=<span class="hljs-number">2010</span></span><br><span class="line"><span class="hljs-attr">USE_SUBNETPOOL</span>=<span class="hljs-literal">False</span></span><br></pre></td></tr></table></figure><figure class="highlight ini hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">[[local|localrc]]</span></span><br><span class="line"><span class="hljs-attr">HOST_IP</span>=<span class="hljs-number">10.20</span>.<span class="hljs-number">102.38</span> # change this per compute node</span><br><span class="line"><span class="hljs-attr">LOGFILE</span>=/opt/stack/logs/stack.sh.log</span><br><span class="line"><span class="hljs-attr">ADMIN_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">DATABASE_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">RABBIT_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">SERVICE_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">DATABASE_TYPE</span>=mysql</span><br><span class="line"><span class="hljs-attr">SERVICE_HOST</span>=<span class="hljs-number">10.20</span>.<span class="hljs-number">102.37</span></span><br><span class="line"><span class="hljs-attr">MYSQL_HOST</span>=<span class="hljs-variable">$SERVICE_HOST</span></span><br><span class="line"><span class="hljs-attr">RABBIT_HOST</span>=<span class="hljs-variable">$SERVICE_HOST</span></span><br><span class="line"><span class="hljs-attr">GLANCE_HOSTPORT</span>=<span class="hljs-variable">$SERVICE_HOST</span>:<span class="hljs-number">9292</span></span><br><span class="line"><span class="hljs-attr">ENABLED_SERVICES</span>=n-cpu,q-agt,n-api-meta,c-vol,placement-client</span><br><span class="line"><span class="hljs-attr">NOVA_VNC_ENABLED</span>=<span class="hljs-literal">True</span></span><br><span class="line"><span class="hljs-attr">NOVNCPROXY_URL</span>=<span class="hljs-string">"http://$SERVICE_HOST:6080/vnc_auto.html"</span></span><br><span class="line"><span class="hljs-attr">VNCSERVER_LISTEN</span>=<span class="hljs-variable">$HOST_IP</span></span><br><span class="line"><span class="hljs-attr">VNCSERVER_PROXYCLIENT_ADDRESS</span>=<span class="hljs-variable">$VNCSERVER_LISTEN</span></span><br><span class="line"><span class="hljs-attr">LIBVIRT_TYPE</span>=kvm</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Services that a compute node runs</span></span><br><span class="line"><span class="hljs-attr">ENABLED_SERVICES</span>=n-cpu,rabbit,q-agt</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">## Open vSwitch provider networking options</span></span><br><span class="line"><span class="hljs-attr">IP_VERSION</span>=<span class="hljs-number">4</span></span><br><span class="line"><span class="hljs-attr">PHYSICAL_NETWORK</span>=default</span><br><span class="line"><span class="hljs-attr">OVS_PHYSICAL_BRIDGE</span>=br-ex</span><br><span class="line"><span class="hljs-attr">PUBLIC_INTERFACE</span>=bond1</span><br><span class="line"><span class="hljs-attr">Q_USE_PROVIDER_NETWORKING</span>=<span class="hljs-literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h2&gt;&lt;p&gt;多节点搭建步骤：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://docs.openstack.org/devstack/rocky/guides/multinode-lab.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.openstack.org/devstack/rocky/guides/multinode-lab.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;要配置 kvm，否则使用默认的 qemu 跑 vm 性能会很差：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://docs.openstack.org/devstack/rocky/guides/devstack-with-nested-kvm.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.openstack.org/devstack/rocky/guides/devstack-with-nested-kvm.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="云计算" scheme="http://whypro.github.io/hexo-blog/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Openstack" scheme="http://whypro.github.io/hexo-blog/tags/Openstack/"/>
    
  </entry>
  
  <entry>
    <title>PLEG unhealthy 导致节点状态不断在 Ready/NotReady 之间切换问题</title>
    <link href="http://whypro.github.io/hexo-blog/20181127/PLEG-unhealthy-%E5%AF%BC%E8%87%B4%E8%8A%82%E7%82%B9%E7%8A%B6%E6%80%81%E4%B8%8D%E6%96%AD%E5%9C%A8-Ready-NotReady-%E4%B9%8B%E9%97%B4%E5%88%87%E6%8D%A2%E9%97%AE%E9%A2%98/"/>
    <id>http://whypro.github.io/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/</id>
    <published>2018-11-27T07:53:30.000Z</published>
    <updated>2019-06-02T09:10:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><ol><li>收到告警提示 PLEG 延时升高（240s）</li></ol><a id="more"></a> <img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/1.png"> <img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/2.png"><ol start="2"><li>节点状态在 Ready 和 NotReady 之间频繁切换</li></ol><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/3.png"> <img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/4.png"><ol start="3"><li>有 pod 处于 Terminating 状态</li></ol><h2 id="排查和原因分析"><a href="#排查和原因分析" class="headerlink" title="排查和原因分析"></a>排查和原因分析</h2><p>查看 kubelet PLEG 相关日志，发现大量 PLEG 超时日志：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Nov 27 10:10:07 xq68 kubelet[24562]: E1127 10:10:07.444787   24562 generic.go:271] PLEG: pod apiserver-inspection-workers-ds-1542964416453270535-6vhmt/qiniu-ranger failed reinspection: rpc error: code = DeadlineExceeded desc = context deadline exceeded</span><br><span class="line">Nov 27 10:14:08 xq68 kubelet[24562]: E1127 10:14:08.502149   24562 generic.go:271] PLEG: pod apiserver-inspection-workers-ds-1542964416453270535-6vhmt/qiniu-ranger failed reinspection: rpc error: code = DeadlineExceeded desc = context deadline exceeded</span><br><span class="line">Nov 27 10:18:09 xq68 kubelet[24562]: E1127 10:18:09.555935   24562 generic.go:271] PLEG: pod apiserver-inspection-workers-ds-1542964416453270535-6vhmt/qiniu-ranger failed reinspection: rpc error: code = DeadlineExceeded desc = context deadline exceeded</span><br><span class="line">Nov 27 10:22:10 xq68 kubelet[24562]: E1127 10:22:10.838479   24562 generic.go:271] PLEG: pod apiserver-inspection-workers-ds-1542964416453270535-6vhmt/qiniu-ranger failed reinspection: rpc error: code = DeadlineExceeded desc = context deadline exceeded</span><br><span class="line">Nov 27 10:26:11 xq68 kubelet[24562]: E1127 10:26:11.878116   24562 generic.go:271] PLEG: pod apiserver-inspection-workers-ds-1542964416453270535-6vhmt/qiniu-ranger failed reinspection: rpc error: code = DeadlineExceeded desc = context deadline exceeded</span><br><span class="line">Nov 27 10:30:12 xq68 kubelet[24562]: E1127 10:30:12.928984   24562 generic.go:271] PLEG: pod apiserver-inspection-workers-ds-1542964416453270535-6vhmt/qiniu-ranger failed reinspection: rpc error: code = DeadlineExceeded desc = context deadline exceeded</span><br><span class="line">Nov 27 10:34:13 xq68 kubelet[24562]: E1127 10:34:13.993793   24562 generic.go:271] PLEG: pod apiserver-inspection-workers-ds-1542964416453270535-6vhmt/qiniu-ranger failed reinspection: rpc error: code = DeadlineExceeded desc = context deadline exceeded</span><br></pre></td></tr></table></figure><p>PLEG (Pod Lifecycle Event Generator) 是 kubelet 定期检查节点上每个 pod 状态的逻辑，它内部缓存了节点所有 pod 的状态，每次通过 relist 时从 container runtime (dockerd) 获取 pod (也就是 pod 包含的所有 container) 的最新状态，然后和当前缓存比较，产生 <code>PodLifecycleEvent</code>。然后遍历所有的 events，更新 pod 状态缓存后将该 event 发送至 event channel。部分代码如下：</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/5.png"><p>而问题就出在更新 Pod 缓存的逻辑，首先 PLEG 更新缓存是串行的，也就是前一个 Pod 执行成功了，后一个 Pod 才能开始；其次，更新缓存会调用 container runtime 的 <code>GetPodStatus</code> 接口来获取 Pod 状态（通过 rpc 获取容器状态和 Pod IP）；而 rpc 调用是阻塞的，默认 120s (2min) 超时；PLEG 只要发现两次 relist 间隔超过 3min，就会认为 PLEG unhealthy，将节点设为 NotReady。</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/6.png"> <img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/7.png"><p>上面的 <code>GetPodStatus</code> 中有调用 cri 的 rpc 接口 PodSandboxStatus 和 <code>ListContainers</code>/<code>ContainerStatus</code> 分别获取 pause 容器和其他容器的状态。</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/8.png"><p>其中 ListContainers/ContainerStatus 里只会从 docker daemon 获取容器信息，而 PodSandboxStatus 不仅会从 docker daemon 获取 pause 容器信息，还会从 CNI 通过 GetPodNetworkStatus 接口获取 pod ip。这几个请求都是 grpc 请求，且超时时间都是 2min，如果中间因为各种原因 hang 住，会阻塞 2min 才能超时返回。</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/9.png"> <img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/10.png"> <img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/11.png"><p>简单整理了整个调用逻辑如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">         grpc       http           grpc</span><br><span class="line">kubelet &lt;----&gt; cri &lt;----&gt; dockerd &lt;----&gt; containerd</span><br><span class="line">                   &lt;----&gt;   cni   &lt;----&gt; network plugin      </span><br><span class="line">                    grpc          command</span><br></pre></td></tr></table></figure><p>同时由上面代码分析，PLEG 超时的原因，就是在更新某个 Pod 状态时，kubelet 通过 rpc 调用 docker daemon 或者 network plugin 时超时了。</p><p><strong>调用 docker daemon 超时的原因有：</strong></p><p>docker daemon hang 住。</p><p><strong>调用 network plugin 超时的原因有：</strong></p><p>network plugin 是利用 command exec 方式调用的， 因为各种原因进程不退出，会导致调用 hang 住。</p><p>调用 network plugin 还有个细节，就是每次调用前会按照 pod 加锁，<strong>所以只要一次调用 hang 住，后面的调用都会 hang 住，等待锁释放</strong>。</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/12.png"><p>但是为什么对一个 Pod 调用 GetPodStatus 时 grpc 超时会导致 PLEG unhealthy 呢？我们先看看两个逻辑：</p><p>一是 relist 时的 updateCache 逻辑：</p><p>PLEG 每次 relist 时不仅要对当前状态有更新的 Pod 进行一次状态获取，还要对上次获取失败的 Pod 重新执行一次状态获取。也就是说，如果一个 grpc 请求的超时是 2min，那么假设一个 Pod 有问题，会将单次 relist 耗时放大至 4min。</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/13.png"><p>二是 PLEG healthy check 逻辑：</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/14.png"> <img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/15.png"><p>Runtime Health Checker 会定时调用 PLEG 的 Healty 函数对 PLEG 执行状态进行检测，从而判断节点的健康状况。每次检测时，只要判断距离上次执行完 relist 的时间大于 3 分钟，上层逻辑就会认为节点不健康了，便会根据结果将节点设置为 NotReady。</p><p>现在的场景是 PLEG relist 会执行，但是每次执行对于有问题的 Pod 要执行两次 updateCache/GetPodStatus，也就是等两次超时需要 4min 时间。Runtime Healthy Checker 每隔 100ms ~ 5s 执行一次，因此在 4min 内，前 3min 的 health check 是成功的，成功之后会将节点标记为 Ready，而 3min 后的 1min 内 healthy check 会失败，kubelet 又会将节点标记为 NotReady。</p><p>这个也能从监控图像上得到证实，如下图，ready status == 1 的间隔是 3min，ready status == 0 的间隔是 1min。</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/16.png"><p>接下来我们一步步确认是哪个组件出了问题导致的：</p><p>确认 docker daemon 状态，看状态获取接口是否正常：</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --unix-socket /var/run/docker.sock http:/containers/40cddec6426e280b8e42a07ca5c8711d18557f3163c2541efd39462ccba10e39/json</span><br></pre></td></tr></table></figure><p>结果正常返回。</p><p>再查看网络组件进程状态，发现 nuke 和 nuke-ipam 两个进程从 2018-11-23 启动后一直没有退出（今天是 2018-11-27）。正常情况下，nuke 和 nkue-ipam 只在 kubelet 通过 cni 调用时执行，执行成功后会立即退出，而现在没有退出是个异常。因此判断问题可能出在 nuke 组件上。</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@xq68:~<span class="hljs-comment"># ps aux | grep nuke</span></span><br><span class="line">root     21122  3.3  0.0  40064 38164 ?        Ssl  Nov19 390:35 /nuke/nukedaemon</span><br><span class="line">root     22814  0.0  0.0 116436  8528 ?        Sl   Nov23   0:00 /opt/cni/bin/nuke</span><br><span class="line">root     22831  0.0  0.0 115204  8192 ?        Sl   Nov23   0:00 /opt/cni/bin/nuke-ipam</span><br><span class="line">root     24012  0.0  0.0  14224  1032 pts/32   S+   10:24   0:00 grep --color=auto nuke</span><br><span class="line">root     29315  0.0  0.0   1560   960 ?        Ss   Jul27   0:00 sh /app/install-nuke-cni.sh</span><br><span class="line">root     31448  0.0  0.0  28280 23696 ?        Ssl  Nov01  28:36 /bin/nuke-l3-agent</span><br></pre></td></tr></table></figure><p>之前出现同样的问题时，为方便排查，我保存了 nuke 相关的 stack 信息，具体原因还需要网络组协助排查。</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/17.png"><p>另外，如果网络方案为 calico，calico 进程 Z 住也会导致该问题：</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/18.png"><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>解决方式有：（选一种即可）</p><ol><li><p>删除问题容器（一般都是 pause 容器）</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a | grep apiserver-inspection-workers-ds-1542964416453270535-6vhmt</span><br><span class="line">docker rm -f &lt;container_id&gt;</span><br></pre></td></tr></table></figure><p>删除后 kubelet 已经找不到这个容器，会认为 sandbox 已经 stop 成功，就不会再继续执行 PodSandBoxStatus 调用 cri 和 cni，从而就不会触发有问题的逻辑了。</p></li><li><p>重启 kubelet（待验证）</p></li><li><p>对于 neutron 网络方案，手动 kill 掉 hang 住的 nuke 和 nuke-ipam，network plugin 强行返回错误，kubelet 会继续执行后续逻辑。</p></li></ol><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><h3 id="优化-kubelet-PLEG-逻辑"><a href="#优化-kubelet-PLEG-逻辑" class="headerlink" title="优化 kubelet PLEG 逻辑"></a>优化 kubelet PLEG 逻辑</h3><ul><li>考虑并行执行，一个 Pod 有问题时不影响整个 PLEG relist 耗时；</li><li>缩小 rpc 超时时间（目前 2min），对于正常场景来说，调用 cri 和 cni 都用不了这么长的时间。缩小超时可以减小单个 Pod 超时对 PLEG 整体的影响；</li><li>优化 updateCache 逻辑，保证每次 relist 对同一个 Pod 只进行一次状态获取。</li></ul><h3 id="修复-network-plugin"><a href="#修复-network-plugin" class="headerlink" title="修复 network plugin"></a>修复 network plugin</h3><p>寻找 network plugin hang 住的原因并修复。</p><h3 id="优化监控告警"><a href="#优化监控告警" class="headerlink" title="优化监控告警"></a>优化监控告警</h3><ul><li>pleg latency &gt; 240s for 15min -&gt; error 短信、slack 告知</li><li>pleg latency &gt; 240s -&gt; warning slack 告知</li></ul><h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><p><a href="https://github.com/kubernetes/kubernetes/issues/45419" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/issues/45419</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;收到告警提示 PLEG 延时升高（240s）&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="云计算" scheme="http://whypro.github.io/hexo-blog/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Kubernetes" scheme="http://whypro.github.io/hexo-blog/tags/Kubernetes/"/>
    
      <category term="K8S" scheme="http://whypro.github.io/hexo-blog/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>HTC 刷机备忘</title>
    <link href="http://whypro.github.io/hexo-blog/20181020/HTC-%E5%88%B7%E6%9C%BA%E5%A4%87%E5%BF%98/"/>
    <id>http://whypro.github.io/hexo-blog/20181020/HTC-刷机备忘/</id>
    <published>2018-10-20T11:10:26.000Z</published>
    <updated>2019-06-02T09:10:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者对 HTC 手机有着深厚的感情，从 HTC G2 到 HTC M8，经历了 HTC 的鼎盛和衰落。本文记录了一些常用的刷机方法和 hack 命令，以作备忘。</p><h2 id="官方-Unlock-ReLock-方法"><a href="#官方-Unlock-ReLock-方法" class="headerlink" title="官方 Unlock/ReLock 方法"></a>官方 Unlock/ReLock 方法</h2><h3 id="Unlock"><a href="#Unlock" class="headerlink" title="Unlock"></a>Unlock</h3><h4 id="获取解锁-token"><a href="#获取解锁-token" class="headerlink" title="获取解锁 token"></a>获取解锁 token</h4><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot oem get_identifier_token</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt; Identifier Token Start &gt;&gt;&gt;&gt;</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">&lt;&lt;&lt;&lt;&lt; Identifier Token End &gt;&gt;&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="获取解锁码"><a href="#获取解锁码" class="headerlink" title="获取解锁码"></a>获取解锁码</h4><p>前往 <a href="http://www.htcdev.com/bootloader" target="_blank" rel="noopener">http://www.htcdev.com/bootloader</a> 获取官方解锁码。</p><h4 id="刷入解锁码"><a href="#刷入解锁码" class="headerlink" title="刷入解锁码"></a>刷入解锁码</h4><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot flash unlocktoken Unlock_code.bin</span><br></pre></td></tr></table></figure><h3 id="Relock"><a href="#Relock" class="headerlink" title="Relock"></a>Relock</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot oem lock</span><br></pre></td></tr></table></figure><h2 id="刷入-Recovery-方法"><a href="#刷入-Recovery-方法" class="headerlink" title="刷入 Recovery 方法"></a>刷入 Recovery 方法</h2><h3 id="常规方法"><a href="#常规方法" class="headerlink" title="常规方法"></a>常规方法</h3><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb reboot bootloader</span><br><span class="line">fastboot flash recovery recovery.img</span><br></pre></td></tr></table></figure><p>重启后进入 recovery 界面</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fastboot reboot</span><br><span class="line">adb reboot recovery</span><br></pre></td></tr></table></figure><p>或者可以在 fastboot 界面直接进入 recovery</p><h3 id="在-S-OFF-LOCKED-状态下刷入第三方-Recovery-的方法"><a href="#在-S-OFF-LOCKED-状态下刷入第三方-Recovery-的方法" class="headerlink" title="在 S-OFF + LOCKED 状态下刷入第三方 Recovery 的方法"></a>在 S-OFF + LOCKED 状态下刷入第三方 Recovery 的方法</h3><h4 id="准备-ZIP-文件"><a href="#准备-ZIP-文件" class="headerlink" title="准备 ZIP 文件"></a>准备 ZIP 文件</h4><p>在 S-OFF + LOCKED 情况下通过 adb 工具线刷时，所用的 <code>recovery.zip</code> 包里必须包括 <code>android-info.txt</code> 和 <code>recovery.img</code>。而这个 <code>android-info.txt</code> 的内容必须符合你的手机信息，以我的 Sprint 版为例，其内容是：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">modelid: PN0720000</span><br><span class="line">cidnum: 11111111</span><br><span class="line">mainver: 5.03.651.3</span><br><span class="line">btype:1</span><br><span class="line">aareport:1</span><br><span class="line">DelCache:1</span><br><span class="line">hbootpreupdate:3</span><br></pre></td></tr></table></figure><p>查询以上信息的方法为：在 adb 中输入 <code>fastboot getvar all</code> 即可看到，然后将所需的 <code>modelid</code>、<code>cidnum</code>、<code>mainver</code> 信息修改到 <code>android-info.txt</code> 文件中。</p><p><code>android-info.txt</code> 文件可以从官方 RUU 中提取，然后把上面查询到的信息替换到里面即可。</p><p>最后将 <code>recovery.img</code> 和 <code>android-info.txt</code> 一起打包到 zip 压缩包中，并放入 adb 工具的文件夹里即可开始下面步骤了。</p><p>（刷 radio 也是同理，必须在 zip 压缩包中加入 <code>android-info.txt</code>。）</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb reboot bootloader</span><br><span class="line">fastboot oem rebootRUU</span><br><span class="line">fastboot flash zip recovery.zip</span><br></pre></td></tr></table></figure><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot reboot</span><br></pre></td></tr></table></figure><h2 id="BootLoader-状态随意修改（需要-S-OFF）"><a href="#BootLoader-状态随意修改（需要-S-OFF）" class="headerlink" title="BootLoader 状态随意修改（需要 S-OFF）"></a>BootLoader 状态随意修改（需要 S-OFF）</h2><h3 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h3><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="hljs-keyword">if</span>=/dev/block/mmcblk0p3 bs=1 skip=33796 count=4</span><br></pre></td></tr></table></figure><h3 id="LOCK"><a href="#LOCK" class="headerlink" title="LOCK"></a>LOCK</h3><p>to LOCK your bootloader,enter the following:</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br><span class="line"></span><br><span class="line">adb shell</span><br><span class="line"></span><br><span class="line">su (<span class="hljs-keyword">if</span> needed to get a <span class="hljs-comment"># prompt)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># (i would very strongly recomend you copy/paste this)</span></span><br><span class="line"><span class="hljs-built_in">echo</span> -ne <span class="hljs-string">'\x00\x00\x00\x00'</span> | dd of=/dev/block/mmcblk0p3 bs=1 seek=33796</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># (exit a second time if you need to to get back to a normal &gt; prompt)</span></span><br><span class="line"><span class="hljs-built_in">exit</span></span><br><span class="line"></span><br><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure><p>verify you are now locked</p><h3 id="UNLOCK"><a href="#UNLOCK" class="headerlink" title="UNLOCK"></a>UNLOCK</h3><p>to UNLOCK your bootloader,enter the following:</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br><span class="line"></span><br><span class="line">adb shell</span><br><span class="line"></span><br><span class="line">su (<span class="hljs-keyword">if</span> needed to get a <span class="hljs-comment"># prompt)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># (i would very strongly recomend you copy/paste this)</span></span><br><span class="line"><span class="hljs-built_in">echo</span> -ne <span class="hljs-string">"HTCU"</span> | dd of=/dev/block/mmcblk0p3 bs=1 seek=33796</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># (exit a second time if you need to to get back to a normal &gt; prompt)</span></span><br><span class="line"><span class="hljs-built_in">exit</span></span><br><span class="line"></span><br><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure><p>verify you are now unlocked</p><h3 id="RELOCK"><a href="#RELOCK" class="headerlink" title="RELOCK"></a>RELOCK</h3><p>to RELOCK your bootloader,enter the following:</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br><span class="line"></span><br><span class="line">adb shell</span><br><span class="line"></span><br><span class="line">su (<span class="hljs-keyword">if</span> needed to get a <span class="hljs-comment"># prompt)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># (i would very strongly recomend you copy/paste this)</span></span><br><span class="line"><span class="hljs-built_in">echo</span> -ne <span class="hljs-string">"HTCL"</span> | dd of=/dev/block/mmcblk0p3 bs=1 seek=33796</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># (exit a second time if you need to to get back to a normal &gt; prompt)</span></span><br><span class="line"><span class="hljs-built_in">exit</span></span><br><span class="line"></span><br><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure><p>verify you are now relocked</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://bbs.gfan.com/android-7235658-1-1.html" target="_blank" rel="noopener">http://bbs.gfan.com/android-7235658-1-1.html</a></p><p><a href="https://androidforums.com/threads/how-to-lock-unlock-your-bootloader-without-htcdev-s-off-required.916138/" target="_blank" rel="noopener">https://androidforums.com/threads/how-to-lock-unlock-your-bootloader-without-htcdev-s-off-required.916138/</a></p><h2 id="HTC-测试指令"><a href="#HTC-测试指令" class="headerlink" title="HTC 测试指令"></a>HTC 测试指令</h2><p>测试指令：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*#*#3424#*#*</span><br></pre></td></tr></table></figure><p>工程模式</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*#*#4636#*#*</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者对 HTC 手机有着深厚的感情，从 HTC G2 到 HTC M8，经历了 HTC 的鼎盛和衰落。本文记录了一些常用的刷机方法和 hack 命令，以作备忘。&lt;/p&gt;&lt;h2 id=&quot;官方-Unlock-ReLock-方法&quot;&gt;&lt;a href=&quot;#官方-Unlock-ReLock-方法&quot; class=&quot;headerlink&quot; title=&quot;官方 Unlock/ReLock 方法&quot;&gt;&lt;/a&gt;官方 Unlock/ReLock 方法&lt;/h2&gt;&lt;h3 id=&quot;Unlock&quot;&gt;&lt;a href=&quot;#Unlock&quot; class=&quot;headerlink&quot; title=&quot;Unlock&quot;&gt;&lt;/a&gt;Unlock&lt;/h3&gt;&lt;h4 id=&quot;获取解锁-token&quot;&gt;&lt;a href=&quot;#获取解锁-token&quot; class=&quot;headerlink&quot; title=&quot;获取解锁 token&quot;&gt;&lt;/a&gt;获取解锁 token&lt;/h4&gt;&lt;figure class=&quot;highlight sh hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fastboot oem get_identifier_token&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="HTC" scheme="http://whypro.github.io/hexo-blog/tags/HTC/"/>
    
      <category term="刷机" scheme="http://whypro.github.io/hexo-blog/tags/%E5%88%B7%E6%9C%BA/"/>
    
      <category term="Android" scheme="http://whypro.github.io/hexo-blog/tags/Android/"/>
    
      <category term="安卓" scheme="http://whypro.github.io/hexo-blog/tags/%E5%AE%89%E5%8D%93/"/>
    
  </entry>
  
  <entry>
    <title>etcd 集群的备份和还原</title>
    <link href="http://whypro.github.io/hexo-blog/20180725/etcd-%E9%9B%86%E7%BE%A4%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E8%BF%98%E5%8E%9F/"/>
    <id>http://whypro.github.io/hexo-blog/20180725/etcd-集群的备份和还原/</id>
    <published>2018-07-25T08:12:00.000Z</published>
    <updated>2019-06-02T09:10:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>安装 etcdctl</p><p><strong>方法1</strong></p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install etcd-client=3.2.17+dfsg-1</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>方法2</strong></p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">export</span> RELEASE=<span class="hljs-string">"3.2.17"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">test</span> -d /tmp/etcd &amp;&amp; mkdir -p /tmp/etcd &amp;&amp; <span class="hljs-built_in">cd</span> /tmp/etcd</span><br><span class="line">wget https://github.com/etcd-io/etcd/releases/download/v<span class="hljs-variable">$&#123;RELEASE&#125;</span>/etcd-v<span class="hljs-variable">$&#123;RELEASE&#125;</span>-linux-amd64.tar.gz</span><br><span class="line">tar -zxvf etcd-v<span class="hljs-variable">$&#123;RELEASE&#125;</span>-linux-amd64.tar.gz</span><br><span class="line"><span class="hljs-built_in">cd</span> etcd-v<span class="hljs-variable">$&#123;RELEASE&#125;</span>-linux-amd64</span><br><span class="line">cp etcdctl /usr/<span class="hljs-built_in">local</span>/bin</span><br><span class="line"></span><br><span class="line">etcdctl --version</span><br></pre></td></tr></table></figure><p><strong>方法3</strong></p><p>使用 docker cp 从 etcd 容器中拷贝。</p><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>etcd 的备份有两种方式，选择其一即可。</p><h3 id="方式一：使用-etcdctl-snapshot-命令（推荐）"><a href="#方式一：使用-etcdctl-snapshot-命令（推荐）" class="headerlink" title="方式一：使用 etcdctl snapshot 命令（推荐）"></a>方式一：使用 etcdctl snapshot 命令（推荐）</h3><p>在任何一个 member 节点执行：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl snapshot save snapshot.db</span><br></pre></td></tr></table></figure><h3 id="方式二：拷贝-member-snap-db-文件"><a href="#方式二：拷贝-member-snap-db-文件" class="headerlink" title="方式二：拷贝 member/snap/db 文件"></a>方式二：拷贝 member/snap/db 文件</h3><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /var/lib/etcd/member/snap/db snapshot.db</span><br></pre></td></tr></table></figure><p>如果使用此方法，etcdctl snapshot restore 时需要设置 <code>--skip-hash-check=true</code></p><h2 id="还原"><a href="#还原" class="headerlink" title="还原"></a>还原</h2><h3 id="方式一：单节点还原成功后，再将其他节点加入集群"><a href="#方式一：单节点还原成功后，再将其他节点加入集群" class="headerlink" title="方式一：单节点还原成功后，再将其他节点加入集群"></a>方式一：单节点还原成功后，再将其他节点加入集群</h3><p>根据 snapshot.db 生成新的 data dir：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># restore.sh</span></span><br><span class="line"></span><br><span class="line">rm /var/lib/etcd -rf </span><br><span class="line"> </span><br><span class="line">ETCDCTL_API=3 etcdctl snapshot restore snapshot.db \</span><br><span class="line">  --name k8s-etcd-host1 \</span><br><span class="line">  --data-dir /var/lib/etcd \</span><br><span class="line">  --initial-cluster k8s-etcd-host1=http://host1:2380 \</span><br><span class="line">  --initial-cluster-token k8s-etcd \</span><br><span class="line">  --initial-advertise-peer-urls http://host1:2380 \</span><br><span class="line">  --skip-hash-check=<span class="hljs-literal">false</span></span><br></pre></td></tr></table></figure><p>启动单实例：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">spec:</span></span><br><span class="line"><span class="hljs-attr">  containers:</span></span><br><span class="line"><span class="hljs-attr">  - command:</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-string">etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--name=k8s-etcd-host1</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-advertise-peer-urls=http://host1:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--listen-peer-urls=http://host1:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--listen-client-urls=http://0.0.0.0:2379</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--advertise-client-urls=http://host1:2379</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--data-dir=/var/lib/etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster-token=k8s-etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster=k8s-etcd-host1=http://host1:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster-state=existing</span></span><br></pre></td></tr></table></figure><p>将其他节点依次加入集群（先执行 add 命令再启动实例），add 命令如下：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl member add k8s-etcd-host2 http://host2:2380</span><br></pre></td></tr></table></figure><p>启动实例：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">spec:</span></span><br><span class="line"><span class="hljs-attr">  containers:</span></span><br><span class="line"><span class="hljs-attr">  - command:</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-string">etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--name=k8s-etcd-host2</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-advertise-peer-urls=http://host2:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--listen-peer-urls=http://host2:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--listen-client-urls=http://0.0.0.0:2379</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--advertise-client-urls=http://host2:2379</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--data-dir=/var/lib/etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster-token=k8s-etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster=k8s-etcd-host1=http://host1:2380,k8s-etcd-host2=http://host2:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster-state=existing</span></span><br></pre></td></tr></table></figure><p>其他实例操作方法类似。</p><h3 id="方式二：同时还原多节点集群"><a href="#方式二：同时还原多节点集群" class="headerlink" title="方式二：同时还原多节点集群"></a>方式二：同时还原多节点集群</h3><p>将 snapshot.db 文件拷贝至所有 etcd 节点，根据 snapshot.db 生成 data dir：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl snapshot restore snapshot.db \</span><br><span class="line">  --name k8s-etcd-host1 \</span><br><span class="line">  --data-dir /var/lib/etcd \</span><br><span class="line">  --initial-cluster k8s-etcd-host1=http://host1:2380,k8s-etcd-host2=http://host2:2380,k8s-etcd-host3=http://host3:2380 \</span><br><span class="line">  --initial-cluster-token k8s-etcd \</span><br><span class="line">  --initial-advertise-peer-urls http://host1:2380 \</span><br><span class="line">  --skip-hash-check=<span class="hljs-literal">false</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">ETCDCTL_API=3 etcdctl snapshot restore snapshot.db \</span><br><span class="line">  --name k8s-etcd-host2 \</span><br><span class="line">  --data-dir /var/lib/etcd \</span><br><span class="line">  --initial-cluster k8s-etcd-host1=http://host1:2380,k8s-etcd-host2=http://host2:2380,k8s-etcd-host3=http://host3:2380 \</span><br><span class="line">  --initial-cluster-token k8s-etcd \</span><br><span class="line">  --initial-advertise-peer-urls http://host2:2380 \</span><br><span class="line">  --skip-hash-check=<span class="hljs-literal">false</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">ETCDCTL_API=3 etcdctl snapshot restore snapshot.db \</span><br><span class="line">  --name k8s-etcd-host3 \</span><br><span class="line">  --data-dir /var/lib/etcd \</span><br><span class="line">  --initial-cluster k8s-etcd-host1=http://host1:2380,k8s-etcd-host2=http://host2:2380,k8s-etcd-host3=http://host3:2380 \</span><br><span class="line">  --initial-cluster-token k8s-etcd \</span><br><span class="line">  --initial-advertise-peer-urls http://host3:2380 \</span><br><span class="line">  --skip-hash-check=<span class="hljs-literal">false</span></span><br></pre></td></tr></table></figure><p>还原后启动所有 etcd 实例 。启动参数如下，其他类似：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">spec:</span></span><br><span class="line"><span class="hljs-attr">  containers:</span></span><br><span class="line"><span class="hljs-attr">  - command:</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-string">etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--name=k8s-etcd-host1</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-advertise-peer-urls=http://host1:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--listen-peer-urls=http://host1:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--listen-client-urls=http://0.0.0.0:2379</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--advertise-client-urls=http://host1:2379</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--data-dir=/var/lib/etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster-token=k8s-etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster=k8s-etcd-host1=http://host1:2380,k8s-etcd-host2=http://host2:2380,k8s-etcd-host3=http://host3:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster-state=existing</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>启动 etcd 之前最好停掉 kube-apiserver</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://coreos.com/etcd/docs/3.1.12/op-guide/recovery.html" target="_blank" rel="noopener">https://coreos.com/etcd/docs/3.1.12/op-guide/recovery.html</a></li><li><a href="https://coreos.com/etcd/docs/latest/op-guide/runtime-configuration.html" target="_blank" rel="noopener">https://coreos.com/etcd/docs/latest/op-guide/runtime-configuration.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;p&gt;安装 etcdctl&lt;/p&gt;&lt;p&gt;&lt;strong&gt;方法1&lt;/strong&gt;&lt;/p&gt;&lt;figure class=&quot;highlight sh hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;apt install etcd-client=3.2.17+dfsg-1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="云计算" scheme="http://whypro.github.io/hexo-blog/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Kubernetes" scheme="http://whypro.github.io/hexo-blog/tags/Kubernetes/"/>
    
      <category term="K8S" scheme="http://whypro.github.io/hexo-blog/tags/K8S/"/>
    
      <category term="etcd" scheme="http://whypro.github.io/hexo-blog/tags/etcd/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 容器生命周期管理</title>
    <link href="http://whypro.github.io/hexo-blog/20180404/Kubernetes-%E5%AE%B9%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/"/>
    <id>http://whypro.github.io/hexo-blog/20180404/Kubernetes-容器生命周期管理/</id>
    <published>2018-04-04T08:09:40.000Z</published>
    <updated>2019-06-02T09:10:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="健康检查和就绪检查"><a href="#健康检查和就绪检查" class="headerlink" title="健康检查和就绪检查"></a>健康检查和就绪检查</h2><h3 id="健康检查（Liveness-Probe）"><a href="#健康检查（Liveness-Probe）" class="headerlink" title="健康检查（Liveness Probe）"></a>健康检查（Liveness Probe）</h3><p>如果设置了 <code>livenessProbe</code>，k8s (kubelet) 会每隔 n 秒执行预先配置的行为来检查容器是否健康</p><p>当健康检查失败时，k8s 会认为容器已经挂掉，会根据 <code>restartPolicy</code> 来对容器进行重启或其他操作。</p><p>每次检查有 3 种结果，<code>Success</code>、<code>Failure</code>、<code>Unknown</code></p><p>如果不配置，默认的检查状态为 <code>Success</code></p><a id="more"></a><p><strong>什么时候不需要健康检查</strong>：如果服务在异常后会自动退出或 crash，就不必配置健康检查，k8s 会按照重启策略来自动操作。</p><p><strong>什么时候需要健康检查</strong>：相反，如果服务异常必须由 k8s 主动介入来重启容器，就需要配置健康检查</p><h3 id="就绪检查（Readiness-Probe）"><a href="#就绪检查（Readiness-Probe）" class="headerlink" title="就绪检查（Readiness Probe）"></a>就绪检查（Readiness Probe）</h3><p>如果设置了 <code>readinessProbe</code>，k8s (kubelet) 会每隔 n 秒检查容器对外提供的服务是否正常</p><p>当就绪检查失败时，k8s 会将 Pod 标记为 <code>Unready</code>，将 Pod IP 从 endpoints 中剔除，即不会让之后的流量通过 service 发送过来。</p><p>在首次检查之前，初始状态为 <code>Failure</code></p><p>如果不配置，默认的状态为 <code>Success</code></p><p><strong>什么时候需要就绪检查</strong>：如果在服务启动后、初始化完成之前不想让流量过来，就需要配置就绪检查。</p><p><strong>什么时候不需要就绪检查</strong>：除了上述场景，在 Pod 被删除时，k8s 会主动将 Pod 置为 <code>UnReady</code> 状态，之后的流量也不会过来，因此针对这种情况不必配置就绪检查。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>健康／就绪检查支持以下参数：</p><ul><li><code>initialDelaySeconds</code>: 容器启动后，进行首次检查的等待时间（秒）</li><li><code>periodSeconds</code>: 每次检查的间隔时间（秒）</li><li><code>timeoutSeconds</code>: 执行检查的超时时间（秒），默认值为 1，最小值是 1</li><li><code>successThreshold</code>: 检查失败时，连续成功 n 次后，认为该容器的健康／就绪检查成功。默认值为 1，最小值是 1，对于健康检查必须为 1</li><li><code>failureThreshold</code>: 连续失败 n 次后，认为该容器的健康／就绪检查失败。默认值为 3，最小值是 1</li></ul><h3 id="检查方式"><a href="#检查方式" class="headerlink" title="检查方式"></a>检查方式</h3><h4 id="Exec-方式"><a href="#Exec-方式" class="headerlink" title="Exec 方式"></a>Exec 方式</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">livenessProbe:</span><br><span class="line">  exec:</span><br><span class="line">    command:</span><br><span class="line">    - cat</span><br><span class="line">    - /tmp/healthy</span><br></pre></td></tr></table></figure><h4 id="HTTP-GET-请求方式"><a href="#HTTP-GET-请求方式" class="headerlink" title="HTTP GET 请求方式"></a>HTTP GET 请求方式</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">livenessProbe:</span><br><span class="line">  httpGet:</span><br><span class="line">    path: /healthz</span><br><span class="line">    port: 8080</span><br><span class="line">    httpHeaders:</span><br><span class="line">    - name: X-Custom-Header</span><br><span class="line">      value: Awesome</span><br></pre></td></tr></table></figure><p>支持的参数包括：</p><ul><li><code>host</code>: 目标主机地址，默认值为 pod IP</li><li><code>scheme</code>: HTTP 或 HTTPS，默认为 HTTP</li><li><code>path</code>: 访问路径</li><li><code>httpHeaders</code>: 自定义请求头</li><li><code>port</code>: 目标端口号，有效值 1~65535</li></ul><h4 id="TCP-Socket-方式"><a href="#TCP-Socket-方式" class="headerlink" title="TCP Socket 方式"></a>TCP Socket 方式</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">livenessProbe:</span><br><span class="line">  tcpSocket:</span><br><span class="line">    port: 8080</span><br></pre></td></tr></table></figure><p>支持的参数包括：</p><ul><li><code>host</code>: 目标主机地址，默认值为 pod IP</li><li><code>port</code>: 目标端口号，有效值 1~65535</li></ul><h2 id="容器重启策略"><a href="#容器重启策略" class="headerlink" title="容器重启策略"></a>容器重启策略</h2><p><code>restartPolicy</code> 是 livenessProbe <code>Failure</code> 后执行的策略，作用于 Pod 的每个容器，可以配置为 <code>Always</code>、<code>OnFaiiure</code>、<code>Never</code>，默认值为 <code>Always</code>。</p><p><code>restartPolicy</code> 只会影响本机节点重启容器的策略，并不会影响 Pod 重新调度的行为，重启的方式按照时间间隔（10s, 20s, 40s, …, 5min）来重启容器，并且每 10min 重置间隔时间</p><p>重启策略 <code>restartPolicy</code> 的配置通过以下几个场景来举例说明：</p><ol><li>Pod Running 状态，包含 1 个容器，容器正常退出</li></ol><p>记录 completion 事件</p><ul><li><code>Always</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>OnFaiiure</code>: 不重启容器，Pod phase 变为 <code>Succeeded</code></li><li><code>Never</code>: 不重启容器，Pod phase 变为 <code>Succeeded</code></li></ul><ol start="2"><li>Pod Running 状态，包含 1 个容器，容器异常退出</li></ol><p>记录 failure 事件</p><ul><li><code>Always</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>OnFaiiure</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>Never</code>: 不重启容器，Pod phase 变为 <code>Failed</code></li></ul><ol start="3"><li>Pod Running 状态，包含 2 个容器，其中一个容器异常退出</li></ol><p>记录 failure 事件</p><ul><li><code>Always</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>OnFaiiure</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>Never</code>: 不重启容器，Pod phase 保持 <code>Running</code> 状态</li></ul><p>此时如果第二个容器退出（无论正常还是异常）</p><p>记录 failure 事件</p><ul><li><code>Always</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>OnFaiiure</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>Never</code>: 不重启容器，Pod phase 变为 <code>Failed</code></li></ul><ol start="4"><li>Pod Running 状态，包含 1 个容器，容器被 OOM (out of memory) killed</li></ol><p>记录 OOM 事件</p><ul><li><code>Always</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>OnFaiiure</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>Never</code>: 不重启容器，Pod phase 变为 <code>Failed</code></li></ul><ol start="5"><li>Pod Running 状态，遇到节点异常（比如磁盘挂掉、segmented out）</li></ol><p>根据异常原因记录相应事件</p><p>无论设置为哪种策略，Pod 状态变为 <code>Failed</code>，并尝试在其他节点重新创建（如果 Pod 是通过 Controller 管理的）</p><h2 id="容器生存周期事件处理"><a href="#容器生存周期事件处理" class="headerlink" title="容器生存周期事件处理"></a>容器生存周期事件处理</h2><p>k8s 在容器创建或终止时会发送 <code>postStart</code> 或 <code>preStop</code> 事件，用户可以通过配置 handler，对这两个容器事件进行处理。</p><p>k8s 在容器创建之后发送 <code>postStart</code> 事件，postStart handler 是异步执行，所以并不保证会在容器的 entrypoint 之前执行，不过容器代码会阻塞住直到 postStart handler 执行完成。执行成功后，容器状态才会设为 <code>Running</code></p><p>k8s 在容器 terminate 之前发送 <code>preStop</code> 事件，terminate 行为会阻塞，直到 preStop handler 同步执行成功或者 Pod 配置的 grace period 超时 (<code>terminationGracePeriodSeconds</code>)。注意：如果不是主动终止，k8s 不会发送 <code>preStop</code> 事件（比如正常退出）。</p><p>如果 postStart 或 preStop handler 执行失败，k8s 直接 kill 掉容器。</p><h3 id="handler-执行方式"><a href="#handler-执行方式" class="headerlink" title="handler 执行方式"></a>handler 执行方式</h3><h4 id="Exec-方式-1"><a href="#Exec-方式-1" class="headerlink" title="Exec 方式"></a>Exec 方式</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lifecycle:</span><br><span class="line">  postStart:</span><br><span class="line">    exec:</span><br><span class="line">      command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo Hello from the postStart handler &gt; /usr/share/message&quot;]</span><br></pre></td></tr></table></figure><h4 id="HTTP-GET-方式"><a href="#HTTP-GET-方式" class="headerlink" title="HTTP GET 方式"></a>HTTP GET 方式</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lifecycle:</span><br><span class="line">  postStart:</span><br><span class="line">    httpGet:</span><br><span class="line">      path: /healthz</span><br><span class="line">      port: 8080</span><br><span class="line">      httpHeaders:</span><br><span class="line">      - name: X-Custom-Header</span><br><span class="line">        value: Awesome</span><br></pre></td></tr></table></figure><h2 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h2><p>livenessProbe 和 readinessProbe 的配置项完全相同，只是检查失败后的行为不同</p><p>lifecycle 的 exec 和 httpGet 和 livenessProbe 对应的配置项相同。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: example</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: example</span><br><span class="line">    // ... </span><br><span class="line">    livenessProbe:</span><br><span class="line">      exec:</span><br><span class="line">        command:</span><br><span class="line">        - cat</span><br><span class="line">        - /tmp/healthy</span><br><span class="line">      initialDelaySeconds: 5</span><br><span class="line">      periodSeconds: 10</span><br><span class="line">    readinessProbe:</span><br><span class="line">      tcpSocket:</span><br><span class="line">        port: 8080</span><br><span class="line">      initialDelaySeconds: 10</span><br><span class="line">      periodSeconds: 10</span><br><span class="line">    lifecycle:</span><br><span class="line">      postStart:</span><br><span class="line">        exec:</span><br><span class="line">          command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo Hello from the postStart handler &gt; /usr/share/message&quot;]</span><br><span class="line">      preStop:</span><br><span class="line">        httpGet:</span><br><span class="line">          host: xxx.xxx.xxx</span><br><span class="line">          path: /stop</span><br><span class="line">          port: 8080</span><br><span class="line">  restartPolicy: OnFailure</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Pod 生命周期：<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/</a></p><p>健康检查和就绪检查：<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/</a></p><p>容器生存周期事件处理：<br><a href="https://kubernetes.io/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/</a><br><a href="https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;健康检查和就绪检查&quot;&gt;&lt;a href=&quot;#健康检查和就绪检查&quot; class=&quot;headerlink&quot; title=&quot;健康检查和就绪检查&quot;&gt;&lt;/a&gt;健康检查和就绪检查&lt;/h2&gt;&lt;h3 id=&quot;健康检查（Liveness-Probe）&quot;&gt;&lt;a href=&quot;#健康检查（Liveness-Probe）&quot; class=&quot;headerlink&quot; title=&quot;健康检查（Liveness Probe）&quot;&gt;&lt;/a&gt;健康检查（Liveness Probe）&lt;/h3&gt;&lt;p&gt;如果设置了 &lt;code&gt;livenessProbe&lt;/code&gt;，k8s (kubelet) 会每隔 n 秒执行预先配置的行为来检查容器是否健康&lt;/p&gt;&lt;p&gt;当健康检查失败时，k8s 会认为容器已经挂掉，会根据 &lt;code&gt;restartPolicy&lt;/code&gt; 来对容器进行重启或其他操作。&lt;/p&gt;&lt;p&gt;每次检查有 3 种结果，&lt;code&gt;Success&lt;/code&gt;、&lt;code&gt;Failure&lt;/code&gt;、&lt;code&gt;Unknown&lt;/code&gt;&lt;/p&gt;&lt;p&gt;如果不配置，默认的检查状态为 &lt;code&gt;Success&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="云计算" scheme="http://whypro.github.io/hexo-blog/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Kubernetes" scheme="http://whypro.github.io/hexo-blog/tags/Kubernetes/"/>
    
      <category term="K8S" scheme="http://whypro.github.io/hexo-blog/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 服务灰度升级最佳实践</title>
    <link href="http://whypro.github.io/hexo-blog/20180301/Kubernetes-%E6%9C%8D%E5%8A%A1%E7%81%B0%E5%BA%A6%E5%8D%87%E7%BA%A7%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://whypro.github.io/hexo-blog/20180301/Kubernetes-服务灰度升级最佳实践/</id>
    <published>2018-03-01T10:10:00.000Z</published>
    <updated>2019-06-02T09:10:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了 Deployment 和 StatefulSet 的升级机制和扩缩容机制，以及一些常用的配置项。并分别介绍了以这两种方式部署 Pod 时的对服务进行升级（包括滚动发布、蓝绿发布、灰度／金丝雀发布）的最佳实践。</p><h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><h3 id="升级机制"><a href="#升级机制" class="headerlink" title="升级机制"></a>升级机制</h3><h4 id="Rollout"><a href="#Rollout" class="headerlink" title="Rollout"></a>Rollout</h4><p>Deployment 的 rollout 在 .spec.template 被修改时触发（比如镜像地址更新、Pod label 更新等等），其他修改（.spec.replicas 更新）不会触发。</p><p>更新时，k8s 通过计算 pod-template-hash，创建新的 ReplicaSet，由新的 rs 启动新的 Pod，不断替换旧 rs 的 Pod。</p><a id="more"></a><p>通过命令</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; rollout status deployment/&lt;deployment-name&gt;</span><br></pre></td></tr></table></figure><p>查看 Deployment rollout 的状态。</p><p><code>.spec.strategy</code> 定义了更新 Pod 的策略：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">minReadySeconds:</span> <span class="hljs-number">5</span></span><br><span class="line"><span class="hljs-attr">strategy:</span></span><br><span class="line"><span class="hljs-attr">  type:</span> <span class="hljs-string">RollingUpdate</span></span><br><span class="line"><span class="hljs-attr">  rollingUpdate:</span></span><br><span class="line"><span class="hljs-attr">    maxSurge:</span> <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-attr">    maxUnavailable:</span> <span class="hljs-number">1</span></span><br></pre></td></tr></table></figure><ul><li><code>spec.strategy.type</code> 可以为 Recreate 或 RollingUpdate。Recreate 先删掉旧 Pod 再创建新 Pod，RollingUpdate 则按照滚动升级的策略来更新。</li><li><code>maxUnavailable</code>：更新时，Deployment 确保不超过 25%（默认值） 的 Pod 处于 unavailable 状态。既可以是数量也可以是百分比，当 <code>maxSurge</code> 为 <code>0</code> 时 <code>maxUnavailable</code> 不能为 <code>0</code>。</li><li><code>maxSurge</code>：更新时，Deployment 确保当前实际创建的 Pod 数（包括新旧实例总和）不超过期望 Pod 数的 25%（默认值）。既可以是数量也可以是百分比。</li><li><code>minReadySeconds</code>：新创建的 Pod 变为 Ready 状态的最少时间，如果容器在该时间内没有 crash，则认为该 Pod 是 available 的。默认值为 0，表示一旦 readiness probe 通过后就变为 Ready，这时如果没有配置 <code>readinessProbe</code>，则只要 Pod 创建后就会为 Ready 状态，可能会导致服务不可用。</li></ul><h4 id="Rollover"><a href="#Rollover" class="headerlink" title="Rollover"></a>Rollover</h4><p>当 Deployment 在 rollout 过程中被更新时，Deployment 会立即执行新的更新，停止之前的 rollout 动作，并根据期望实例数删除（缩容）之前的 Pod，这个过程叫做 rollover。</p><h4 id="Rollback"><a href="#Rollback" class="headerlink" title="Rollback"></a>Rollback</h4><p>获取 Deployment 的 rollout 历史，最新的 revision 即当前版本</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; rollout history deployment/&lt;deployment-name&gt;</span><br></pre></td></tr></table></figure><p>查看指定 revision 的详细信息</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; rollout history deployment/&lt;deployment-name&gt; --revision=&lt;revision_num&gt;</span><br></pre></td></tr></table></figure><p>回滚到上一个版本</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; rollout undo deployment/&lt;deployment-name&gt;</span><br></pre></td></tr></table></figure><p>回滚到指定版本</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; rollout undo deployment/&lt;deployment-name&gt; --to-revision=&lt;revision_num&gt;</span><br></pre></td></tr></table></figure><p>当 Deployment 回滚成功时，会生成 DeploymentRollback 事件</p><p>可以通过 <code>.spec.revisionHistoryLimit</code> 配置最多保留的 revision 历史个数（不包括当前版本），默认值为 2，即保留 3 个 revision。</p><h4 id="Pause-Resume"><a href="#Pause-Resume" class="headerlink" title="Pause/Resume"></a>Pause/Resume</h4><p>当 Deployment 的 <code>.spec.paused = true</code> 时，任何更新都不会被触发 rollout。通过如下命令设置 Deployment 为 paused：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; rollout pause deployment/&lt;deployment-name&gt;</span><br></pre></td></tr></table></figure><p>还原：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; rollout resume deploy/&lt;deployment-name&gt;</span><br></pre></td></tr></table></figure><h3 id="扩缩容机制"><a href="#扩缩容机制" class="headerlink" title="扩缩容机制"></a>扩缩容机制</h3><h4 id="手动扩缩容"><a href="#手动扩缩容" class="headerlink" title="手动扩缩容"></a>手动扩缩容</h4><p>可以通过修改 <code>.spec.replicas</code>，或者执行 kubectl 命令的方式对 Deployment 进行扩缩容：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale deployment nginx-deployment --replicas=10</span><br></pre></td></tr></table></figure><h4 id="自动扩缩容"><a href="#自动扩缩容" class="headerlink" title="自动扩缩容"></a>自动扩缩容</h4><p>k8s 支持通过创建 HorizontalPodAutoscaler，根据 CPU 利用率或者服务提供的 metrics，对 Deployment、Replication Controller 或者 ReplicaSet 进行自动扩缩容。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl autoscale deployment nginx-deployment --min=10 --max=15 --cpu-percent=80</span><br></pre></td></tr></table></figure><p>详细请参考：</p><p><a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/</a></p><p><a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/</a></p><h3 id="发布最佳实践"><a href="#发布最佳实践" class="headerlink" title="发布最佳实践"></a>发布最佳实践</h3><h4 id="滚动发布"><a href="#滚动发布" class="headerlink" title="滚动发布"></a>滚动发布</h4><p>滚动发布是 Deployment 默认支持的更新方式，除了上文介绍的 rollingUpdate 相关配置外，不需要其他特殊的配置工作，</p><h4 id="灰度／金丝雀发布"><a href="#灰度／金丝雀发布" class="headerlink" title="灰度／金丝雀发布"></a>灰度／金丝雀发布</h4><p>金丝雀发布通过同时创建两个 Deployments 来实现，通过 track 标签区分两个版本，稳定版本的 Deployment 定义如下：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">name:</span> <span class="hljs-string">frontend</span></span><br><span class="line"><span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span></span><br><span class="line"><span class="hljs-string">...</span></span><br><span class="line"><span class="hljs-attr">labels:</span></span><br><span class="line"><span class="hljs-attr">   app:</span> <span class="hljs-string">guestbook</span></span><br><span class="line"><span class="hljs-attr">   tier:</span> <span class="hljs-string">frontend</span></span><br><span class="line"><span class="hljs-attr">   track:</span> <span class="hljs-string">stable</span></span><br><span class="line"><span class="hljs-string">...</span></span><br><span class="line"><span class="hljs-attr">image:</span> <span class="hljs-attr">gb-frontend:v3</span></span><br></pre></td></tr></table></figure><p>金丝雀版本的定义如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name: frontend-canary</span><br><span class="line">replicas: 1</span><br><span class="line">...</span><br><span class="line">labels:</span><br><span class="line">   app: guestbook</span><br><span class="line">   tier: frontend</span><br><span class="line">   track: canary</span><br><span class="line">...</span><br><span class="line">image: gb-frontend:v4</span><br></pre></td></tr></table></figure><p>再配置 service 的 labelSelector 将流量同时导入两个版本的 Pod</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">selector:</span></span><br><span class="line"><span class="hljs-attr">  app:</span> <span class="hljs-string">guestbook</span></span><br><span class="line"><span class="hljs-attr">  tier:</span> <span class="hljs-string">frontend</span></span><br></pre></td></tr></table></figure><p>通过 <code>.spec.replicas</code> 数量和扩缩容机制可以灵活配置稳定版本和金丝雀版本的比例（上面的例子为 3:1），流量会按照这个比例转发至不同版本，一旦线上测试无误后，将 track = stable 的 Deployment 更新为新版本镜像，再删除 track = canary 的 Deployment 即可。</p><h4 id="蓝绿发布"><a href="#蓝绿发布" class="headerlink" title="蓝绿发布"></a>蓝绿发布</h4><p>与金丝雀发布类似，同时创建 2 个label 不同的 Deployment，例如，deployment-1 定义如下：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">name:</span> <span class="hljs-string">frontend</span></span><br><span class="line"><span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span></span><br><span class="line"><span class="hljs-string">...</span></span><br><span class="line"><span class="hljs-attr">labels:</span></span><br><span class="line"><span class="hljs-attr">   app:</span> <span class="hljs-string">guestbook</span></span><br><span class="line"><span class="hljs-attr">   tier:</span> <span class="hljs-string">frontend</span></span><br><span class="line"><span class="hljs-attr">   version:</span> <span class="hljs-string">v3</span></span><br><span class="line"><span class="hljs-string">...</span></span><br><span class="line"><span class="hljs-attr">image:</span> <span class="hljs-attr">gb-frontend:v3</span></span><br></pre></td></tr></table></figure><p>deployment-2 定义如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name: frontend</span><br><span class="line">replicas: 3</span><br><span class="line">...</span><br><span class="line">labels:</span><br><span class="line">   app: guestbook</span><br><span class="line">   tier: frontend</span><br><span class="line">   version: v4</span><br><span class="line">...</span><br><span class="line">image: gb-frontend:v4</span><br></pre></td></tr></table></figure><p>金丝雀发布通过修改 Deployment 的 replicas 数量和 Pod 镜像地址实现流量切换，而蓝绿发布通过修改 Service 的 labelSelector 实现流量切换。</p><p>原 service 定义如下：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">selector:</span></span><br><span class="line"><span class="hljs-attr">  app:</span> <span class="hljs-string">guestbook</span></span><br><span class="line"><span class="hljs-attr">  tier:</span> <span class="hljs-string">frontend</span></span><br><span class="line"><span class="hljs-attr">  version:</span> <span class="hljs-string">v3</span></span><br></pre></td></tr></table></figure><p>切量时修改为：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">selector:</span></span><br><span class="line"><span class="hljs-attr">  app:</span> <span class="hljs-string">guestbook</span></span><br><span class="line"><span class="hljs-attr">  tier:</span> <span class="hljs-string">frontend</span></span><br><span class="line"><span class="hljs-attr">  version:</span> <span class="hljs-string">v4</span></span><br></pre></td></tr></table></figure><h2 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h2><p>StatefulSet 相对于 Deployment，具有以下特点：</p><ul><li>稳定：唯一的 Pod 名称，唯一的网络ID，持久化存储</li><li>有序：部署和伸缩都按照顺序执行，滚动升级按照顺序执行</li></ul><h3 id="升级机制-1"><a href="#升级机制-1" class="headerlink" title="升级机制"></a>升级机制</h3><ul><li><code>.spec.updateStrategy</code> 定义了升级 StatefulSet 的 Pod 的行为</li><li><code>.spec.updateStrategy.type</code> 为 OnDelete （默认行为）时，用户手动删除 Pod 后，新的 Pod 才会创建；为 RollingUpdate 时，k8s 按照 {N-1 .. 0} 的顺序滚动更新每个 Pod。</li><li><code>.spec.updateStrategy.rollingUpdate.partition</code> 可以实现灰度发布，当 StatefulSet 更新时，所有序号大于或等于 partition 的 Pod 会滚动更新；所有序号小于 partition 的 Pod 不会更新，即使被删掉，也会创建旧版本的 Pod。当 partition 大于 replicas 时，任何 Pod 都不会被更新。</li></ul><p>配置示例如下：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">spec:</span></span><br><span class="line"><span class="hljs-attr">  replicas:</span> <span class="hljs-number">10</span></span><br><span class="line"><span class="hljs-attr">  updateStrategy:</span></span><br><span class="line"><span class="hljs-attr">    type:</span> <span class="hljs-string">RollingUpdate</span></span><br><span class="line"><span class="hljs-attr">    rollingUpdate:</span></span><br><span class="line"><span class="hljs-attr">      partition:</span> <span class="hljs-number">7</span>  <span class="hljs-comment"># 7, 8, 9 will be rolling updated</span></span><br></pre></td></tr></table></figure><p>StatefulSet 也支持 <code>kubectl rollout</code> 命令，使用方法同 Deployment。</p><h3 id="扩缩容机制-1"><a href="#扩缩容机制-1" class="headerlink" title="扩缩容机制"></a>扩缩容机制</h3><p>可以通过 <code>spec.podManagementPolicy</code> 来配置 StatefulSet 的扩缩容策略</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">spec:</span></span><br><span class="line"><span class="hljs-attr">  podManagementPolicy:</span> <span class="hljs-string">OrderdReady</span></span><br></pre></td></tr></table></figure><h4 id="OrderedReady"><a href="#OrderedReady" class="headerlink" title="OrderedReady"></a>OrderedReady</h4><p>默认行为</p><p>扩容时，Pod 按照 {0 .. N-1} 依次创建，并且前一个 Running／Ready 之后，后一个才会创建</p><p>缩容时，Pod 按照 {N-1 .. 0} 依次删除，前一个完全删除之后，后一个才会开始删除</p><h4 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h4><p>扩缩容时忽略顺序，并发创建或删除</p><p>注意，该配置仅仅对扩缩容（修改 replicas）的情况有效，升级 StatefulSet 时 k8s 依然按照次序来更新 Pod。</p><h3 id="唯一网络-ID"><a href="#唯一网络-ID" class="headerlink" title="唯一网络 ID"></a>唯一网络 ID</h3><p>每个 Pod 都有唯一的 hostname，格式为<statefulset-name>-<pod 序号>，domain name 的格式为<headless-svc-name>.<namespace>.svc.cluster.local，通过该 domain name 可以解析到 StatefulSet 下所有的 Pod。通过<statefulset-name>-<pod 序号>.<headless-svc-name>.<namespace>.svc.cluster.local 可以解析到指定 Pod。</namespace></headless-svc-name></pod></statefulset-name></namespace></headless-svc-name></pod></statefulset-name></p><h3 id="稳定存储"><a href="#稳定存储" class="headerlink" title="稳定存储"></a>稳定存储</h3><p>通过配置 StatefulSet 的 <code>volumeClaimTemplates</code>，k8s 会为每个 Pod 创建 PV 和 PVC 并绑定。当 Pod 删除时，对应的 PVC 不会被删除，当重新创建时，仍然会绑定到之前的 PV。</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">volumeClaimTemplates:</span></span><br><span class="line"><span class="hljs-attr">- metadata:</span></span><br><span class="line"><span class="hljs-attr">    name:</span> <span class="hljs-string">www</span></span><br><span class="line"><span class="hljs-attr">  spec:</span></span><br><span class="line"><span class="hljs-attr">    accessModes:</span> <span class="hljs-string">[</span> <span class="hljs-string">"ReadWriteOnce"</span> <span class="hljs-string">]</span></span><br><span class="line"><span class="hljs-attr">    storageClassName:</span> <span class="hljs-string">"my-storage-class"</span></span><br><span class="line"><span class="hljs-attr">    resources:</span></span><br><span class="line"><span class="hljs-attr">      requests:</span></span><br><span class="line"><span class="hljs-attr">        storage:</span> <span class="hljs-number">1</span><span class="hljs-string">Gi</span></span><br></pre></td></tr></table></figure><h3 id="发布最佳实践-1"><a href="#发布最佳实践-1" class="headerlink" title="发布最佳实践"></a>发布最佳实践</h3><h4 id="滚动发布-1"><a href="#滚动发布-1" class="headerlink" title="滚动发布"></a>滚动发布</h4><p>滚动发布需要配置 <code>.spec.updateStrategy.type</code> 为 <code>RollingUpdate</code>，StatefulSet 的默认行为是按照 {N-1 .. 0} 的顺序依次更新。</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">spec:</span></span><br><span class="line"><span class="hljs-attr">  updateStrategy:</span></span><br><span class="line"><span class="hljs-attr">    type:</span> <span class="hljs-string">RollingUpdate</span></span><br></pre></td></tr></table></figure><h4 id="蓝绿发布-1"><a href="#蓝绿发布-1" class="headerlink" title="蓝绿发布"></a>蓝绿发布</h4><p>蓝绿发布与 Deployment 的方式相同，通过创建 2 个 StatefulSet，修改 Service 的方式实现切量。</p><h4 id="灰度／金丝雀发布-1"><a href="#灰度／金丝雀发布-1" class="headerlink" title="灰度／金丝雀发布"></a>灰度／金丝雀发布</h4><p>金丝雀发布通过修改 StatefulSet 的 <code>.spec.updateStrategy.rollingUpdate.partition</code> 的值来实现发布。</p><p>例如 replicas 为 10 时，Pod 的序号为 0 - 9，首先将 partition 设置为 7，再修改 StatefulSet 的 Pod template 配置，会依次触发 Pod 9, 8, 7 的滚动更新，Pod 0-6 依然维持老版本，此时老版本与旧版本的比例为 7:3。线上验证无误后，再将 partition 设置为 0，依次触发 Pod 6 - 0 的滚动更新，此时全部更新至新版本。</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">spec:</span></span><br><span class="line"><span class="hljs-attr">  replicas:</span> <span class="hljs-number">10</span></span><br><span class="line"><span class="hljs-attr">  updateStrategy:</span></span><br><span class="line"><span class="hljs-attr">    type:</span> <span class="hljs-string">RollingUpdate</span></span><br><span class="line"><span class="hljs-attr">    rollingUpdate:</span></span><br><span class="line"><span class="hljs-attr">      partition:</span> <span class="hljs-number">7</span>  <span class="hljs-comment"># 7, 8, 9 will be rolling updated</span></span><br></pre></td></tr></table></figure><h2 id="Replication-Controller-（官方已不推荐使用）"><a href="#Replication-Controller-（官方已不推荐使用）" class="headerlink" title="Replication Controller （官方已不推荐使用）"></a>Replication Controller （官方已不推荐使用）</h2><p>kubectl rolling-update 只适用于 Replication Controllers，已经被 Deployment 取代，在此不过多介绍。</p><p><a href="https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Deployment：<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/workloads/controllers/deployment/</a></li><li>Deployment Rolling Update：<a href="https://tachingchen.com/blog/kubernetes-rolling-update-with-deployment/" target="_blank" rel="noopener">https://tachingchen.com/blog/kubernetes-rolling-update-with-deployment/</a></li><li>金丝雀部署：<a href="https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments</a></li><li>微服务部署：蓝绿部署、滚动部署、灰度发布、金丝雀发布：<a href="https://www.jianshu.com/p/022685baba7d" target="_blank" rel="noopener">https://www.jianshu.com/p/022685baba7d</a></li><li>StatefulSet：<a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了 Deployment 和 StatefulSet 的升级机制和扩缩容机制，以及一些常用的配置项。并分别介绍了以这两种方式部署 Pod 时的对服务进行升级（包括滚动发布、蓝绿发布、灰度／金丝雀发布）的最佳实践。&lt;/p&gt;&lt;h2 id=&quot;Deployment&quot;&gt;&lt;a href=&quot;#Deployment&quot; class=&quot;headerlink&quot; title=&quot;Deployment&quot;&gt;&lt;/a&gt;Deployment&lt;/h2&gt;&lt;h3 id=&quot;升级机制&quot;&gt;&lt;a href=&quot;#升级机制&quot; class=&quot;headerlink&quot; title=&quot;升级机制&quot;&gt;&lt;/a&gt;升级机制&lt;/h3&gt;&lt;h4 id=&quot;Rollout&quot;&gt;&lt;a href=&quot;#Rollout&quot; class=&quot;headerlink&quot; title=&quot;Rollout&quot;&gt;&lt;/a&gt;Rollout&lt;/h4&gt;&lt;p&gt;Deployment 的 rollout 在 .spec.template 被修改时触发（比如镜像地址更新、Pod label 更新等等），其他修改（.spec.replicas 更新）不会触发。&lt;/p&gt;&lt;p&gt;更新时，k8s 通过计算 pod-template-hash，创建新的 ReplicaSet，由新的 rs 启动新的 Pod，不断替换旧 rs 的 Pod。&lt;/p&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="Kubernetes" scheme="http://whypro.github.io/hexo-blog/tags/Kubernetes/"/>
    
      <category term="K8S" scheme="http://whypro.github.io/hexo-blog/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>从头编写一款时间序列数据库</title>
    <link href="http://whypro.github.io/hexo-blog/20180110/%E4%BB%8E%E5%A4%B4%E7%BC%96%E5%86%99%E4%B8%80%E6%AC%BE%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://whypro.github.io/hexo-blog/20180110/从头编写一款时间序列数据库/</id>
    <published>2018-01-10T14:01:52.000Z</published>
    <updated>2019-06-02T09:10:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转自 <a href="http://dockone.io/article/2300" target="_blank" rel="noopener">从头编写一款时间序列数据库</a> （翻译：Colstuwjx），请支持原作者。</p></blockquote><p>我从事监控方面的工作。尤其是专注在 <a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus</a>，一款内置了自己定制的时间序列数据库的监控系统，以及它和 <a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a> 的集成工作。</p><p>从很多方面来说，Kubernetes 表现出了一切 Prometheus 专门设计的东西。它使得持续部署，自动扩缩，以及高度动态环境的其他功能更易于实现。它的查询语言和操作模型，还有许多其他概念方面的决策使得 Prometheus 尤其适合这样的环境。然而，如果被监控的工作负载变得更加显著动态的话，这也会给监控系统本身带来新的压力。基于这一点的考虑，与其再次回顾 Prometheus 已经很好解决的问题，还不如专注于在这样一个高度动态或短生命周期服务的环境里提高它的性能。</p><p>Prometheus 的存储层在历史上有着惊人的性能表现，一个单台服务器每秒可以摄取多达 100 万个采样，数百万个时间序列，同时仅占用令人惊叹的少量磁盘空间。尽管当前的存储已经给我们提供了不错的服务，笔者构思了一个新设计的存储子系统用来纠正现有解决方案的一些短板，并且可以用来配备支撑下一代的集群规模。</p><a id="more"></a><blockquote><p>注意：笔者并没有数据库方面的背景。我在这里所说的话可能是错误的或是带有误导性的。你可以在 Freenode 上的 #prometheus 频道里将你的批评指正反馈到我（fabxc）。</p></blockquote><h2 id="问题，难题，问题域"><a href="#问题，难题，问题域" class="headerlink" title="问题，难题，问题域"></a>问题，难题，问题域</h2><p>首先，快速概括一下我们试图完成的任务以及这里面暴露出的关键问题。针对每一点，我们会先看一看 Prometheus 目前的做法，它在哪些地方做的出色，以及我们旨在通过新的设计想解决哪些问题。</p><h3 id="时间序列数据"><a href="#时间序列数据" class="headerlink" title="时间序列数据"></a>时间序列数据</h3><p>我们有一个根据时间采集数据点的系统。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">identifier -&gt; (t0, v0), (t1, v1), (t2, v2), (t3, v3), ....</span><br></pre></td></tr></table></figure><p>每个数据点都是一个由时间戳和值组成的元组。为了达成监控的目的，时间戳是一个整数，值则可以是任意数字。经验来看，一个64位的浮点数往往能够很好地展现计数器（counter）和测量（gauge）的值，因此我们也不例外。一个时间序列是一组时间上严格单调递增的数据点序列，它可以通过一个标识符来寻址。我们的标识符便是一个度量（metric）名带上一个多维标签的字典。多维标签会将单个度量的测量空间分区。每个度量名加上一串唯一的标签便组成了它自己的时间序列（time series），它会有一个与之关联的值序列流。下面是一组典型的序列标识符，它是度量请求计数的一部分：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">requests_total&#123;path=&quot;/status&quot;, method=&quot;GET&quot;, instance=&quot;10.0.0.1:80&quot;&#125;</span><br><span class="line">requests_total&#123;path=&quot;/status&quot;, method=&quot;POST&quot;, instance=&quot;10.0.0.3:80&quot;&#125;</span><br><span class="line">requests_total&#123;path=&quot;/&quot;, method=&quot;GET&quot;, instance=&quot;10.0.0.2:80&quot;&#125;</span><br></pre></td></tr></table></figure><p>让我们快速简化一下这个表达形式：我们不妨将一个度量名视为另一种标签维度 - 在我们的场景里便是 <code>__name__</code>。在查询级别上，它可能会被特殊对待，但是它并不会关注我们采用何种方式来存放它，这一点我们将在后面看到。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;__name__=&quot;requests_total&quot;, path=&quot;/status&quot;, method=&quot;GET&quot;, instance=&quot;10.0.0.1:80&quot;&#125;</span><br><span class="line">&#123;__name__=&quot;requests_total&quot;, path=&quot;/status&quot;, method=&quot;POST&quot;, instance=&quot;10.0.0.3:80&quot;&#125;</span><br><span class="line">&#123;__name__=&quot;requests_total&quot;, path=&quot;/&quot;, method=&quot;GET&quot;, instance=&quot;10.0.0.2:80&quot;&#125;</span><br></pre></td></tr></table></figure><p>当查询时间序列数据时，我们想通过指定标签来选择。最简单的例子莫过于 <code>{__name__=&quot;requests_total&quot;}</code> 会选出所有属于 <code>requests_total</code> 度量的序列。针对所有被选中的序列来说，我们会在一个指定的时间窗口里检索出对应的数据点。</p><p>而在更复杂的查询里，我们可能希望同时选择满足多个标签选择器的序列，并且就表达形式来说也会存在比等于更复杂的条件。比如，取反（<code>method!=&quot;GET&quot;</code>）或者正则表达式匹配（<code>method=~&quot;PUT|POST&quot;</code>）。</p><p>这大体上决定了所需存储的数据以及它们该如何被调用。</p><h3 id="横轴和纵轴"><a href="#横轴和纵轴" class="headerlink" title="横轴和纵轴"></a>横轴和纵轴</h3><p>在一个简化的视图中，所有数据点都可以在一个二维平面上分布。横轴代表时间，而序列标识符的空间遍及整个纵轴。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">series</span><br><span class="line">  ^   </span><br><span class="line">  │   . . . . . . . . . . . . . . . . .   . . . . .   &#123;__name__=&quot;request_total&quot;, method=&quot;GET&quot;&#125;</span><br><span class="line">  │     . . . . . . . . . . . . . . . . . . . . . .   &#123;__name__=&quot;request_total&quot;, method=&quot;POST&quot;&#125;</span><br><span class="line">  │         . . . . . . .</span><br><span class="line">  │       . . .     . . . . . . . . . . . . . . . .                  ... </span><br><span class="line">  │     . . . . . . . . . . . . . . . . .   . . . .   </span><br><span class="line">  │     . . . . . . . . . .   . . . . . . . . . . .   &#123;__name__=&quot;errors_total&quot;, method=&quot;POST&quot;&#125;</span><br><span class="line">  │           . . .   . . . . . . . . .   . . . . .   &#123;__name__=&quot;errors_total&quot;, method=&quot;GET&quot;&#125;</span><br><span class="line">  │         . . . . . . . . .       . . . . .</span><br><span class="line">  │       . . .     . . . . . . . . . . . . . . . .                  ... </span><br><span class="line">  │     . . . . . . . . . . . . . . . .   . . . . </span><br><span class="line">  v</span><br><span class="line">    &lt;-------------------- time ---------------------&gt;</span><br></pre></td></tr></table></figure><p>Prometheus 通过定期抓取一组时间序列的当前值来检索得到数据点。这样一个我们检索批次的实体被称作一个目标（target）。由于每个目标的样本数据都是单独抓取的，因此写入模式是完全垂直并且高度并发的。这里提供一些衡量尺度：一个单个的Prometheus实例会从成千上万的目标采集数据点，每个目标可以暴露出数百上千个不同的时间序列。</p><p>就每秒采集数百万个数据点的规模而言，批量写入是一个不可调和的性能需求。分散地写入单个数据点到磁盘的话又会是一个非常缓慢的过程。因此，我们想要实现的是按顺序写入更大的数据块。对于机械的旋转磁盘而言这样做并不出奇，因为它们的头会一直物理地移动到不同的区块。虽然 SSD 以快速地随机写入性能而闻名，但是实际上它们却不能修改单个字节，而只能写入 4KiB 或更大的的页。这意味着写一个 16 字节的样本同写一个完整的 4KiB 页没什么两样。这种行为即是所谓的<a href="https://en.wikipedia.org/wiki/Write_amplification" target="_blank" rel="noopener">写入放大</a>的一部分，作为一个“额外红利”，它会耗损你的 SSD —— 因此它不仅仅只是会变慢而已，还会在几天或者几周内完全毁掉你的硬件。关于这个问题的更详细信息，系列博客”<a href="http://codecapsule.com/2014/02/12/coding-for-ssds-part-1-introduction-and-table-of-contents/" target="_blank" rel="noopener">针对 SSD 编程</a>“系列会是一个不错的资源。我们不妨考虑一下这里面的主要关键点：顺序和批量写入是旋转磁盘和 SSD 的理想写入模式。 这是一个应该遵循的简单规则。</p><p>时间序列数据库的查询模型跟写模型相比，更是有明显不同的区别。我们可以对一个单个序列查询一个单个的数据点，在 10000 个序列里查询一个单个的数据点，在一个单个序列里查询几周的数据点，甚至在 10000 个序列里查询几周的数据点，等等。因此在我们的二维平面上，查询既不是完全垂直的，也不是水平的，而是二者的矩形组合。<a href="https://prometheus.io/docs/practices/rules/" target="_blank" rel="noopener">记录规则</a>可以减轻已知的一些查询方面的问题，但是仍然不是临时查询（ad-hoc queries）的一个通用解决方案，这些查询也必须能很好的进行下去。</p><p>须知我们想要的是批量写入，但是我们得到的批次只是序列之间一个纵向的数据点集合。当在一个时间窗口上针对某个序列查询数据点时，不仅难以确定各个数据点可以被找到的位置，我们还不得不从磁盘上大量的随机位置进行读取。每次查询操作可能涉及到数以百万的样例数据，即使在最快的 SSD 上这样的操作也会变慢。读操作还将从磁盘上检索更多的数据，而不仅仅只是所请求的 16 字节大小的样本。 SSD 将加载一整页，HDD 将至少读取整个扇区。 无论哪种方式，我们都会浪费宝贵的读吞吐量。</p><p>因此，在理想情况下，相同序列的样本数据将会被顺序存储，这样一来我们便可以用尽可能少的读来扫描得到它们。 在上层，我们只需要知道这个序列可以访问的所有数据点的开始位置。</p><p>在将收集的数据写入磁盘的理想模式和为服务的查询操作提供更显著有效的存储格式之间显然存在着强烈的冲突。这是我们的时间序列数据库要解决的根本问题。</p><h4 id="当前的解决方案"><a href="#当前的解决方案" class="headerlink" title="当前的解决方案"></a>当前的解决方案</h4><p>是时候来看看 Prometheus 当前的存储是如何实现的，我们不妨叫它“V2”，它致力于解决这个问题。我们会为每个时间序列创建一个文件，它会按照时间顺序包含所有的样本数据。由于每隔几秒就把单个的样本数据添加到所有这些文件的成本不小，我们针对每个序列在内存里批量存放了 1KiB 的数据块，一旦它们填满了再把这些块添加到一个个的文件里。这一方案解决了很大一部分问题。写操作如今是分批次的，样本数据也是顺序存储的。它还能为我们提供一个令人难以置信的高效压缩格式，这是基于一个给定的样本相对于相同序列里前面的那些样本数据只有非常少量的变化这一属性而设计。Facebook 在它们的 Gorilla TSDB 的论文里描述了一种类似的基于块（Chunk）的存储方法，并且引入了一个压缩格式，将16个字节的样本减少到平均 1.37 字节。V2 存储使用了各种压缩格式，包括 Gorilla 的一个变种。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  ┌──────────┬─────────┬─────────┬─────────┬─────────┐           series A</span><br><span class="line">  └──────────┴─────────┴─────────┴─────────┴─────────┘</span><br><span class="line">         ┌──────────┬─────────┬─────────┬─────────┬─────────┐    series B</span><br><span class="line">         └──────────┴─────────┴─────────┴─────────┴─────────┘ </span><br><span class="line">                             . . .</span><br><span class="line">┌──────────┬─────────┬─────────┬─────────┬─────────┬─────────┐   series XYZ</span><br><span class="line">└──────────┴─────────┴─────────┴─────────┴─────────┴─────────┘ </span><br><span class="line">  chunk 1    chunk 2   chunk 3     ...</span><br></pre></td></tr></table></figure><p>尽管基于块的实现方案很棒，如何为每个序列维护一个单独的文件却也是V2存储引擎困扰的地方，这里面有几个原因：</p><ul><li><p>我们实际上需要维护的文件数量多于我们正在收集数据的时间序列数量。在“序列分流”一节会详解介绍到这点。由于产生了几百万个文件，不久的将来或者迟早有一天，我们的文件系统会出现 <a href="https://en.wikipedia.org/wiki/Inode" target="_blank" rel="noopener">inodes</a> 耗尽的情况。在这种情况下我们只能通过重新格式化磁盘来恢复，这样做可能带有侵入性和破坏性。通常我们都希望避免格式化磁盘，特别是需要适配某个单个应用时更是如此。</p></li><li><p>即便做了分块，每秒也会产生数以千计的数据块并且准备好被持久化。这仍然需要每秒完成几千次单独的磁盘写操作。尽管这一点可以通过为每个序列填满的数据块做分批处理来缓解压力，这反过来又会增加等待被持久化的数据总的内存占用。</p></li><li><p>保持打开所有文件来读取和写入是不可行的。特别是因为在24小时后超过99%的数据便不再会被查询。如果它还是被查询到的话，我们就不得不打开数千个文件，查找和读取相关的数据点到内存，然后再重新关闭它们。而这样做会导致很高的查询延迟，数据块被相对积极地缓存的话又会导致一些问题，这一点会在“耗用资源”一节里进一步概述。</p></li><li><p>最终，旧数据必须得被清理掉，而且数据需要从数百万的文件前面被抹除。这意味着删除实际上是写密集型操作。此外，循环地在这数百万的文件里穿梭然后分析它们会让这个过程常常耗费数个小时。在完成时有可能还需要重新开始。呵呵，删除旧文件将会给你的SSD带来进一步的写入放大！</p></li><li><p>当前堆积的数据块只能放在内存里。如果应用崩溃的话，数据将会丢失。为了避免这种情况，它会定期地保存内存状态的检查点（Checkpoint）到磁盘，这可能比我们愿意接受的数据丢失窗口要长得多。从检查点恢复估计也会花上几分钟，造成痛苦而漫长的重启周期。</p></li></ul><p>从现有的设计中脱颖而出的关键在于块的概念，我们当然希望保留这一设计。大多数最近的块被保留在内存里一般来说也是一个不错的做法。毕竟，最大幅度被查询数据里大部分便是这些最近的点。</p><p>一个时间序列对应一个文件这一概念是我们想要替换的。</p><h3 id="序列分流-Series-Churn"><a href="#序列分流-Series-Churn" class="headerlink" title="序列分流 (Series Churn)"></a>序列分流 (Series Churn)</h3><p>在 Prometheus 的上下文里，我们使用术语“序列分流”来描述一组时间序列变得不活跃，即不再接收数据点，取而代之的是有一组新的活跃的序列出现。</p><p>举个例子，由一个给定的微服务实例产出的所有序列各自都有一个标识它起源的“instance”标签。如果我们对该微服务完成了一次滚动更新然后将每个实例切换到了一个更新的版本的话，序列分流就产生了。在一个更加动态的环境里，这些事件可能会以小时的频率出现。像Kubernetes这样的集群编排系统允许应用程序不断地自动伸缩和频繁的滚动更新，它可能会创建出数万个新的应用程序实例，并且每天都会使用全新的时间序列。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">series</span><br><span class="line">  ^</span><br><span class="line">  │   . . . . . .</span><br><span class="line">  │   . . . . . .</span><br><span class="line">  │   . . . . . .</span><br><span class="line">  │               . . . . . . .</span><br><span class="line">  │               . . . . . . .</span><br><span class="line">  │               . . . . . . .</span><br><span class="line">  │                             . . . . . .</span><br><span class="line">  │                             . . . . . .</span><br><span class="line">  │                                         . . . . .</span><br><span class="line">  │                                         . . . . .</span><br><span class="line">  │                                         . . . . .</span><br><span class="line">  v</span><br><span class="line">    &lt;-------------------- time ---------------------&gt;</span><br></pre></td></tr></table></figure><p>因此，即便整个基础设施大体上保持不变，随着时间的推移，我们数据库里的时间序列数据量也会呈线性增长。 尽管 Prometheus 服务器很愿意去采集 1000 万个时间序列的数据，但是如果不得不在十亿个序列中查找数据的话，很明显查询性能会受到影响。</p><h4 id="当前解决方案"><a href="#当前解决方案" class="headerlink" title="当前解决方案"></a>当前解决方案</h4><p>Prometheus当前 V2 版本的存储针对当前被存放的所有序列都有一个基于 LevelDB 的索引。它允许包含一个指定的标签对来查询序列，但是缺乏一个可扩展的方式以组合来自不同标签选择的结果。举个例子，用户可以有效地选出带有标签 <code>__name __ =&quot;requests_total&quot;</code> 的所有序列，但是选择所有满足 <code>instance=&quot;A&quot;</code> AND <code>__name __ =&quot;requests_total&quot;</code> 的序列则都有可扩展性的问题。我们稍后会重新审视为什么会造成这样的结果，要改善查询延迟的话要做哪些必要的调整。</p><p>实际上这一问题正是触发要实现一个更好的存储系统的最初动力。Prometheus 需要一个改进的索引方法从数亿个时间序列里进行快速搜索。</p><h3 id="耗用资源"><a href="#耗用资源" class="headerlink" title="耗用资源"></a>耗用资源</h3><p>耗用资源是试图扩展 Prometheus（或者任何东西，真的）时不变的话题之一。但是实际上烦恼用户的问题并不是绝对的资源匮乏。实际上，由于给定需求的驱动，Prometheus 管理着令人难以置信的吞吐量。问题更在于是面对变化的相对未知性和不稳定性。由于V2存储本身的架构设计，它会缓慢地构建出大量的样本数据块，而这会导致内存消耗随着时间的推移不断增加。随着数据块被填满，它们会被写入到磁盘，随即便能够从内存中被清理出去。最终，Prometheus 的内存使用量会达到一个稳定的状态。直到受监控的环境发生变化 - 每次我们扩展应用程序或进行滚动更新时，序列分流 会造成内存，CPU 和磁盘 IO 占用方面的增长。</p><p>如果变更是正在进行的话，那么最终它将再次达到一个稳定的状态，但是比起一个更加静态的环境而言，它所消耗的资源将会显著提高。过渡期的时长一般长达几个小时，而且很难说最大资源使用量会是多少。</p><p>每个时间序列对应一个单个文件的方式使得单个查询很容易就击垮 Prometheus 的进程。而当所要查询的数据没有缓存到内存时，被查询序列的文件会被打开，然后包含相关数据点的数据块会被读取到内存里。倘若数据量超过了可用内存，Prometheus 会因为 OOM 被杀死而退出。待查询完成后，加载的数据可以再次释放，但通常会缓存更长时间，以便在相同数据上更快地提供后续查询。后者显然是一件好事。</p><p>最后，我们看下 SSD 上下文里的写入放大，以及 Prometheus 是如何通过批量写入来解决这个问题。然而，这里仍然有几处会造成写入放大，因为存在太多小的批次而且没有精确地对准页面边界。针对更大规模的 Prometheus 服务器，现实世界已经有发现硬件寿命缩短的情况。可能对于具有高写入吞吐量的数据库应用程序来说，这仍属正常，但是我们应该关注是否可以缓解这一情况。</p><h2 id="从头开始"><a href="#从头开始" class="headerlink" title="从头开始"></a>从头开始</h2><p>如今，我们对我们的问题域有了一个清晰的了解，V2 存储是如何解决它的，以及它在设计上存在哪些问题。我们也看到一些很棒的概念设计，这些也是我们想要或多或少无缝适配的。相当数量的 V2 版本存在的问题均可以通过一些改进和部分的重新设计来解决，但为了让事情变得更好玩些（当然，我这个决定是经过深思熟虑的），我决定从头开始编写一款全新的时间序列数据库 —— 从零开始，即，将字节数据写到文件系统。</p><p>性能和资源使用这样的关键问题会直接引领我们做出存储格式方面的选择。我们必须为我们的数据找到一个正确的算法和磁盘布局以实现一个性能优良的存储层。</p><p>这便是我直接迈向成功时走的捷径 —— 忽略之前经历过的头疼，无数失败的想法，数不尽的草图，眼泪，还有绝望。</p><h3 id="V3-宏观设计"><a href="#V3-宏观设计" class="headerlink" title="V3 - 宏观设计"></a>V3 - 宏观设计</h3><p>我们新版存储引擎的宏观设计是怎样的？简略来讲，只要到我们的 data 目录下运行 <code>tree</code> 命令，一切便都一目了然。不妨看下这幅美妙的画面它能带给我们怎样的一个惊喜。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ tree ./data</span><br><span class="line">./data</span><br><span class="line">├── b-000001</span><br><span class="line">│   ├── chunks</span><br><span class="line">│   │   ├── 000001</span><br><span class="line">│   │   ├── 000002</span><br><span class="line">│   │   └── 000003</span><br><span class="line">│   ├── index</span><br><span class="line">│   └── meta.json</span><br><span class="line">├── b-000004</span><br><span class="line">│   ├── chunks</span><br><span class="line">│   │   └── 000001</span><br><span class="line">│   ├── index</span><br><span class="line">│   └── meta.json</span><br><span class="line">├── b-000005</span><br><span class="line">│   ├── chunks</span><br><span class="line">│   │   └── 000001</span><br><span class="line">│   ├── index</span><br><span class="line">│   └── meta.json</span><br><span class="line">└── b-000006</span><br><span class="line">    ├── meta.json</span><br><span class="line">    └── wal</span><br><span class="line">        ├── 000001</span><br><span class="line">        ├── 000002</span><br><span class="line">        └── 000003</span><br></pre></td></tr></table></figure><p>在最上面一层，我们有一组带编号的块，它们均有一个前缀 <code>b-</code>。 每个块显然都维护一个包含索引的文件以及一个包含更多编号文件的”chunk”目录。”chunks”目录没别的，就多个序列的一些数据点的原始块。跟V2的做法一样，这样可以用非常低的成本来读取一个时间窗口里的序列数据，并且允许我们采用相同的有效压缩算法。这个概念已经被证实是行之有效的，我们自然就沿用这一点。很显然，这里不再是每个序列对应一个单个文件，取而代之的是，几个文件包含许多序列的数据块。</p><p>“index”文件的存在是预料之中的事情。我们不妨假定它包含了大量的黑魔法，允许我们找出标签，它们可能的值，整个时间序列，以及存放数据点的数据块。</p><p>但是，为什么有几个目录是一个索引和一些块文件这样的布局？为什么最后一个目录里取而代之的是有一个“wal”目录？搞清楚这两个问题的话可以解决我们90％的问题。</p><h4 id="众多的小型数据库"><a href="#众多的小型数据库" class="headerlink" title="众多的小型数据库"></a>众多的小型数据库</h4><p>我们将我们的水平维度，即时间空间分割成非重叠的块。 每个块当成一个完全独立的数据库，包含其时间窗口的所有时间序列数据。因此，它有自己的索引和一组块文件。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t0            t1             t2             t3             now</span><br><span class="line"> ┌───────────┐  ┌───────────┐  ┌───────────┐  ┌───────────┐</span><br><span class="line"> │           │  │           │  │           │  │           │                 ┌────────────┐</span><br><span class="line"> │           │  │           │  │           │  │  mutable  │ &lt;─── write ──── ┤ Prometheus │</span><br><span class="line"> │           │  │           │  │           │  │           │                 └────────────┘</span><br><span class="line"> └───────────┘  └───────────┘  └───────────┘  └───────────┘                        ^</span><br><span class="line">       └──────────────┴───────┬──────┴──────────────┘                              │</span><br><span class="line">                              │                                                  query</span><br><span class="line">                              │                                                    │</span><br><span class="line">                            merge ─────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p>每个块的数据均是无法更改的。当然，在我们采集到新数据时我们必须能够将新序列和样本数据添加到最近的数据块里。对于这个数据块，所有新数据都将写入到内存数据库里，跟我们持久化的数据块一样，它也会提供相同的查找属性。内存里的数据结构也可以被有效地更新。为了防止数据丢失，所有传入的数据还会被写入预写日志（write ahead log），即我们的“wal”目录中的一组文件，我们可以在重新启动时基于这些文件将之前内存里的数据重新填充到内存数据库。</p><p>所有这些文件都带有自己的序列化格式，它附带了许多标志，偏移量，变体和 CRC32 校验和。比起无聊地读着介绍，读者朋友自己去发现它们也许会更有乐趣些。</p><p>这种布局允许我们查出所有和被查询的时间范围相关的数据块。每个块的部分结果被合并到一起形成最终的完整结果。</p><p>这种水平分区解锁了一些很棒的功能：</p><ul><li><p>当查询一个时间范围时，我们可以轻松地忽略该范围外的所有数据块。 通过减少一系列开始时需要检查的数据，它可以初步解决序列分流的问题。</p></li><li><p>当完成一个数据块的填充时，我们可以通过顺序写入数据到一些较大的文件来保存内存数据库中的数据。 这样就避免了任何写入放大的问题，并且同样适用于SSD和HDD。</p></li><li><p>我们继承了 V2 优秀的地方，最近最多被查询的数据块总是作为热点保存在内存里。</p></li><li><p>棒棒哒，我们再也不需要通过固定的1KiB块大小设定来更好地对齐磁盘上的数据。 我们可以选择任何对于个别数据点和选定的压缩格式最有意义的大小。</p></li><li><p>删除旧数据变得非常低成本和及时。我们只需要删除一个目录。 请记住，在旧存储中，我们不得不分析并重新编写高达数亿个文件，这一操作可能需要几个小时才能收敛。</p></li></ul><p>每个块还包含一个 <code>meta.json</code> 文件。 它简单地保存该数据块的人类可读信息，便于用户轻松了解数据块的存储状态及其包含的数据。</p><h5 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h5><p>从数以百万的小文件改成几个更大的文件使得我们能够以很小的成本保持所有文件的打开句柄。这也解锁了使用 <a href="https://en.wikipedia.org/wiki/Mmap" target="_blank" rel="noopener">mmap(2)</a> 的玩法，它是一个系统调用，允许我们通过文件内容透明地回传到一个虚拟内存区域。为了简单起见，你可以联想它类似于交换(swap)空间，只是我们所有的数据已经在磁盘上，并且在将数据交换出内存后不会发生写入。这意味着我们可以将数据库里的所有内容均视为内存而不占用任何物理RAM。只有我们访问我们的数据库文件中的某些字节范围时，操作系统才会从磁盘惰性地加载页面。这就把和我们持久化数据相关的所有内存管理都交给了操作系统负责。 一般来说，操作系统更有资格做出这样的决定，因为它对整个机器及其所有过程有更全面的看法。查询数据可以相当积极地被缓存在内存里，而一旦面临内存压力，页面便会被逐出(evicted)。如果机器有未使用的内存，Prometheus 将会很高兴去缓存整个数据库，而一旦另一个应用程序需要它，它将立即返回。</p><p>这样一来，比起受到 RAM 的大小限制，即便查询更多的持久化数据，查询操作也不会再轻易造成进程的 OOM。内存的缓存大小变得完全自适应，只有在查询实际需要的数据时才会加载数据。</p><p>就我个人的理解，这是今天的很多数据库的工作方式，如果磁盘格式允许的话，这是一个理想的方法 - 除非你有信心在进程里做的工作能够超越操作系统。我们自己做了很少一部分工作而确实从外部系统收获了大量功能。</p><h4 id="压缩-compaction"><a href="#压缩-compaction" class="headerlink" title="压缩 (compaction)"></a>压缩 (compaction)</h4><p>存储引擎必须定期地“切出”一个新的块，并将之前完成的块写入到磁盘。只有块被成功持久化后，用于恢复内存块的预写日志文件（wal）才会被删除。</p><p>我们有兴趣将每个块的保存时间设置的相对短一些（一般设置大约两个小时），以避免在内存中堆积太多的数据。当查询多个块时，我们必须将其结果合并为一个完整结果。 这个合并过程显然会有一个成本，一个一周长的查询不应该需要合并超过80个的部分结果。</p><p>为了实现两者共同的需求，我们引入数据压缩（compaction）。它描述了采集一个或多个数据块并将其写入一个可能会更大的块的过程。它还可以沿途修改现有的数据，例如，清理已删除的数据，或重组我们的样本数据块以提高查询性能。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t0             t1            t2             t3             t4             now</span><br><span class="line"> ┌────────────┐  ┌──────────┐  ┌───────────┐  ┌───────────┐  ┌───────────┐</span><br><span class="line"> │ 1          │  │ 2        │  │ 3         │  │ 4         │  │ 5 mutable │    before</span><br><span class="line"> └────────────┘  └──────────┘  └───────────┘  └───────────┘  └───────────┘</span><br><span class="line"> ┌─────────────────────────────────────────┐  ┌───────────┐  ┌───────────┐</span><br><span class="line"> │ 1              compacted                │  │ 4         │  │ 5 mutable │    after (option A)</span><br><span class="line"> └─────────────────────────────────────────┘  └───────────┘  └───────────┘</span><br><span class="line"> ┌──────────────────────────┐  ┌──────────────────────────┐  ┌───────────┐</span><br><span class="line"> │ 1       compacted        │  │ 3      compacted         │  │ 5 mutable │    after (option B)</span><br><span class="line"> └──────────────────────────┘  └──────────────────────────┘  └───────────┘</span><br></pre></td></tr></table></figure><p>在这个例子里，我们有一组顺序的块 <code>[1, 2, 3, 4]</code>。数据块 1, 2 和 3 可以被一起压缩，然后形成的新结构便是 <code>[1, 4]</code>。或者，将它们成对地压缩成 <code>[1，3]</code>。 所有的时间序列数据仍然存在，但是现在总体的数据块更少。 这显著降低了查询时的合并成本，因为现在需要被合并的部分查询结果会更少。</p><h4 id="保留-Retention"><a href="#保留-Retention" class="headerlink" title="保留 (Retention)"></a>保留 (Retention)</h4><p>我们看到，删除旧数据在 V2 存储引擎里是一个缓慢的过程，而且会消耗 CPU，内存和磁盘。那么，我们该如何在基于块的设计中删除旧数据呢？简单来讲，只需删除该目录下在我们配置的保留窗口里没有数据的块。 在下面的示例中，块1可以安全地被删除，而2必须保留到完全落在边界之后才行。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                     |</span><br><span class="line">┌────────────┐  ┌────┼─────┐  ┌───────────┐  ┌───────────┐  ┌───────────┐</span><br><span class="line">│ 1          │  │ 2  |     │  │ 3         │  │ 4         │  │ 5         │   . . .</span><br><span class="line">└────────────┘  └────┼─────┘  └───────────┘  └───────────┘  └───────────┘</span><br><span class="line">                     |</span><br><span class="line">                     |</span><br><span class="line">            retention boundary</span><br></pre></td></tr></table></figure><p>获取越旧的数据，数据块可能就变得越大，这是因为我们会不断地压缩以前压缩的块。 因此必须得有一个压缩的上限，这样一来块就不会扩展到跨越整个数据库从而影响到我们设计的最初优势。</p><p>另一个方便之处在于，这样也可以限制部分在保留窗口里部分在外面的数据块的总磁盘开销，即上面示例中的块 2.当用户将最大块的大小设置为总保留窗口的 10% 时，保留块 2 的总开销也有 10% 的上限。</p><p>总而言之，保留删除的实现从非常高的成本变成了几乎零成本。</p><blockquote><p>如果看到这里，而且读者朋友本人有一些数据库的背景的话，你可能会问一件事：这是一个新玩法吗？ —— 其实不是；而且大概还可以做得更好。</p><p>在内存里批量处理数据，在预写日志（wal）里跟踪，并定期刷新到磁盘，这种模式在今天是被广泛采纳的。</p><p>无论数据特指的问题域是什么，我们所看到的好处几乎都是普遍适用的。 遵循这一方法的突出开源案例是 LevelDB，Cassandra，InfluxDB 或 HBase。而这里面的关键是要避免重复发明劣质轮子，研究经过生产验证的方法，并采取正确的姿势应用它们。</p><p>这里仍然留有余地可以添加用户自己的黑科技。</p></blockquote><h3 id="索引-index"><a href="#索引-index" class="headerlink" title="索引 (index)"></a>索引 (index)</h3><p>调研存储的改进方案的源动力便是为了解决序列分流引发的问题。基于块的布局设计减少了为查询提供服务所涉及的时间序列的总数。因此，假设我们索引查找的时间复杂度是 O（n ^ 2），我们设法减少n个相等的数量，那么现在就有一个改进的复杂度 O（n ^ 2） - uhm，等一下… 哇靠。</p><p>这时候脑海里迅速回忆起“算法101”提醒我们的事情，理论上讲，这并没有给我们带来任何改善。 如果以前做的不好，那现在也差不多。理论有时候真的挺让人沮丧的。</p><p>通过实践，我们大部分的查询明显会被更快地应答。然而，跨越全部时间范围的查询仍然很慢，即便他们只需要找到少量的系列。在所有这些工作开始之前，我最初的想法都是想要一个切实解决这个问题的方案：我们需要一个更强大的<a href="https://en.wikipedia.org/wiki/Inverted_index" target="_blank" rel="noopener">倒排索引</a>。</p><p>倒排索引基于它们内容的子集提供对数据项的快速查找。简单来讲，用户可以找出所有带有标签“app =”nginx“的序列，而无需遍历每一个序列然后再检查它是否包含该标签。</p><p>为此，每个序列被分配一个唯一的 ID，通过它可以在恒定的时间内检索，即 O（1）。在这种情况下，ID 就是我们的正向索引。</p><blockquote><p>示例：如果ID为10,29和9的序列包含标签 <code>app=&quot;nginx&quot;</code>，标签 “nginx” 的倒排索引便是一个简单的列表 <code>[10,29,9]</code>，它可以用来快速检索包含该标签的所有序列。即便还有 200 亿个序列，这也不会影响该次查找的速度。</p></blockquote><p>简而言之，如果n是我们的序列总数，m 是给定查询的结果大小，那么使用索引的查询复杂度便是 O（m）。查询操作扩展到根据其检索的数据量（m）而不是正在搜索的数据体（n）是一个很棒的特性，因为一般来说 m 明显会更小些。</p><p>为了简单起见，我们假定可以在恒定的时间内完成倒排索引列表本身的检索。</p><p>实际上，这也几乎就是V2版本所拥有的倒排索引的类型，也是为数百万序列提供高性能查询的最低要求。敏锐的观察者会注意到，在最坏的情况下，所有的系列都存在一个标签，因此，m又是O（n）。 这是预料中的事情，而且也完全合理。 如果用户要查询所有的数据，自然就需要更长的时间。 一旦涉及到更复杂的查询这里可能就有问题了。</p><h4 id="组合标签-Combining-Labels"><a href="#组合标签-Combining-Labels" class="headerlink" title="组合标签 (Combining Labels)"></a>组合标签 (Combining Labels)</h4><p>标签被关联到数百万序列是很常见的。 假设有一个拥有数百个实例的横向可扩缩的“foo”微服务，每个实例有数千个系列。 每个系列都会有“app =”foo“的标签。当然，用户一般不会去查询所有的系列，而是通过进一步的过滤标签来限制查询，例如，我想知道我的服务实例收到多少个请求，那查询语句便是 <code>__name __ =“requests_total” AND app =“foo”</code>。</p><p>为了找出满足两个标签选择器的所有系列，我们取每个标签选择器的倒排索引列表然后取交集。 所得到的集合通常比每个输入列表小一个数量级。由于每个输入列表具有最差情况的复杂度是O（n），所以在两个列表上嵌套迭代的暴力解都具有O（n ^ 2）的运行时间。 其他集合操作也是相同的成本，例如union（app =“foo”OR app =“bar”）。当用户向查询添加进一步的标签选择器时，指数会增加到O（n ^ 3），O（n ^ 4），O（n ^ 5），… O（n ^ k）。 通过更改执行顺序，可以玩很多技巧来最大限度地有效减少运行时间。越复杂，就越需要了解数据样式和标签之间的关系。这引入了更多复杂度，但是并没有减少我们算法的最坏运行时间。</p><p>以上基本便是V2存储里采取的方式，幸运的是，看似微不足道的修改足以获得显著的提升。如果我们说我们的倒排索引中ID是排序好的话会发生什么？</p><p>假设我们初始查询的列表示例如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__name__=&quot;requests_total&quot;   -&gt;   [ 9999, 1000, 1001, 2000000, 2000001, 2000002, 2000003 ]</span><br><span class="line">     app=&quot;foo&quot;              -&gt;   [ 1, 3, 10, 11, 12, 100, 311, 320, 1000, 1001, 10002 ]</span><br><span class="line"></span><br><span class="line">             intersection   =&gt;   [ 1000, 1001 ]</span><br></pre></td></tr></table></figure><p>它们的交集相当小。我们可以通过在每个列表的开始处设置一个光标，并且始终从较小的数字那端依次推进。 当两个数字相等时，我们将数字添加到我们的结果中并推进两个游标。总的来说，我们以这种之字形模式（zig-zag pattern）扫描这两个列表，这样一来我们总的成本会是O（2n）= O（n），因为我们只是在任意一个列表中向前移动。</p><p>两个以上列表的不同集合操作的过程也是类似的效果。因此，k个集合操作的数量仅仅只会将时间复杂度修改为（O（k * n））而不是我们最坏情况的查找运行时的指数级（O（n ^ k））。真是一个大进步。</p><p>我在这里描述的内容几乎就是任意一款<a href="https://en.wikipedia.org/wiki/Search_engine_indexing#Inverted_indices" target="_blank" rel="noopener">全文搜索引擎</a> 所使用的规范搜索索引的简化版本。每个序列的描述符被视为一个简短的“文档”，每个标签（名称+固定值）作为其中的“单词”。我们可以忽略通常在搜索引擎索引中遇到的大量附加数据，例如字位置和出现频率等数据。</p><p>业内似乎都在无休止的研究探索改进实际运行时的方法，他们也常常对输入数据做出一些假设。不出所料的是，许多可以压缩倒排索引的技术均是有利有弊的。而由于我们的“文档”很小，“文字”在所有序列里都是非常重复的，所以压缩变得几乎无关紧要。 例如，一个约440万系列的现实世界数据集，每个标签约有12个，拥有少于5,000个唯一的标签。在我们最开始的存储版本里，我们坚持使用基本方法而不进行压缩，只添加了一些简单的调整来跳过大范围的非相交ID。</p><p>维持排序好的ID听上去可能很简单，但是实际坚持下来却是不太容易办到的。比如，V2存储引擎将一个哈希值作为ID赋给新的序列，我们无法有效地基于此建立一个排序好的倒排索引。另一个艰巨的任务是在数据被删除或更新时修改磁盘上的索引。通常，最简单的方法是简单地重新计算和重写它们，但是得在保证数据库可查询和一致性的同时执行这一操作。V3版本的存储引擎通过在每个块中分配一个单独的不可变索引来彻底解决这一问题，只能通过压缩时的重写来进行修改。而且，只有整个保存在内存里的可变块的索引才需要被更新。</p><h2 id="基准测试-Benchmark"><a href="#基准测试-Benchmark" class="headerlink" title="基准测试 (Benchmark)"></a>基准测试 (Benchmark)</h2><p>我发起了一个最初开发版本V3存储的基准测试，它是基于从现实世界数据集中提取的大约440万个序列描述符，并生成合成的数据点到对应的序列。这种遍历测试了单独的存储模块，而且对于快速识别性能瓶颈和触发仅在高并发负载下才会遇到的死锁尤为重要。</p><p>在完成概念性的实施之后，基准测试可以在我的Macbook Pro上保持每秒2000万个数据点的写吞吐量 —— 而所有的Chrome Tab和Slack都在持续运行。所以尽管这听上去很棒，但也表明推动这一基准测试没有进一步的价值（或者在这个问题里的随机环境下运行是这样的）。毕竟，这是合成的，这就决定了第一印象不会太好。对比最初的设计目标放大到近20倍的数据量，那么是时候将它嵌入到真正的Prometheus服务器里了，我们可以在上面添加所有只会在更贴近现实的环境里才会遇到的一切实际开销和情景。</p><p>实际上，我们没有可重复的Prometheus基准测试配置，特别是没有允许不同版本的A / B测试。 亡羊补牢为时不晚，<a href="https://github.com/prometheus/prombench" target="_blank" rel="noopener">现在我们有一个了</a>！</p><p>我们的工具允许我们声明式地定义一个基准测试场景，然后将其部署到AWS上的Kubernetes集群。 虽然这不是全面的基准测试的最佳环境，但它肯定能反映出我们的用户基本上会比64内核和128GB内存的专用裸机服务器跑的更好。我们部署了两台Prometheus 1.5.2的服务器（V2存储引擎）以及两台基于2.0开发分支（V3存储引擎）部署的两台Prometheus服务器。每台Prometheus服务都是运行在一台配备有一块SSD的专用服务器上。我们将一个横向可扩展的应用程序部署到了工作节点上并让它对外暴露典型的微服务度量。此外，Kubernetes集群和节点本身也正在被监控。全部配置均由另一个Meta-Prometheus监督，它会监控每台Prometheus服务器的健康性和性能。为了模拟序列分流，微服务会定期地向上扩容和向下缩容，以去除旧的pod，并产生新的pod，从而生成新的序列。 查询负载以“典型”地选择查询来模拟，对每个Prometheus版本的一台服务器执行操作。</p><p>总体而言，缩放和查询负载以及采样频率显著超过了今天Prometheus的生产部署。 例如，我们每15分钟换掉60％的微服务实例以产生序列分流。在现代化的基础设施中这应该每天只会发生1-5次。 这样就能确保我们的V3设计能够处理未来几年的工作负载。 因此，比起一个更为温和的环境，在现在这样的情况下，Prometheus 1.5.2和2.0之间的性能差异更大。我们每秒总共从850个同一时间暴露50万个序列的目标里收集大约11万个样本。</p><p>在放任这一配置运行一段时间后，我们可以来看些数字。我们评估一下前12个小时内两个版本均达到稳定状态的几个指标。</p><blockquote><p>请注意在Prometheus图形界面上的屏幕截图中略微截断的Y轴。</p></blockquote><img src="/hexo-blog/20180110/从头编写一款时间序列数据库/heap_usage.png"><p>堆内存使用（GB）</p><p>内存使用是当今用户最为困扰的资源问题，因为它是相对无法预测的，而且可能会导致进程崩溃。显然，被查询的服务器正在消耗更多的内存，这主要得归咎于查询引擎的开销，而这一点在未来将有望得到优化。总的来说，Prometheus 2.0的内存消耗减少了3-4倍。 大约六个小时后，Prometheus 1.5版本就有一个明显的尖峰，与六个小时的保留边界一致。 由于删除操作成本很高，资源消耗也随之增加。这将在下面的各种其他图表中体现。</p><img src="/hexo-blog/20180110/从头编写一款时间序列数据库/cpu_usage.png"><p>CPU使用率，核心/秒</p><p>CPU使用率的展示也是类似的模式，但是这里面查询服务器与非查询服务器之间的增量差异更为明显。以约0.5个核心/秒的平均值摄取大约110,000个样本/秒，与查询计算所花费的时间周期相比，我们的新存储消耗成本几乎可以忽略不计。 总的来说，新存储需要的CPU资源减少了3-10倍。</p><img src="/hexo-blog/20180110/从头编写一款时间序列数据库/disk_writes.png"><p>磁盘写入MB/秒</p><p>我们磁盘的写入利用率方面展示出了最突出和意想不到的改进。 这清晰地表明了为什么Prometheus 1.5容易造成SSD的耗损。 一旦第一个块被持久化到序列文件里，我们就能看到最开始会有一个飙升的过程，一旦删除然后开始重写，就会出现第二次飙升。令人诧异的是，被查询和非查询的服务器显示出完全不同的资源消耗。</p><p>另一方面，Prometheus 2.0只是以大约每秒一兆字节的写入速度写入到wal文件。 当块被压缩到磁盘时，写入周期性地出现一个尖峰。 这总体上节省了：惊人的97-99％。</p><img src="/hexo-blog/20180110/从头编写一款时间序列数据库/disk_usage.png"><p>磁盘大小（GB）</p><p>与磁盘写入量密切相关的是磁盘空间的总占用量。 由于我们对样本，即我们数据中的大部分组成，使用几乎相同的压缩算法，因此它们也应该是大致相同的。 在一个更稳定的环境中，这样做在很大程度上是合理的，但是因为我们要处理的是高度的序列分流，我们还得考虑每个序列的开销。</p><p>可以看到，Prometheus 1.5在两个版本都抵达稳定状态之前，消耗的存储空间因为保留策略的执行而迅速飙升。而Prometheus 2.0似乎在每个序列的开销都有一个明显的降幅。我们可以很高兴地看到磁盘空间是由预写日志文件线性填充的，并随着其压缩会瞬间下降。 事实上，Prometheus 2.0服务器不完全匹配线性增长的情况也是需要进一步调查的。</p><p>一切看上去都是充满希望的。 剩下的重要部分便是查询延迟。 新的索引应该提高了我们的查找复杂度。 没有实质改变的是这些数据的处理，例如 rate（）函数或聚合。 这些是查询引擎的一部分。</p><img src="/hexo-blog/20180110/从头编写一款时间序列数据库/query_latency.png"><p>99百分位数查询延迟（以秒为单位）</p><p>数据完全符合预期。 在Prometheus 1.5中，随着存储更多的序列，查询延迟会随时间而增加。 一旦保留策略开始执行，旧的系列被删除，它才会平息。 相比之下，Prometheus 2.0从一开始就停留在合理的位置。</p><p>这个数据怎样被收集则需要用户花些心思。对服务器发出的查询请求取决于一个时间范围值和即时查询估计的最佳搭档，压缩或轻或重，以及涉及的序列或多或少等等。它不一定代表查询的真实分布。它也不能代表冷数据的查询性能，我们可以假设所有样本数据实际上总是存储在内存中的热点数据。</p><p>尽管如此，我们仍然可以非常有信心地说，新版存储引擎在序列分流方面整体查询的性能变得非常有弹性，并且在我们高压的基准场景中存储的性能提高了4倍。在一个更加静态的环境里，我们可以假定查询时间主要用于查询引擎本身，而且延迟明显可以被改进到更低值。</p><img src="/hexo-blog/20180110/从头编写一款时间序列数据库/ingestion_rate.png"><p>采样/秒</p><p>最后，快速过一下我们对不同Prometheus服务器的采样率。 我们可以看到，配备V3存储的两台服务器是相同的采样率。几个小时后，它变得不稳定，这是由于基准集群的各个节点高负载造成的失去响应而跟Prometheus实例本身无关。 （这两行2.0的数据完全匹配的事实希望能让人信服）</p><p>即便还有更多可用的CPU和内存资源，Prometheus 1.5.2服务器的采样速率也在大大降低。 序列分流的高压导致它无法收集更大量的数据。</p><p>那么，现在每秒可以抓取的绝对最大样本数是多少？</p><p>我不知道 - 而且也故意不关注这一点。</p><p>影响Prometheus数据流量的因素众多，而这里面没有哪个单个数字能够衡量捕获质量。最大采样率历来是导致基准偏倚的一个指标，它忽略了更重要的方面，如查询性能以及对序列分流的抵御能力。 一些基本测试证实了资源使用线性增长的粗略假设。而这很容易推断出存在什么可能的结果。</p><p>我们的基准测试设置模拟了一个高度动态的环境，它给Prometheus施加的压力比今天大多数现实世界的设定要更大。 结果表明，我们在最优设计目标的基础上运行，而在不是最棒的云服务器上跑着。当然，最终衡量是否成功还是得取决于用户的反馈而不是基准数字。</p><blockquote><p>注意：在撰写本文时，Prometheus 1.6正在开发中，它将允许更可靠地配置最大内存使用量，并且可能会显著降低总体的消耗，略微有利于提高CPU利用率。我并没有进行重复的测试，因为整体的结果仍然变化不大，特别是当面对高度的序列分流时更是如此。</p></blockquote><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Prometheus开始准备应对独立样本的高基数序列及吞吐的处理。 这仍然是一项很具有挑战的任务，但是新的存储引擎似乎使得我们对于超大规模，超收敛的GIFEE基础设施的未来感到满意。恩，它似乎跑的不错。</p><p>配备新版V3存储引擎的第一个Alpha版本的 <a href="https://prometheus.io/blog/2017/04/10/promehteus-20-sneak-peak/" target="_blank" rel="noopener">Prometheus 2.0</a> 已经可用于测试。在这个早期阶段，预计会发生崩溃，死锁和其他错误。</p><p>存储引擎本身的代码可以在<a href="https://github.com/prometheus/tsdb" target="_blank" rel="noopener">单独的项目</a>中找到。对于Prometheus本身而言，这是非常不可知论的，而且它也可以广泛用于一大波正在苦苦寻觅一个有效的本地时间序列数据库存储的应用。</p><blockquote><p>这里得感谢很多人对这项工作的贡献。以下名单不分前后：</p><p>Bojoern Rabenstein和Julius Volz在V2存储引擎上的打磨工作以及他们对于V3的反馈为这新一代设计里所能看到的一切事物奠定了基础。</p><p>Wilhelm Bierbaum持续不断地意见和见解为新一代的设计做出了重大贡献。Brian Brazil源源不断的反馈也确保我们最终采用语义上合理的方案。与Peter Bourgon的精辟讨论验证了新的设计，并且造就了这篇文章。</p><p>当然也别忘了我所在的CoreOS整个团队和公司本身对这项工作的支持和赞助。感谢那些能够耐心听我一次又一次地扯着SSD，浮点数和序列化格式的每一位同学。</p></blockquote><p>原文链接：<a href="https://fabxc.org/blog/2017-04-10-writing-a-tsdb/" target="_blank" rel="noopener">writing-a-time-series-database-from-scratch</a><br>译文链接：<a href="http://dockone.io/article/2300" target="_blank" rel="noopener">从头编写一款时间序列数据库</a> （翻译：Colstuwjx）</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;本文转自 &lt;a href=&quot;http://dockone.io/article/2300&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;从头编写一款时间序列数据库&lt;/a&gt; （翻译：Colstuwjx），请支持原作者。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我从事监控方面的工作。尤其是专注在 &lt;a href=&quot;https://prometheus.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Prometheus&lt;/a&gt;，一款内置了自己定制的时间序列数据库的监控系统，以及它和 &lt;a href=&quot;https://kubernetes.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kubernetes&lt;/a&gt; 的集成工作。&lt;/p&gt;&lt;p&gt;从很多方面来说，Kubernetes 表现出了一切 Prometheus 专门设计的东西。它使得持续部署，自动扩缩，以及高度动态环境的其他功能更易于实现。它的查询语言和操作模型，还有许多其他概念方面的决策使得 Prometheus 尤其适合这样的环境。然而，如果被监控的工作负载变得更加显著动态的话，这也会给监控系统本身带来新的压力。基于这一点的考虑，与其再次回顾 Prometheus 已经很好解决的问题，还不如专注于在这样一个高度动态或短生命周期服务的环境里提高它的性能。&lt;/p&gt;&lt;p&gt;Prometheus 的存储层在历史上有着惊人的性能表现，一个单台服务器每秒可以摄取多达 100 万个采样，数百万个时间序列，同时仅占用令人惊叹的少量磁盘空间。尽管当前的存储已经给我们提供了不错的服务，笔者构思了一个新设计的存储子系统用来纠正现有解决方案的一些短板，并且可以用来配备支撑下一代的集群规模。&lt;/p&gt;
    
    </summary>
    
    
      <category term="转载" scheme="http://whypro.github.io/hexo-blog/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="Kubernetes" scheme="http://whypro.github.io/hexo-blog/tags/Kubernetes/"/>
    
      <category term="K8S" scheme="http://whypro.github.io/hexo-blog/tags/K8S/"/>
    
      <category term="Prometheus" scheme="http://whypro.github.io/hexo-blog/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes APIServer 证书的手动签发</title>
    <link href="http://whypro.github.io/hexo-blog/20171206/Kubernetes-APIServer-%E8%AF%81%E4%B9%A6%E7%9A%84%E6%89%8B%E5%8A%A8%E7%AD%BE%E5%8F%91/"/>
    <id>http://whypro.github.io/hexo-blog/20171206/Kubernetes-APIServer-证书的手动签发/</id>
    <published>2017-12-06T12:13:00.000Z</published>
    <updated>2019-06-02T09:10:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>有时我们需要将自定义的域名或 IP 加入到 apiserver 的证书中，以通过 kubectl 或 kubelet 等客户端的验证，这个时候就需要对 apiserver 证书中包含的 IP 和 DNS 信息做些修改。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>首先介绍几个概念：</p><ul><li>KEY: 私钥</li><li>CSR: Certificate Signing Request 证书签名请求（公钥）</li><li>CRT: Certificate 证书</li><li>x.509: 一种证书格式</li><li>PEM: X.509 证书文件具体的存储格式（有时候用 pem 代替 crt 后缀）</li></ul><a id="more"></a><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>重新生成 apiserver 证书的步骤：</p><ol><li>创建 2048bit 的 <code>ca.key</code> （<code>/etc/kubernetes/pki</code> 目录已经存在可跳过）</li></ol><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out ca.key 2048</span><br></pre></td></tr></table></figure><ol start="2"><li>基于 <code>ca.key</code> 创建 <code>ca.crt</code> （<code>/etc/kubernetes/pki</code> 已经存在可跳过）</li></ol><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -x509 -new -nodes -key ca.key -subj <span class="hljs-string">"/CN=kube-apiserver"</span> -days 10000 -out ca.crt</span><br></pre></td></tr></table></figure><ol start="3"><li>创建 2048bit 的 <code>server.key</code> （<code>/etc/kubernetes/pki</code> 已经存在可跳过）</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out apiserver.key 2048</span><br></pre></td></tr></table></figure><ol start="4"><li>编辑创建 csr 需要的配置文件</li></ol><p>根据需要添加或修改相应字段</p><figure class="highlight ini hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">[ req ]</span></span><br><span class="line"><span class="hljs-attr">default_bits</span> = <span class="hljs-number">2048</span></span><br><span class="line"><span class="hljs-attr">prompt</span> = <span class="hljs-literal">no</span></span><br><span class="line"><span class="hljs-attr">default_md</span> = sha256</span><br><span class="line"><span class="hljs-attr">req_extensions</span> = req_ext</span><br><span class="line"><span class="hljs-attr">distinguished_name</span> = dn</span><br><span class="line"> </span><br><span class="line"><span class="hljs-section">[ dn ]</span></span><br><span class="line"><span class="hljs-attr">CN</span> = kube-apiserver</span><br><span class="line"> </span><br><span class="line"><span class="hljs-section">[ req_ext ]</span></span><br><span class="line"><span class="hljs-attr">subjectAltName</span> = @alt_names</span><br><span class="line"> </span><br><span class="line"><span class="hljs-section">[alt_names]</span></span><br><span class="line">DNS.1 = kubernetes</span><br><span class="line">DNS.2 = kubernetes.default</span><br><span class="line">DNS.3 = kubernetes.default.svc</span><br><span class="line">DNS.4 = kubernetes.default.svc.cluster.local</span><br><span class="line">DNS.5 = haoyu-k8s-1</span><br><span class="line">IP.1 = 10.96.0.1</span><br><span class="line">IP.2 = 172.21.1.13</span><br><span class="line">IP.3 = 183.2.220.210</span><br><span class="line"> </span><br><span class="line"><span class="hljs-section">[ v3_ext ]</span></span><br><span class="line"><span class="hljs-attr">keyUsage</span>=critical, digitalSignature, keyEncipherment</span><br><span class="line"><span class="hljs-attr">extendedKeyUsage</span>=serverAuth</span><br><span class="line"><span class="hljs-attr">subjectAltName</span>=@alt_names</span><br></pre></td></tr></table></figure><ol start="5"><li>创建 <code>server.csr</code></li></ol><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key apiserver.key -out apiserver.csr -config csr.conf</span><br></pre></td></tr></table></figure><ol start="6"><li>基于 <code>ca.key</code> <code>ca.crt</code> <code>server.csr</code> 创建 <code>server.crt</code></li></ol><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -<span class="hljs-keyword">in</span> apiserver.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out apiserver.crt -days 10000 -extensions v3_ext -extfile csr.conf</span><br></pre></td></tr></table></figure><ol start="7"><li>查看生成的 <code>server.crt</code></li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509  -noout -text -in ./apiserver.crt</span><br></pre></td></tr></table></figure><p>最好和原证书 diff 一下，以保证其他字段一致</p><p>对于多个 apiserver 高可用的场景，方便起见可以将生成的 <code>apiserver.crt</code> 和 <code>apiserver.key</code> 一同拷贝到多个节点的 <code>/etc/kubernetes/pki</code> 目录下（使用同一份私钥和证书）。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><code>csr.conf</code>:</p><p>主要关注 alt_names 的 DNS 和 IP 字段：</p><figure class="highlight ini hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">[ req ]</span></span><br><span class="line"><span class="hljs-attr">default_bits</span> = <span class="hljs-number">2048</span></span><br><span class="line"><span class="hljs-attr">prompt</span> = <span class="hljs-literal">no</span></span><br><span class="line"><span class="hljs-attr">default_md</span> = sha256</span><br><span class="line"><span class="hljs-attr">req_extensions</span> = req_ext</span><br><span class="line"><span class="hljs-attr">distinguished_name</span> = dn</span><br><span class="line"> </span><br><span class="line"><span class="hljs-section">[ dn ]</span></span><br><span class="line"><span class="hljs-attr">CN</span> = kube-apiserver</span><br><span class="line"> </span><br><span class="line"><span class="hljs-section">[ req_ext ]</span></span><br><span class="line"><span class="hljs-attr">subjectAltName</span> = @alt_names</span><br><span class="line"> </span><br><span class="line"><span class="hljs-section">[alt_names]</span></span><br><span class="line">DNS.1 = kubernetes</span><br><span class="line">DNS.2 = kubernetes.default</span><br><span class="line">DNS.3 = kubernetes.default.svc</span><br><span class="line">DNS.4 = kubernetes.default.svc.cluster.local</span><br><span class="line">DNS.5 = kubernetes.kube-system.svc.cluster.local</span><br><span class="line">DNS.6 = host1</span><br><span class="line">DNS.7 = host2</span><br><span class="line">DNS.8 = host3</span><br><span class="line"> </span><br><span class="line">IP.1 = 172.16.0.1</span><br><span class="line">IP.2 = 10.200.20.11</span><br><span class="line">IP.3 = 10.200.20.12</span><br><span class="line">IP.4 = 10.200.20.13</span><br><span class="line">IP.5 = 10.200.20.200</span><br><span class="line"> </span><br><span class="line"><span class="hljs-section">[ v3_ext ]</span></span><br><span class="line"><span class="hljs-attr">keyUsage</span>=critical, digitalSignature, keyEncipherment</span><br><span class="line"><span class="hljs-attr">extendedKeyUsage</span>=serverAuth</span><br><span class="line"><span class="hljs-attr">subjectAltName</span>=@alt_names</span><br></pre></td></tr></table></figure><p><code>cert.sh</code>:</p><p>根据 <code>csr.conf</code> 自动签发 <code>apiserver.crt</code>，并拷贝至 <code>/etc/kubernetes/pki</code> 目录：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key /etc/kubernetes/pki/apiserver.key -out apiserver.csr -config csr.conf</span><br><span class="line">openssl x509 -req -<span class="hljs-keyword">in</span> apiserver.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -out apiserver.crt -days 10000 -extensions v3_ext -extfile csr.conf</span><br><span class="line"> </span><br><span class="line">openssl x509  -noout -text -<span class="hljs-keyword">in</span> /etc/kubernetes/pki/apiserver.crt &gt; apiserver.crt.old.txt</span><br><span class="line">openssl x509  -noout -text -<span class="hljs-keyword">in</span> apiserver.crt &gt; apiserver.crt.txt</span><br><span class="line">diff apiserver.crt.txt apiserver.crt.old.txt</span><br><span class="line"> </span><br><span class="line">mv /etc/kubernetes/pki/apiserver.crt /etc/kubernetes/pki/apiserver.crt.bak.$(date +%Y%m%d%H%M%S)</span><br><span class="line">cp apiserver.crt /etc/kubernetes/pki/apiserver.crt</span><br><span class="line">chmod 400 /etc/kubernetes/pki/apiserver.crt</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://kubernetes.io/docs/concepts/cluster-administration/certificates/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/cluster-administration/certificates/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;有时我们需要将自定义的域名或 IP 加入到 apiserver 的证书中，以通过 kubectl 或 kubelet 等客户端的验证，这个时候就需要对 apiserver 证书中包含的 IP 和 DNS 信息做些修改。&lt;/p&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;首先介绍几个概念：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;KEY: 私钥&lt;/li&gt;&lt;li&gt;CSR: Certificate Signing Request 证书签名请求（公钥）&lt;/li&gt;&lt;li&gt;CRT: Certificate 证书&lt;/li&gt;&lt;li&gt;x.509: 一种证书格式&lt;/li&gt;&lt;li&gt;PEM: X.509 证书文件具体的存储格式（有时候用 pem 代替 crt 后缀）&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="云计算" scheme="http://whypro.github.io/hexo-blog/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Kubernetes" scheme="http://whypro.github.io/hexo-blog/tags/Kubernetes/"/>
    
      <category term="K8S" scheme="http://whypro.github.io/hexo-blog/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>Aria2 配置备忘</title>
    <link href="http://whypro.github.io/hexo-blog/20171015/Aria2-%E9%85%8D%E7%BD%AE%E5%A4%87%E5%BF%98/"/>
    <id>http://whypro.github.io/hexo-blog/20171015/Aria2-配置备忘/</id>
    <published>2017-10-15T13:01:10.000Z</published>
    <updated>2019-06-02T09:10:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>Aria2 是一款轻量级的命令行下载工具，支持 HTTP/HTTPS、FTP、SFTP、BitTorrent 和 Metalink 等链接格式，提供 JSON-RPC 和 XML-RPC 管理接口，是一款优秀的 Linux 版迅雷替代品。</p><a id="more"></a><h2 id="Aria2-Server"><a href="#Aria2-Server" class="headerlink" title="Aria2 Server"></a>Aria2 Server</h2><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/aria2</span><br><span class="line">touch /etc/aria2/save-session.list</span><br><span class="line"></span><br><span class="line">mkdir /var/log/aria2</span><br></pre></td></tr></table></figure><p>将以下内容保存至 <code>/etc/aria2/aria2.conf</code>：</p><figure class="highlight ini hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">## '#'开头为注释内容, 选项都有相应的注释说明, 根据需要修改 ##</span></span><br><span class="line"><span class="hljs-comment">## 被注释的选项填写的是默认值, 建议在需要修改时再取消注释  ##</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">## 文件保存相关 ##</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置</span></span><br><span class="line"><span class="hljs-attr">dir</span>=/home/whypro/aria2</span><br><span class="line"><span class="hljs-comment"># 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M</span></span><br><span class="line"><span class="hljs-comment">#disk-cache=32M</span></span><br><span class="line"><span class="hljs-comment"># 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc</span></span><br><span class="line"><span class="hljs-comment"># 预分配所需时间: none &lt; falloc ? trunc &lt; prealloc</span></span><br><span class="line"><span class="hljs-comment"># falloc和trunc则需要文件系统和内核支持</span></span><br><span class="line"><span class="hljs-comment"># NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项</span></span><br><span class="line"><span class="hljs-comment">#file-allocation=none</span></span><br><span class="line"><span class="hljs-comment"># 断点续传</span></span><br><span class="line"><span class="hljs-attr">continue</span>=<span class="hljs-literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">## 下载连接相关 ##</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 最大同时下载任务数, 运行时可修改, 默认:5</span></span><br><span class="line"><span class="hljs-comment">#max-concurrent-downloads=5</span></span><br><span class="line"><span class="hljs-comment"># 同一服务器连接数, 添加时可指定, 默认:1</span></span><br><span class="line"><span class="hljs-attr">max-connection-per-server</span>=<span class="hljs-number">10</span></span><br><span class="line"><span class="hljs-comment"># 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M</span></span><br><span class="line"><span class="hljs-comment"># 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载</span></span><br><span class="line"><span class="hljs-attr">min-split-size</span>=<span class="hljs-number">10</span>M</span><br><span class="line"><span class="hljs-comment"># 单个任务最大线程数, 添加时可指定, 默认:5</span></span><br><span class="line"><span class="hljs-comment">#split=5</span></span><br><span class="line"><span class="hljs-comment"># 整体下载速度限制, 运行时可修改, 默认:0</span></span><br><span class="line"><span class="hljs-comment">#max-overall-download-limit=0</span></span><br><span class="line"><span class="hljs-comment"># 单个任务下载速度限制, 默认:0</span></span><br><span class="line"><span class="hljs-comment">#max-download-limit=0</span></span><br><span class="line"><span class="hljs-comment"># 整体上传速度限制, 运行时可修改, 默认:0</span></span><br><span class="line"><span class="hljs-comment">#max-overall-upload-limit=0</span></span><br><span class="line"><span class="hljs-comment"># 单个任务上传速度限制, 默认:0</span></span><br><span class="line"><span class="hljs-comment">#max-upload-limit=0</span></span><br><span class="line"><span class="hljs-comment"># 禁用IPv6, 默认:false</span></span><br><span class="line"><span class="hljs-attr">disable-ipv6</span>=<span class="hljs-literal">true</span></span><br><span class="line"><span class="hljs-comment"># 连接超时时间, 默认:60</span></span><br><span class="line"><span class="hljs-attr">timeout</span>=<span class="hljs-number">600</span></span><br><span class="line"><span class="hljs-comment"># 最大重试次数, 设置为0表示不限制重试次数, 默认:5</span></span><br><span class="line"><span class="hljs-attr">max-tries</span>=<span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-comment"># 设置重试等待的秒数, 默认:0</span></span><br><span class="line"><span class="hljs-attr">retry-wait</span>=<span class="hljs-number">30</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">## 进度保存相关 ##</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 从会话文件中读取下载任务</span></span><br><span class="line"><span class="hljs-attr">input-file</span>=/etc/aria2/save-session.list</span><br><span class="line"><span class="hljs-comment"># 在Aria2退出时保存`错误/未完成`的下载任务到会话文件</span></span><br><span class="line"><span class="hljs-attr">save-session</span>=/etc/aria2/save-session.list</span><br><span class="line"><span class="hljs-comment"># 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0</span></span><br><span class="line"><span class="hljs-comment">#save-session-interval=60</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">## RPC相关设置 ##</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 启用RPC, 默认:false</span></span><br><span class="line"><span class="hljs-attr">enable-rpc</span>=<span class="hljs-literal">true</span></span><br><span class="line"><span class="hljs-comment"># 允许所有来源, 默认:false</span></span><br><span class="line"><span class="hljs-attr">rpc-allow-origin-all</span>=<span class="hljs-literal">true</span></span><br><span class="line"><span class="hljs-comment"># 允许非外部访问, 默认:false</span></span><br><span class="line"><span class="hljs-attr">rpc-listen-all</span>=<span class="hljs-literal">true</span></span><br><span class="line"><span class="hljs-comment"># 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同</span></span><br><span class="line"><span class="hljs-comment">#event-poll=select</span></span><br><span class="line"><span class="hljs-comment"># RPC监听端口, 端口被占用时可以修改, 默认:6800</span></span><br><span class="line"><span class="hljs-comment">#rpc-listen-port=6800</span></span><br><span class="line"><span class="hljs-comment"># 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项</span></span><br><span class="line"><span class="hljs-comment">#rpc-secret=&lt;TOKEN&gt;</span></span><br><span class="line"><span class="hljs-comment"># 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项</span></span><br><span class="line"><span class="hljs-comment">#rpc-user=&lt;USER&gt;</span></span><br><span class="line"><span class="hljs-comment"># 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项</span></span><br><span class="line"><span class="hljs-comment">#rpc-passwd=&lt;PASSWD&gt;</span></span><br><span class="line"><span class="hljs-comment"># 是否启用 RPC 服务的 SSL/TLS 加密,</span></span><br><span class="line"><span class="hljs-comment"># 启用加密后 RPC 服务需要使用 https 或者 wss 协议连接</span></span><br><span class="line"><span class="hljs-comment">#rpc-secure=true</span></span><br><span class="line"><span class="hljs-comment"># 在 RPC 服务中启用 SSL/TLS 加密时的证书文件,</span></span><br><span class="line"><span class="hljs-comment"># 使用 PEM 格式时，您必须通过 --rpc-private-key 指定私钥</span></span><br><span class="line"><span class="hljs-comment">#rpc-certificate=/path/to/certificate.pem</span></span><br><span class="line"><span class="hljs-comment"># 在 RPC 服务中启用 SSL/TLS 加密时的私钥文件</span></span><br><span class="line"><span class="hljs-comment">#rpc-private-key=/path/to/certificate.key</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">## BT/PT下载相关 ##</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true</span></span><br><span class="line"><span class="hljs-comment">#follow-torrent=true</span></span><br><span class="line"><span class="hljs-comment"># BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999</span></span><br><span class="line"><span class="hljs-attr">listen-port</span>=<span class="hljs-number">51413</span></span><br><span class="line"><span class="hljs-comment"># 单个种子最大连接数, 默认:55</span></span><br><span class="line"><span class="hljs-comment">#bt-max-peers=55</span></span><br><span class="line"><span class="hljs-comment"># 打开DHT功能, PT需要禁用, 默认:true</span></span><br><span class="line"><span class="hljs-attr">enable-dht</span>=<span class="hljs-literal">false</span></span><br><span class="line"><span class="hljs-comment"># 打开IPv6 DHT功能, PT需要禁用</span></span><br><span class="line"><span class="hljs-comment">#enable-dht6=false</span></span><br><span class="line"><span class="hljs-comment"># DHT网络监听端口, 默认:6881-6999</span></span><br><span class="line"><span class="hljs-comment">#dht-listen-port=6881-6999</span></span><br><span class="line"><span class="hljs-comment"># 本地节点查找, PT需要禁用, 默认:false</span></span><br><span class="line"><span class="hljs-comment">#bt-enable-lpd=false</span></span><br><span class="line"><span class="hljs-comment"># 种子交换, PT需要禁用, 默认:true</span></span><br><span class="line"><span class="hljs-attr">enable-peer-exchange</span>=<span class="hljs-literal">false</span></span><br><span class="line"><span class="hljs-comment"># 每个种子限速, 对少种的PT很有用, 默认:50K</span></span><br><span class="line"><span class="hljs-comment">#bt-request-peer-speed-limit=50K</span></span><br><span class="line"><span class="hljs-comment"># 客户端伪装, PT需要</span></span><br><span class="line"><span class="hljs-attr">peer-id-prefix</span>=-TR2770-</span><br><span class="line"><span class="hljs-attr">user-agent</span>=Transmission/<span class="hljs-number">2.77</span></span><br><span class="line"><span class="hljs-comment"># 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0</span></span><br><span class="line"><span class="hljs-attr">seed-ratio</span>=<span class="hljs-number">0</span></span><br><span class="line"><span class="hljs-comment"># 强制保存会话, 即使任务已经完成, 默认:false</span></span><br><span class="line"><span class="hljs-comment"># 较新的版本开启后会在任务完成后依然保留.aria2文件</span></span><br><span class="line"><span class="hljs-comment">#force-save=false</span></span><br><span class="line"><span class="hljs-comment"># BT校验相关, 默认:true</span></span><br><span class="line"><span class="hljs-comment">#bt-hash-check-seed=true</span></span><br><span class="line"><span class="hljs-comment"># 继续之前的BT任务时, 无需再次校验, 默认:false</span></span><br><span class="line"><span class="hljs-attr">bt-seed-unverified</span>=<span class="hljs-literal">true</span></span><br><span class="line"><span class="hljs-comment"># 保存磁力链接元数据为种子文件(.torrent文件), 默认:false</span></span><br><span class="line"><span class="hljs-attr">bt-save-metadata</span>=<span class="hljs-literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">## 其他相关 ##</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 日志级别，可以为debug, info, notice, warn 或 error</span></span><br><span class="line"><span class="hljs-attr">log-level</span>=notice</span><br><span class="line"><span class="hljs-comment"># 日志文件，根据实际情况修改</span></span><br><span class="line"><span class="hljs-attr">log</span>=/var/log/aria2/aria2.log</span><br><span class="line"><span class="hljs-comment"># 下载进度输出的间隔时间</span></span><br><span class="line"><span class="hljs-attr">summary-interval</span>=<span class="hljs-number">120</span></span><br><span class="line"><span class="hljs-comment"># 是否以守护进程的方式启动</span></span><br><span class="line"><span class="hljs-attr">daemon</span>=<span class="hljs-literal">true</span></span><br></pre></td></tr></table></figure><h2 id="Systemd-Service"><a href="#Systemd-Service" class="headerlink" title="Systemd Service"></a>Systemd Service</h2><p>将以下内容保存至 <code>aria2c.service</code> 放入 <code>/lib/systemd/system/</code> 目录</p><figure class="highlight ini hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">[Unit]</span></span><br><span class="line"><span class="hljs-attr">Description</span>=aria2c -- file download manager</span><br><span class="line"><span class="hljs-attr">After</span>=network.target</span><br><span class="line"></span><br><span class="line"><span class="hljs-section">[Service]</span></span><br><span class="line"><span class="hljs-attr">Type</span>=forking</span><br><span class="line"><span class="hljs-attr">User</span>=%i</span><br><span class="line"><span class="hljs-attr">WorkingDirectory</span>=%h</span><br><span class="line"><span class="hljs-attr">Environment</span>=VAR=/var/%i</span><br><span class="line"><span class="hljs-attr">ExecStart</span>=/usr/bin/aria2c --conf-path=/etc/aria2/aria2.conf</span><br><span class="line"></span><br><span class="line"><span class="hljs-section">[Install]</span></span><br><span class="line"><span class="hljs-attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure><p>之后执行</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start aria2c</span><br><span class="line">systemctl enable aria2c</span><br></pre></td></tr></table></figure><h2 id="Web-UI"><a href="#Web-UI" class="headerlink" title="Web UI"></a>Web UI</h2><h3 id="Aria2WebUI"><a href="#Aria2WebUI" class="headerlink" title="Aria2WebUI"></a>Aria2WebUI</h3><ul><li><a href="http://webui-aria2.ghostry.cn/" target="_blank" rel="noopener">http://webui-aria2.ghostry.cn/</a></li><li><a href="https://ziahamza.github.io/webui-aria2/" target="_blank" rel="noopener">https://ziahamza.github.io/webui-aria2/</a></li></ul><h3 id="YAAW"><a href="#YAAW" class="headerlink" title="YAAW:"></a>YAAW:</h3><ul><li><a href="https://chrome.google.com/webstore/detail/yaaw-for-chrome/dennnbdlpgjgbcjfgaohdahloollfgoc" target="_blank" rel="noopener">Chrome 插件</a></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="http://ju.outofmemory.cn/entry/146734" target="_blank" rel="noopener">Raspberry Pi技术笔记之四：使用aria2打造下载利器</a><br>[2] <a href="http://aria2c.com/usage.html" target="_blank" rel="noopener">Aria2 &amp; YAAW 使用说明</a><br>[3] <a href="https://aria2.github.io/manual/en/html/aria2c.html" target="_blank" rel="noopener">aria2c docs</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Aria2 是一款轻量级的命令行下载工具，支持 HTTP/HTTPS、FTP、SFTP、BitTorrent 和 Metalink 等链接格式，提供 JSON-RPC 和 XML-RPC 管理接口，是一款优秀的 Linux 版迅雷替代品。&lt;/p&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>Hello, Hexo.</title>
    <link href="http://whypro.github.io/hexo-blog/20170924/hello-hexo/"/>
    <id>http://whypro.github.io/hexo-blog/20170924/hello-hexo/</id>
    <published>2017-09-23T17:44:27.000Z</published>
    <updated>2019-06-02T09:10:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>周末折腾了半天，终于将博客从 Pelican 转到了 Hexo，在此记录一下。</p><h2 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h2><p>首先说说方案选择，目前博客系统大致分为静态和动态两类，动态博客有 Wordpress、Ghost 等等，因为需要单独的主机和搭建环境，并且数据存在 DB 迁移起来比较费劲，所以放弃了这种方案；静态博客有 Pelican、Jekyll、Hexo 等等，后者很多优点，访问速度快，博客可直接用 Markdown 以文件的形式保存在 Github，借助 Github Pages 部署方便，不用自己搭建主机，总之个人觉得这些优点可以完爆动态博客。</p><p>笔者之前的博客是基于 Pelican 的，因为使用 Python 写的，而自己对 Python 有一种痴迷，因此之前选用了这种方案，但是慢慢发现缺点有很多。首先是渲染速度慢，当文章越来越多时，博客生成的时间就会让人难以忍受。另外 Pelican 的主题都不是很炫，找了半天都没有找到好看的主题，这也是促使我选用其他博客系统的一个原因。</p><p>其次了解了 Jekyll，它是用 Ruby 开发的，也是 Github 主推的博客系统，和 Github 无缝结合，可以直接在 Github 页面上配置、修改主题（<a href="https://pages.github.com/" target="_blank" rel="noopener">教程在此</a>），主题也很多，如果没有遇见 Hexo，也许我会选择 Jekyll。</p><p>Hexo 使用 Nodejs 开发，渲染速度相对于 Python 和 Ruby 来说很快，而且 CLI 设计也非常人性化，配置简单，支持的插件也有很多，使用 <code>npm</code> 来管理。也许正是由于开发语言的关系，Hexo 的主题质量都非常高，都非常好看，让人眼花缭乱（<a href="https://hexo.io/themes/index.html" target="_blank" rel="noopener">https://hexo.io/themes/index.html</a>）。老实说我是被这款名叫 <a href="https://github.com/klugjo/hexo-theme-alpha-dust" target="_blank" rel="noopener">AlphaDust</a> 的主题吸引了，非常有科技感，而且响应式在移动设备上也比较完美，无论是英文字体还是中文字体都支持很好，对作者的敬意油然而生。当然 <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT</a> 也是一款非常优秀的主题，以后有机会可以尝试一下（^_^）。</p><a id="more"></a><h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>可以参考<a href="https://hexo.io/docs/index.html" target="_blank" rel="noopener">官方文档</a>。</p><p>首先安装 nvm：</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">$</span><span class="hljs-bash"> curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash</span></span><br></pre></td></tr></table></figure><p>安装完成后重启终端，安装 nodejs 和 hexo：</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">$</span><span class="hljs-bash"> nvm install stable</span></span><br><span class="line"><span class="hljs-meta">$</span><span class="hljs-bash"> npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure><p>创建一个新的博客项目：</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">$</span><span class="hljs-bash"> hexo init &lt;folder&gt;</span></span><br><span class="line"><span class="hljs-meta">$</span><span class="hljs-bash"> <span class="hljs-built_in">cd</span> &lt;folder&gt;</span></span><br><span class="line"><span class="hljs-meta">$</span><span class="hljs-bash"> npm install</span></span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>这里要注意的是如果使用 Github Pages，URL 包含子目录时，要注意设置 <code>_config.yml</code> 中的 <code>url</code> 和 <code>root</code>。</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">url:</span> <span class="hljs-attr">http://whypro.github.io/hexo-blog</span></span><br><span class="line"><span class="hljs-attr">root:</span> <span class="hljs-string">/hexo-blog/</span></span><br></pre></td></tr></table></figure><p>文章 URL 和文件名的配置按照个人喜好来修改：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year:month:day/:title/</span></span><br><span class="line"><span class="hljs-attr">new_post_name:</span> <span class="hljs-string">:year:month:day-:title.md</span></span><br></pre></td></tr></table></figure><h2 id="部署-Github-Pages"><a href="#部署-Github-Pages" class="headerlink" title="部署 Github Pages"></a>部署 Github Pages</h2><p>首先在配置文件中加入 Github 相关信息：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">deploy:</span>  </span><br><span class="line"><span class="hljs-attr">  type:</span> <span class="hljs-string">git</span></span><br><span class="line"><span class="hljs-attr">  repository:</span> <span class="hljs-string">git@github.com:&lt;username&gt;/&lt;reponame&gt;.git</span></span><br><span class="line"><span class="hljs-attr">  branch:</span> <span class="hljs-string">gh-pages</span></span><br></pre></td></tr></table></figure><p>然后执行：</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">$</span><span class="hljs-bash"> hexo generate</span></span><br><span class="line"><span class="hljs-meta">$</span><span class="hljs-bash"> hexo deploy</span></span><br></pre></td></tr></table></figure><h2 id="后续工作"><a href="#后续工作" class="headerlink" title="后续工作"></a>后续工作</h2><p>至于博客的全文搜索，可以用 <a href="https://swiftype.com/" target="_blank" rel="noopener">Swiftype</a> 服务，有空再研究一下。</p><p>关于代码高亮可以参考 <a href="http://highlightjs.readthedocs.io/en/latest/css-classes-reference.html" target="_blank" rel="noopener">CSS classes reference</a>。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://www.race604.com/migrate-ghost-to-hexo/" target="_blank" rel="noopener">博客从 Ghost 迁移到 Hexo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周末折腾了半天，终于将博客从 Pelican 转到了 Hexo，在此记录一下。&lt;/p&gt;&lt;h2 id=&quot;方案选择&quot;&gt;&lt;a href=&quot;#方案选择&quot; class=&quot;headerlink&quot; title=&quot;方案选择&quot;&gt;&lt;/a&gt;方案选择&lt;/h2&gt;&lt;p&gt;首先说说方案选择，目前博客系统大致分为静态和动态两类，动态博客有 Wordpress、Ghost 等等，因为需要单独的主机和搭建环境，并且数据存在 DB 迁移起来比较费劲，所以放弃了这种方案；静态博客有 Pelican、Jekyll、Hexo 等等，后者很多优点，访问速度快，博客可直接用 Markdown 以文件的形式保存在 Github，借助 Github Pages 部署方便，不用自己搭建主机，总之个人觉得这些优点可以完爆动态博客。&lt;/p&gt;&lt;p&gt;笔者之前的博客是基于 Pelican 的，因为使用 Python 写的，而自己对 Python 有一种痴迷，因此之前选用了这种方案，但是慢慢发现缺点有很多。首先是渲染速度慢，当文章越来越多时，博客生成的时间就会让人难以忍受。另外 Pelican 的主题都不是很炫，找了半天都没有找到好看的主题，这也是促使我选用其他博客系统的一个原因。&lt;/p&gt;&lt;p&gt;其次了解了 Jekyll，它是用 Ruby 开发的，也是 Github 主推的博客系统，和 Github 无缝结合，可以直接在 Github 页面上配置、修改主题（&lt;a href=&quot;https://pages.github.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;教程在此&lt;/a&gt;），主题也很多，如果没有遇见 Hexo，也许我会选择 Jekyll。&lt;/p&gt;&lt;p&gt;Hexo 使用 Nodejs 开发，渲染速度相对于 Python 和 Ruby 来说很快，而且 CLI 设计也非常人性化，配置简单，支持的插件也有很多，使用 &lt;code&gt;npm&lt;/code&gt; 来管理。也许正是由于开发语言的关系，Hexo 的主题质量都非常高，都非常好看，让人眼花缭乱（&lt;a href=&quot;https://hexo.io/themes/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://hexo.io/themes/index.html&lt;/a&gt;）。老实说我是被这款名叫 &lt;a href=&quot;https://github.com/klugjo/hexo-theme-alpha-dust&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AlphaDust&lt;/a&gt; 的主题吸引了，非常有科技感，而且响应式在移动设备上也比较完美，无论是英文字体还是中文字体都支持很好，对作者的敬意油然而生。当然 &lt;a href=&quot;http://theme-next.iissnan.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NexT&lt;/a&gt; 也是一款非常优秀的主题，以后有机会可以尝试一下（^_^）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>引用计数与垃圾收集之比较</title>
    <link href="http://whypro.github.io/hexo-blog/20160910/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E4%B8%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E4%B9%8B%E6%AF%94%E8%BE%83/"/>
    <id>http://whypro.github.io/hexo-blog/20160910/引用计数与垃圾收集之比较/</id>
    <published>2016-09-09T16:45:13.000Z</published>
    <updated>2019-07-04T03:44:51.756Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="http://blog.codingnow.com/2008/06/gc.html" target="_blank" rel="noopener">http://blog.codingnow.com/2008/06/gc.html</a></p></blockquote><p>本质上来说，引用计数策略和垃圾收集策略都属于资源的自动化管理。所谓自动化管理，就是在逻辑层不知道资源在什么时候被释放掉，而依赖底层库来维持资源的生命期。</p><p>而手工管理，则是可以准确的知道资源的生命期，在准确的位置回收它。在 C++ 中，体现在析构函数中写明 delete 用到的资源，并由编译器自动生成的代码析构基类和成员变量。</p><p>所以，为 C++ 写一个垃圾收集器，并不和手工管理资源冲突。自动化管理几乎在所有有点规模的 C++ 工程中都在使用，只不过用的是引用计数的策略而非垃圾收集而已。也就是说，我们使用 C++ 或 C 长期以来就是结合了手工管理和自动管理在构建系统了。无论用引用计数，还是用垃圾收集，软件实现的细节上，该手工管理的地方我们依旧可以手工管理。</p><p>为什么要用资源生命期自动管理？</p><a id="more"></a><p>让我们来看面向对象，如果一切皆对象，每个对象的生命期就应该由自己负责，我们是可以直接准确的死亡时间的。可惜，有很多东西不是纯粹的对象。最重要的一个就是对象容器。它们除了自身的属性，还保持了对一组同类对象的引用。</p><p>一个对象可以分别被几个容器引用，这使得容器区别于猫猫狗狗这些对象实体。因为容器引用一个东西不等于这个东西是这个容器的一部分（有时候可以，有时候不行）。当我们把希望整个世界分成一个个对象时，所有的原子被分到各层的对象上后，就会发现有零零总总的概念无法用对象提取。引用而非拥有，这是无法回避的。</p><p>面向对象的本质在于，对许多对象提取出共性放在一起处理。这样，各式容器的使用就是无可避免的了。</p><p>也正是如此，对象自己并不知道自己是否已经可以宣告死亡。除非了解自己和别的对象的联系（这种关系不是对象）。资源可以是对象，而自动化管理正是管理的这些对象和对象之间的关系。</p><p>引用计数就是最容易实现的一种方案：记录对象被引用的次数，而不具体记录是谁引用了它。这样，降低了建立和解除引用的代价。但是，有得必有失。在引用计数的过程中，我们也丢失了重要的信息：到底是谁引用了自己。所以，引用计数在处理间接引用的问题上代价增加。</p><p>对象死亡的判定是：对象和这个世界还有没有联系，无论是直接的还是间接的。所以，一个对象即使还有另外的对象直接引用它，它也可能已经脱离了世界。为了解决这个问题，使用引用计数的系统，必须在对象和世界脱离联系时，通知和它有关联的对象。对象的销毁代价增加，就是引用计数策略的短板。</p><p>对象的销毁频率，取决于对象的平均生存时间。而对象的生存时间，一方面受对象粒度的影响，往往对象粒度越细，对象平均生存时间越短（虽然表面上没有直接联系，但是实际设计时往往会导致这个结果）；另一方面，我们往往会把容器和引用关系也实现成一种对象（概念上本不应该是对象）。比如说许多自动维持引用计数的智能指针就是一个小容器，里面保持了对一个对象唯一的引用，它就被实现成一个小对象。</p><p>通常，对象本身的性质并不随自己在内存空间中的位置改变而改变。但是引用关系（通常用指针来实现）却和内存地址相关。C++ 缺乏一种对象在内存中移动的语义表达，等价物是，在新的内存块中拷贝构造一个新对象，并销毁原有的。</p><p>另一方面，程序的运行序中，函数调用造成的堆栈上的嵌套作用域也可以看成一个个容器，机器指令穿行于这些作用域间，临时构造出的对对象的引用（智能指针），就被放置于这些作用域内。函数调用越频繁，这些作用域的创建和销毁也就越频繁。</p><p>这些导致了 C++ 必须依赖大量的 inline 函数，让编译器了解更多的上下文信息，方能减轻小对象（智能指针）创建销毁的负担。 STL 库也必须为其做一些优化，例如 stl port 中，对 POD 类型就做了特例化处理。可惜，智能指针不是 POD ，让编译器聪明到合并执行序列中的引用加减，难度太大（考虑到多线程因素，除非编译器可以知道线程的信息，否则几乎不可能实现）。</p><p>C++ 在实现面向对象的编程上，比 C 提供了许多便利。其中之一就是，在描述一个对象是另一个对象的一部分时，通过构造和析构函数机制，可以自动化的维护这相关部分的生命期。但它没能在语言上解决的是，当两者之间只是引用关系时，生命期如何处理。前者，我们有几乎唯一的简洁明了的解决之道；而后者根据实际需要可以有多种选择，顾而 C++ 在语言层面不提供一致解决方案。可惜的是 C++ 却一直每能提供一个简洁好用，带有普适性的 GC 库。大家都偏向于更为容易实现的引用计数的方案，这个结果跟具体实现的复杂度有关。毕竟在实现 gc 的时候，C 缺乏必要的语言支持（而 C++ 在实现层面，是从 C 的基础上发展而来）。</p><hr><p>再来看看垃圾收集，比较成熟的算法基于标记清除（或标记整理）或其变体。简单说，就是由收集器框架记录下对象和对象之间的联系（这些联系信息存放的位置不重要，可以在对象的内存布局空间上，也可以在独立的地方，关键在于这些信息可以被收集器访问）。确定一个世界的根，定期的从这个根开始遍历这个世界，把有关联的对象标记起来，最后回收没有被标记的对象。</p><p>从算法上来看，建立对象和对象之间的联系的时间代价和引用计数的时间代价数量级上是一致的，都是 O(1) 。但实际实现时，前者的代价通常要大一些。空间代价上也是前者略大，但也没有数量级上的差别。</p><p>而 GC 管理的对象，在销毁时的代价要小的多。它不需要通知和它有关联的对象。</p><p>这就是为什么，许多使用 GC 的软件有时候比使用引用计数的软件运行效率还高那么一点的缘故。</p><p>可是，GC 有一个额外的时间代价来源于标记的过程。完成完整的一次清理过程，必然遍历到世界中每一个活着的对象。代价是 O(N) ，N 随着对象总体数量的增加而增加。所以我们应该减少被 GC 管理的对象的数量，在这一点上，手工管理依然有意义。即，明确一个对象是另一个对象的组成部分时，可以考虑用手工管理的方式。</p><p>另一个糟糕的地方是，在实现时，我们往往把对象间的关联信息放在了对象本身的内存布局空间中，遍历这个世界中的对象意味着访问所有对象的内存。当虚拟内存空间大于实际物理内存空间时，这意味着页面交换。我觉得，很大程度上，java 或 C# 这样的语言搭建起来的庞大系统偶尔运行缓慢，根本原因就在这里。当然，这些是可以被改进的。并非算法本身的问题。</p><p>可以这样说，GC (garbage collection) 把 RC (reference counting) 中那些短期对象的销毁代价转嫁到了一次性的标记清除过程。这把逻辑处理和资源管理正交分解了。这种被分解的问题，会随着硬件的进步更容易提高性能（比如多核的发展）。但是，在较小规模的软件或独立模块中，这个优势并不会太明显。反而 GC 本身远高于 RC 的复杂性，会成为其软肋。</p><p>对于不需要面向对象的软件，甚至连资源自动化管理都不需要。这时，无论是 GC 还是 RC 都无用武之地。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://blog.codingnow.com/2008/06/gc.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.codingnow.com/2008/06/gc.html&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;本质上来说，引用计数策略和垃圾收集策略都属于资源的自动化管理。所谓自动化管理，就是在逻辑层不知道资源在什么时候被释放掉，而依赖底层库来维持资源的生命期。&lt;/p&gt;&lt;p&gt;而手工管理，则是可以准确的知道资源的生命期，在准确的位置回收它。在 C++ 中，体现在析构函数中写明 delete 用到的资源，并由编译器自动生成的代码析构基类和成员变量。&lt;/p&gt;&lt;p&gt;所以，为 C++ 写一个垃圾收集器，并不和手工管理资源冲突。自动化管理几乎在所有有点规模的 C++ 工程中都在使用，只不过用的是引用计数的策略而非垃圾收集而已。也就是说，我们使用 C++ 或 C 长期以来就是结合了手工管理和自动管理在构建系统了。无论用引用计数，还是用垃圾收集，软件实现的细节上，该手工管理的地方我们依旧可以手工管理。&lt;/p&gt;&lt;p&gt;为什么要用资源生命期自动管理？&lt;/p&gt;
    
    </summary>
    
    
      <category term="转载" scheme="http://whypro.github.io/hexo-blog/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="垃圾回收" scheme="http://whypro.github.io/hexo-blog/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
      <category term="GC" scheme="http://whypro.github.io/hexo-blog/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>协程的历史，现在和未来</title>
    <link href="http://whypro.github.io/hexo-blog/20160909/%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8E%86%E5%8F%B2%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%92%8C%E6%9C%AA%E6%9D%A5/"/>
    <id>http://whypro.github.io/hexo-blog/20160909/协程的历史，现在和未来/</id>
    <published>2016-09-08T16:30:30.000Z</published>
    <updated>2019-07-04T03:44:51.756Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="http://blog.youxu.info/2014/12/04/coroutine/" target="_blank" rel="noopener">http://blog.youxu.info/2014/12/04/coroutine/</a></p></blockquote><p>本文原发于《程序员》2014年11月刊，发表时略有修改。</p><p>计算机科学是一门应用科学，几乎所有概念都是为了理解或解决实际问题而生的。协程 (Coroutine) 的出现也不例外。协程的概念，最早可以追溯到写作 COBOL 语言编译器中的技术难题。</p><a id="more"></a><h2 id="从磁带到协程"><a href="#从磁带到协程" class="headerlink" title="从磁带到协程"></a>从磁带到协程</h2><p>COBOL 是最早的高级语言之一。编译器则是高级语言必不可少的一部分。现如今，我们对编译器了解，已经到了可以把核心内容浓缩成一本教科书的程度。然而在六十年代，如何写作高效的语言编译器是那个时代绕不过的现实问题。比如，1960 年夏天，D. E. Knuth 就是利用开车横穿美国去加州理工读研究生的时间，对着 <a href="https://www.cs.virginia.edu/brochure/images/manuals/b205/central/central.html" target="_blank" rel="noopener">Burroughs 205</a> 机器指令集手写 COBOL 编译器。最早提出“协程”概念的 Melvin Conway 的出发点，也是如何写一个只扫描一遍程序 (one-pass) 的 COBOL 编译器。众多的“高手”纷纷投入编译器书写，可见一门新科学发展之初也是筚路蓝缕</p><p>以现代眼光来看，高级语言编译器实际上是多个步骤组合而成：词法解析，语法解析，语法树构建，以及优化和目标代码生成等等。编译实质上就是从源程序出发，依次将这些步骤的输出作为下一步的输入，最终输出目标代码。在现代计算机上实现这种管道式的架构毫无困难：只需要依次运行，中间结果存为中间文件或放入内存即可。GCC 和 Clang 编译器，以及 <a href="http://www.antlr.org/" target="_blank" rel="noopener">ANTLR</a> 构建的编译器，都遵循这样的设计。</p><p>在 Conway 的设计里，词法和语法解析不再是两个独立运行的步骤，而是交织在一起。编译器的控制流在词法和语法解析之间来回切换：当词法模块读入足够多的 token 时，控制流交给语法分析；当语法分析消化完所有 token 后，控制流交给词法分析。词法和语法分别独立维护自身的运行状态。Conway 构建的这种协同工作机制，需要参与者“让出 (yield)”控制流时，记住自身状态，以便在控制流返回时能够从上次让出的位置恢复(resume)执行。简言之，协程的全部精神就在于控制流的主动让出和恢复。我们熟悉的子过程调用可以看作在返回时让出控制流的一种特殊的协程，其内部状态在返回时被丢弃了，因此不存在“恢复”这个操作。</p><p>以现在眼光来看，编译器的实现并不必然需要协程。然而，Conway 用协程实现 COBOL 编译器在当时绝不是舍近求远。首先，从原理上来说，因为 COBOL 并不是 <a href="https://en.wikipedia.org/wiki/LL_parser" target="_blank" rel="noopener">LL(1)</a> 型语法，即使现在我们也无法简单构建一个以词法分析为子过程的自动机。其次，当年计算机依赖于磁带存储设备，而磁带存储设备只支持顺序存储（设想一下随机访问带来的频繁的倒带和快进问题）。也就是说，依次执行编译步骤并依靠中间文件通信的设计是不现实的，各步骤必须同步前进。正是这样的现实局限和设计需要，自然催生了协程的概念。</p><h2 id="自顶向下，无需协同"><a href="#自顶向下，无需协同" class="headerlink" title="自顶向下，无需协同"></a>自顶向下，无需协同</h2><p>虽然协程是伴随着高级语言诞生的，它却没有能像子过程一样成为通用编程语言的基本元素。</p><p>从 1963 年首次提出到上个世纪九十年代，我们在 ALOGL, Pascal, C, FORTRAN 等主流的命令式编程语言中都没有看到原生的协程支持。协程只稀疏地出现在 Simula，Modular-2 (Pascal 升级版) 和 Smalltalk 等相对小众的语言中。协程作为一个比子进程更加通用的概念，在实际编程却没有取代子进程，这一点不得不说是出乎意外的。如果我们结合当时的程序设计思想看，这一点又是意料之中的：协程是不符合那个时代所崇尚的“自顶向下”的程序设计思想的，自然也就不会成为当时主流的命令式编程语言 (imperative programming) 的一部分。</p><p>正如面向对象的语言是围绕面向对象的开发理念设计一样，命令式编程语言是围绕自顶向下(top-down)的开发理念设计的。在自顶向下的理念指导下，程序被切分为一个主程序和大大小小的子模块，每一个子模块又可能调用更多子模块等等。C 家族语言的 main() 函数就是这种自顶而下思想的体现。在这种理念指导下，各模块形成层次调用关系，而程序设计就是制作这些子过程。在“自顶向下”这种层次化的理念下，具有鲜明层次的子过程调用成为软件系统最自然的组织方式，也是理所当然。相较之下，具有执行中让出和恢复功能的协程在这种架构下无用武之地。可以说，自上而下的设计思想从一开始就排除了对协程的需求。其后的结构化编程(Structural Programming) 思想，更是进一步强化了“子过程调用作为唯一控制结构”的基本假设。在这样的指导思想下，协程一直没有成为当时编程语言的一等公民。</p><p>尽管从提出到上世纪 90 年代，协程在编程语言中没有普遍成为一等公民，但作为一种易于理解的控制结构，协程的概念渗入到了软件设计的许多方面。在结构化编程思想一统天下之时， D. Knuth 曾经专门写过一篇 <a href="http://c2.com/cgi/wiki?StructuredProgrammingWithGoToStatements" target="_blank" rel="noopener">“ Structured Programming with GOTO ”</a> 来为 GOTO 语句辩护。在他列出的几条 GOTO 可以方便编程且不破坏程序结构的例子中，有一个（例子7b）就是用 GOTO 实现协程控制结构。相比较之下，不用 GOTO 的“结构化”代码反而失去了良好的结构。当然，追求实际结果的工业界对于学界的这场要不要剔除 GOTO 的争论并不感冒。当时许多语言都附带了不建议使用的 GOTO 语句，显得左右逢源。这方面一个最明显的例子就是 Java：其语言本身预留了 goto 关键字，其编译器却没有提供任何的支持，可以说在 goto 这场争论中做足了中间派。</p><p>实践中，协程的思想频繁应用于任务调度和流处理上。比如，UNIX 管道就可以看成是众多命令间的协同操作。当然，管道的现代实现都是以 pipe() 系统调用和进程间的通信为基础，而非简单遵循协程的 yield/resume 语法。</p><p>许多协同式多任务操作系统，也可以看成协程运行系统。说到协同式多任务系统，一个常见的误区是认为协同式调度比抢占式调度“低级”，因为我们所熟悉的桌面操作系统，都是从协同式调度（如 Windows 3.2， Mac OS 9 等）过渡到抢占式多任务系统的。实际上，调度方式并无高下，完全取决于应用场景。抢占式系统允许操作系统剥夺进程执行权限，抢占控制流，因而天然适合服务器和图形操作系统，因为调度器可以优先保证对用户交互和网络事件的快速响应。当年 Windows 95 刚刚推出的时候，抢占式多任务就被作为一大买点大加宣传。协同式调度则等到进程时间片用完或系统调用时转移执行权限，因此适合实时或分时等等对运行时间有保障的系统。</p><p>另外，抢占式系统依赖于 CPU 的硬件支持。 因为调度器需要“剥夺”进程的执行权，就意味着调度器需要运行在比普通进程高的权限上，否则任何“流氓（rogue）”进程都可以去剥夺其他进程了。只有 CPU 支持了执行权限后，抢占式调度才成为可能。x86 系统从 80386 处理器开始引入 Ring 机制支持执行权限，这也是为何 Windows 95 和 Linux 其实只能运行在 80386 之后的 x86 处理器上的原因。而协同式多任务适用于那些没有处理器权限支持的场景，这些场景包含资源受限的嵌入式系统和实时系统。在这些系统中，程序均以协程的方式运行。调度器负责控制流的让出和恢复。通过协程的模型，无需硬件支持，我们就可以在一个“简陋”的处理器上实现一个多任务的系统。我们见到的许多智能设备，如运动手环，基于硬件限制，都是采用协同调度的架构。</p><h2 id="协程的复兴和现代形式"><a href="#协程的复兴和现代形式" class="headerlink" title="协程的复兴和现代形式"></a>协程的复兴和现代形式</h2><p>编程思想能否普及开来，很大程度上在于应用场景。协程没有能在自顶向下的世界里立足，却在动态语言世界里大放光彩，这里最显著的例子莫过于 Python 的迭代器和生成器。</p><p>回想一下在 C 的世界里，循环的标准写法是 <code>for (i = 0; i &lt; n; ++i) { … }</code>。 这行代码包含两个独立的逻辑, <code>for</code> 循环控制了 <code>i</code> 的边界条件， <code>++i</code> 控制了 <code>i</code> 的自增逻辑。这行代码适用于 C 世界里的数组即内存位移的范式，因此适合大多数访问场景。到了 STL 和复杂数据结构的世界，因为许多数据结构只支持顺序访问，循环往往写成：<code>for (i = A.first(); i.hasNext();i = i.next()) { … }</code></p><p>这种设计抽象出了一个独立于数据结构的迭代器，专门负责数据结构上元素访问顺序。迭代器把访问逻辑从数据结构上分离出来, 是一个常用的设计模式 （GoF 23个设计模式之一）.我们在 STL 和 Java Collection 中也常常看到迭代器的身影。</p><p>在适当的时候，我们可以更进一步引入一个语法糖（脚注：这里牵涉到一个外部迭代器和内部迭代器的问题。限于篇幅不在此讨论）将循环写成: <code>for i in A.Iterator() {func(i)}</code>。</p><p>事实上，许多现代语言都支持类似的语法。这种语法抛弃了以 <code>i</code> 变量作为迭代指针的功能，要求迭代器自身能够记住当前迭代位置，调用时返回下一个元素。读者不难看到，这种架构就是我们在文章开始提到的语法分析器的架构。正因为如此，我们可以从协程的角度来理解迭代器：当控制流转换到迭代器上时，迭代器负责生成和返回下一个元素。一旦下一个元素准备就绪，迭代器就让出控制流。这种特殊的迭代器实现在 Python 中又被成为生成器。以协程的角度切入的的好处是设计大大精简。实际上，在 Python 中，生成器本身就是一个普通的函数，和普通函数的唯一不同是它的返回语句是协程风格的 <code>yield</code>。这里，<code>yield</code> 一语双关，既是让出控制流，也是生成迭代器的返回值。</p><p>以上我们仅仅讨论了生成器的最基本的特性。实际上，生成器的强大之处在于我们可以像 UNIX 管道一样串联起来，组成所谓的生成器表达式。如果我们有一个可以生成 <code>1，2，3 …</code> 的生成器 <code>N</code>，则 <code>square = (i \*\*2 for i in N)</code> 就是一个生成平方数的生成器表达式。注意这里圆括号语法和 <a href="http://en.wikipedia.org/wiki/List_comprehension" target="_blank" rel="noopener">list comprehension</a> 方括号语法的区别，<code>square = [i \*\*2 for i in N]</code> 是生成一个具体的列表。我们可以串联这些生成器表达式，最终的控制流会在这些串联的部分间转换，无需我们写作复杂的嵌套调用。当然，<code>yield</code> 只是冰山的一角，现代的 Python 语言还充分利用了 <code>yield</code> 关键字构建了 <a href="https://www.python.org/dev/peps/pep-0380/" target="_blank" rel="noopener">yield from</a> 语句，<code>(yield)</code> 语法等等，使得我们无困难的将协程的思想融入到 Python 编程中去。限于篇幅这里不再展开。</p><p>我们前面说过，协程的思想本质上就是控制流的主动让出和恢复机制。在现代语言里，可以实现协程思想的方法很多，这些实现间并无高下之分，所区别的就是是否适合应用场景。理解这一点，我们对于各种协程的分类，如半对称/对称协程，有栈与无栈协程等具体实现就能提纲挈领，无需在实现细节上纠结。</p><p>协程在实践中的实现方式千差万别，一个简单的原因，是协程本身可以通过许多基本元素构建。基本元素的选取方式不一样，构建出来的协程抽象也就有差别。比如, Lua 语言选取了 <code>create</code>, <code>resume</code> 和 <code>yield</code> 作为基本构建元素, 从调度器层面构建出所谓的“非对程”协程系统。而 Julia 语言绕过调度器，通过在协程内调用 <code>yieldto</code> 函数完成了同样的功能，构建出了一个所谓的对称协程系统。尽管这两个语言使用了同样的 <code>setjmp</code> 库，构造出来的原语却不一样。又比如，许多 C 语言的协程库都使用了 <code>ucontext</code> 库实现，这是因为 POSIX 本身提供了 <code>ucontext</code> 库，不少协程实现是以 <code>ucontext</code> 为蓝本实现的。这些实现，都不可避免地带上了 <code>ucontext</code> 系统的一些基本假设，比如协程间是平等的，一般带有调度器来协调协程等等（比如 <a href="http://swtch.com/libtask/" target="_blank" rel="noopener">libtask</a> 实现，以及 <a href="http://blog.codingnow.com/2012/07/c_coroutine.html" target="_blank" rel="noopener">云风的 coroutine 库</a> ）。Go 语言的一个鲜明特色就是通道（<code>channel</code>）作为一级对象。因此，<code>resume</code> 和 <code>yield</code> 等在其他语言里的原语在 go 里都以通道方式构建。我们还可以举出许多同样的例子。这些风格的差异往往和语言的历史，演化路径，和要解决的问题相关，我们不必苛求他们的协程模型一定要如此这般。</p><p>总的来说，协程为协同任务提供了一种运行时抽象。这种抽象非常适合于协同多任务调度和数据流处理。在现代操作系统和编程语言中，因为用户态线程切换代价比内核态线程小，协程成为了一种轻量级的多任务模型。我们无法预测未来，但是可以看到，协程已经成为许多擅长数据处理的语言的一级对象。随着计算机并行性能的提升，用户态任务调度已经成为一种标准的多任务模型。在这样的大趋势下，协程这个简单且有效的模型就显得更加引人注目。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://blog.youxu.info/2014/12/04/coroutine/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.youxu.info/2014/12/04/coroutine/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;本文原发于《程序员》2014年11月刊，发表时略有修改。&lt;/p&gt;&lt;p&gt;计算机科学是一门应用科学，几乎所有概念都是为了理解或解决实际问题而生的。协程 (Coroutine) 的出现也不例外。协程的概念，最早可以追溯到写作 COBOL 语言编译器中的技术难题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="转载" scheme="http://whypro.github.io/hexo-blog/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="协程" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>IO 设计模式：Reactor 和 Proactor 对比</title>
    <link href="http://whypro.github.io/hexo-blog/20160909/IO-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9AReactor-%E5%92%8C-Proactor-%E5%AF%B9%E6%AF%94/"/>
    <id>http://whypro.github.io/hexo-blog/20160909/IO-设计模式：Reactor-和-Proactor-对比/</id>
    <published>2016-09-08T16:30:27.000Z</published>
    <updated>2019-07-04T03:44:51.753Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="https://segmentfault.com/a/1190000002715832" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002715832</a><br>Posted by: 大CC | 28APR,2015<br>博客：<a href="http://blog.me115.com/" target="_blank" rel="noopener">blog.me115.com</a> [<a href="http://feed.feedsky.com/me115" target="_blank" rel="noopener">订阅</a>]<br>微博：<a href="http://weibo.com/bigcc115" target="_blank" rel="noopener">新浪微博</a></p></blockquote><p>平时接触的开源产品如Redis、ACE，事件模型都使用的Reactor模式；而同样做事件处理的Proactor，由于操作系统的原因，相关的开源产品也少；这里学习下其模型结构，重点对比下两者的异同点；</p><h2 id="反应器Reactor"><a href="#反应器Reactor" class="headerlink" title="反应器Reactor"></a>反应器Reactor</h2><h3 id="Reactor模式结构"><a href="#Reactor模式结构" class="headerlink" title="Reactor模式结构"></a>Reactor模式结构</h3><a id="more"></a> <img src="/hexo-blog/20160909/IO-设计模式：Reactor-和-Proactor-对比/bVlyFO"><p>Reactor包含如下角色：</p><ul><li>Handle 句柄；用来标识socket连接或是打开文件；</li><li>Synchronous Event Demultiplexer：同步事件多路分解器：由操作系统内核实现的一个函数；用于阻塞等待发生在句柄集合上的一个或多个事件；（如select/epoll；）</li><li>Event Handler：事件处理接口</li><li>Concrete Event HandlerA：实现应用程序所提供的特定事件处理逻辑；</li><li>Reactor：反应器，定义一个接口，实现以下功能：<ol><li>供应用程序注册和删除关注的事件句柄；</li><li>运行事件循环；</li><li>有就绪事件到来时，分发事件到之前注册的回调函数上处理；</li></ol></li></ul><p>“反应”器名字中”反应“的由来：</p><blockquote><p>“反应”即“倒置”，“控制逆转”</p></blockquote><p>具体事件处理程序不调用反应器，而是由反应器分配一个具体事件处理程序，具体事件处理程序对某个指定的事件发生做出反应；这种控制逆转又称为“好莱坞法则”（不要调用我，让我来调用你）</p><h3 id="业务流程及时序图"><a href="#业务流程及时序图" class="headerlink" title="业务流程及时序图"></a>业务流程及时序图</h3><img src="/hexo-blog/20160909/IO-设计模式：Reactor-和-Proactor-对比/bVlyFP"><ol><li>应用启动，将关注的事件handle注册到Reactor中；</li><li>调用Reactor，进入无限事件循环，等待注册的事件到来；</li><li>事件到来，select返回，Reactor将事件分发到之前注册的回调函数中处理；</li></ol><h2 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h2><h3 id="Proactor模式结构"><a href="#Proactor模式结构" class="headerlink" title="Proactor模式结构"></a>Proactor模式结构</h3><img src="/hexo-blog/20160909/IO-设计模式：Reactor-和-Proactor-对比/bVlyFQ"><p>Proactor主动器模式包含如下角色</p><ul><li>Handle 句柄；用来标识socket连接或是打开文件；</li><li>Asynchronous Operation Processor：异步操作处理器；负责执行异步操作，一般由操作系统内核实现；</li><li>Asynchronous Operation：异步操作</li><li>Completion Event Queue：完成事件队列；异步操作完成的结果放到队列中等待后续使用</li><li>Proactor：主动器；为应用程序进程提供事件循环；从完成事件队列中取出异步操作的结果，分发调用相应的后续处理逻辑；</li><li>Completion Handler：完成事件接口；一般是由回调函数组成的接口；</li><li>Concrete Completion Handler：完成事件处理逻辑；实现接口定义特定的应用处理逻辑；</li></ul><h3 id="业务流程及时序图-1"><a href="#业务流程及时序图-1" class="headerlink" title="业务流程及时序图"></a>业务流程及时序图</h3><img src="/hexo-blog/20160909/IO-设计模式：Reactor-和-Proactor-对比/bVlyFR"><ol><li>应用程序启动，调用异步操作处理器提供的异步操作接口函数，调用之后应用程序和异步操作处理就独立运行；应用程序可以调用新的异步操作，而其它操作可以并发进行；</li><li>应用程序启动Proactor主动器，进行无限的事件循环，等待完成事件到来；</li><li>异步操作处理器执行异步操作，完成后将结果放入到完成事件队列；</li><li>主动器从完成事件队列中取出结果，分发到相应的完成事件回调函数处理逻辑中；</li></ol><h2 id="对比两者的区别"><a href="#对比两者的区别" class="headerlink" title="对比两者的区别"></a>对比两者的区别</h2><h3 id="主动和被动"><a href="#主动和被动" class="headerlink" title="主动和被动"></a>主动和被动</h3><p>以主动写为例：</p><ul><li>Reactor将handle放到select()，等待可写就绪，然后调用write()写入数据；写完处理后续逻辑；</li><li>Proactor调用aoi_write后立刻返回，由内核负责写操作，写完后调用相应的回调函数处理后续逻辑；</li></ul><p>可以看出，Reactor被动的等待指示事件的到来并做出反应；它有一个等待的过程，做什么都要先放入到监听事件集合中等待handler可用时再进行操作；</p><p>Proactor直接调用异步读写操作，调用完后立刻返回；</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>Reactor实现了一个被动的事件分离和分发模型，服务等待请求事件的到来，再通过不受间断的同步处理事件，从而做出反应；</p><p>Proactor实现了一个主动的事件分离和分发模型；这种设计允许多个任务并发的执行，从而提高吞吐量；并可执行耗时长的任务（各个任务间互不影响）</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>Reactor实现相对简单，对于耗时短的处理场景处理高效；</p><p>操作系统可以在多个事件源上等待，并且避免了多线程编程相关的性能开销和编程复杂性；</p><p>事件的串行化对应用是透明的，可以顺序的同步执行而不需要加锁；</p><p>事务分离：将与应用无关的多路分解和分配机制和与应用相关的回调函数分离开来，</p><p>Proactor性能更高，能够处理耗时长的并发场景；</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>Reactor处理耗时长的操作会造成事件分发的阻塞，影响到后续事件的处理；</p><p>Proactor实现逻辑复杂；依赖操作系统对异步的支持，目前实现了纯异步操作的操作系统少，实现优秀的如windows IOCP，但由于其windows系统用于服务器的局限性，目前应用范围较小；而Unix/Linux系统对纯异步的支持有限，应用事件驱动的主流还是通过select/epoll来实现；</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>Reactor：同时接收多个服务请求，并且依次同步的处理它们的事件驱动程序；</p><p>Proactor：异步接收和同时处理多个服务请求的事件驱动程序；</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《面向模式的软件体系结构 卷2》<br>《面向模式的软件架构 卷4》</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;原文地址：&lt;a href=&quot;https://segmentfault.com/a/1190000002715832&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190000002715832&lt;/a&gt;&lt;br&gt;Posted by: 大CC | 28APR,2015&lt;br&gt;博客：&lt;a href=&quot;http://blog.me115.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;blog.me115.com&lt;/a&gt; [&lt;a href=&quot;http://feed.feedsky.com/me115&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;订阅&lt;/a&gt;]&lt;br&gt;微博：&lt;a href=&quot;http://weibo.com/bigcc115&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;新浪微博&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;平时接触的开源产品如Redis、ACE，事件模型都使用的Reactor模式；而同样做事件处理的Proactor，由于操作系统的原因，相关的开源产品也少；这里学习下其模型结构，重点对比下两者的异同点；&lt;/p&gt;&lt;h2 id=&quot;反应器Reactor&quot;&gt;&lt;a href=&quot;#反应器Reactor&quot; class=&quot;headerlink&quot; title=&quot;反应器Reactor&quot;&gt;&lt;/a&gt;反应器Reactor&lt;/h2&gt;&lt;h3 id=&quot;Reactor模式结构&quot;&gt;&lt;a href=&quot;#Reactor模式结构&quot; class=&quot;headerlink&quot; title=&quot;Reactor模式结构&quot;&gt;&lt;/a&gt;Reactor模式结构&lt;/h3&gt;
    
    </summary>
    
    
      <category term="转载" scheme="http://whypro.github.io/hexo-blog/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="非阻塞" scheme="http://whypro.github.io/hexo-blog/tags/%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    
      <category term="NIO" scheme="http://whypro.github.io/hexo-blog/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>各种相纸比较</title>
    <link href="http://whypro.github.io/hexo-blog/20151015/%E5%90%84%E7%A7%8D%E7%9B%B8%E7%BA%B8%E6%AF%94%E8%BE%83/"/>
    <id>http://whypro.github.io/hexo-blog/20151015/各种相纸比较/</id>
    <published>2015-10-15T03:10:00.000Z</published>
    <updated>2019-07-04T03:44:51.753Z</updated>
    
    <content type="html"><![CDATA[<p>最近在某宝上用不同相纸冲印了一些照片，觉得效果还是有一些差异的，现在具体对比一下，以供各位朋友日后参考，同时也作为自己的一个记录。</p><p>第一次冲洗我使用了【富士晶彩光面】、【富士金冠绒面】和【柯达皇家绒面】这三种类型的相纸。</p><a id="more"></a><p>首先介绍一下光面与绒面的区别：</p><ul><li><p>光面看起来更加鲜艳亮丽，但是容易留下指纹和划痕，因此个人认为适合风景等需要对色彩表现较高的照片。</p></li><li><p>绒面看起来柔和一些，更高档，但是有颗粒感，因此个人认为适合人像，静物等对局部细节要求较高的照片。</p></li></ul><p>其次，富士相纸和柯达相纸在色彩表现上的区别有：</p><ul><li><p>富士相纸对冷色调的表现更好，因此更适合风景等。</p></li><li><p>柯达相纸对暖色调的表现更好，因此更适合人像等。</p></li></ul><p>最后，说一下这三种相纸的区别：</p><ul><li>【富士晶彩光面】厚度最薄，但很有弹性。</li></ul><p>【富士金冠绒面】和【柯达皇家绒面】这两种虽然都是绒面，但是也有细微区别：</p><ul><li>【富士金冠绒面】的颗粒感较小，对光线的反射不太明显，厚度一般。</li><li>【柯达皇家绒面】的颗粒感较大，对光线的反射更明显，更厚一些。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在某宝上用不同相纸冲印了一些照片，觉得效果还是有一些差异的，现在具体对比一下，以供各位朋友日后参考，同时也作为自己的一个记录。&lt;/p&gt;&lt;p&gt;第一次冲洗我使用了【富士晶彩光面】、【富士金冠绒面】和【柯达皇家绒面】这三种类型的相纸。&lt;/p&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="摄影" scheme="http://whypro.github.io/hexo-blog/tags/%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>连连看游戏消除算法</title>
    <link href="http://whypro.github.io/hexo-blog/20150721/%E8%BF%9E%E8%BF%9E%E7%9C%8B%E6%B8%B8%E6%88%8F%E6%B6%88%E9%99%A4%E7%AE%97%E6%B3%95/"/>
    <id>http://whypro.github.io/hexo-blog/20150721/连连看游戏消除算法/</id>
    <published>2015-07-21T12:29:37.000Z</published>
    <updated>2019-06-02T09:10:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在收到一道的面试题，觉得比较有意思，决定记录下来，整个题目与解答过程大概如下。</p><p>连连看是一种很受大家欢迎的小游戏。下面四张图给出了最基本的消除规则：</p><a id="more"></a> <img src="/hexo-blog/20150721/连连看游戏消除算法/0.png"><p>图 A 中出现在同一直线上无障碍的圈圈可以消除；图 B 中两个圈圈可以通过一次转弯消除；图 C 和图 D 中，两个圈圈可以通过两次转弯消除。</p><p>已知以下接口，表示位置(x, y)上有无障碍物：</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isBlocked</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;       <span class="hljs-comment">// 无障碍物（位置(x,y)为空）</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;       <span class="hljs-comment">// 有障碍物（位置(x,y)上有方块或圈圈）</span></span><br></pre></td></tr></table></figure><p>请写一个函数来判断给定的任意两个圈圈是否可消除（x1, y1与x2, y2为两个圈圈的位置）：</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> y2)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="水平检测"><a href="#水平检测" class="headerlink" title="水平检测"></a>水平检测</h2><p>水平检测用来判断两个点的纵坐标是否相等，同时判断两点间有没有障碍物。</p><img src="/hexo-blog/20150721/连连看游戏消除算法/1.png"><p>因此直接检测两点间是否有障碍物就可以了，代码如下：</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">horizon</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> y2)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (x1 == x2 &amp;&amp; y1 == y2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (x1 != x2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">int</span> start_y = <span class="hljs-built_in">std</span>::min(y1, y2)</span><br><span class="line">    <span class="hljs-keyword">int</span> end_y = <span class="hljs-built_in">std</span>::max(y1, y2);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = start_y; j &lt; end_y; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (isBlocked(x1, j))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="垂直检测"><a href="#垂直检测" class="headerlink" title="垂直检测"></a>垂直检测</h2><p>垂直检测用来判断两个点的横坐标是否相等，同时判断两点间有没有障碍物。</p><img src="/hexo-blog/20150721/连连看游戏消除算法/2.png"><p>同样地，直接检测两点间是否有障碍物，代码如下：</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">vertical</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> y2)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (x1 == x2 &amp;&amp; y1 == y2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (y1 != y2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">int</span> start_x = <span class="hljs-built_in">std</span>::min(x1, x2);</span><br><span class="line">    <span class="hljs-keyword">int</span> end_x = <span class="hljs-built_in">std</span>::max(x1, x2);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start_x; i &lt; end_x; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (isBlocked(i, y1))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个拐角检测"><a href="#一个拐角检测" class="headerlink" title="一个拐角检测"></a>一个拐角检测</h2><p>一个拐角检测可分解为水平检测和垂直检测，当两个同时满足时，便两点可通过一个拐角相连。即：</p><p>一个拐角检测 = 水平检测 &amp;&amp; 垂直检测</p><img src="/hexo-blog/20150721/连连看游戏消除算法/3.png"><p>A 点至 B 点能否连接可转化为满足任意一点：</p><ol><li><p>A 点至 C 点的垂直检测，以及 C 点至 B 点的水平检测；</p></li><li><p>A 点至 D 点的水平检测，以及 D 点至 B 点的垂直检测。</p></li></ol><p>代码如下：</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">turn_once</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> y2)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (x1 == x2 &amp;&amp; y1 == y2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">int</span> c_x = x1, c_y = y2;</span><br><span class="line">    <span class="hljs-keyword">int</span> d_x = x2, d_y = y1;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">int</span> ret = <span class="hljs-literal">false</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!isBlocked(c_x, c_y))</span><br><span class="line">    &#123;</span><br><span class="line">        ret |= horizon(x1, y1, c_x, c_y) &amp;&amp; vertical(c_x, c_y, x2, y2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (!isBlocked(d_x, d_y))</span><br><span class="line">    &#123;</span><br><span class="line">        ret |= horizon(x1, y1, d_x, d_y) &amp;&amp; vertical(d_x, d_y, x2, y2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两个拐角检测"><a href="#两个拐角检测" class="headerlink" title="两个拐角检测"></a>两个拐角检测</h2><p>两个拐角检测可分解为一个拐角检测和水平检测或垂直检测。即：</p><p>两个拐角检测 = 一个拐角检测 &amp;&amp; (水平检测 || 垂直检测)</p><img src="/hexo-blog/20150721/连连看游戏消除算法/4.png"><p>如图，水平、垂直分别穿过 A B 共有四条直线，扫描直线上所有不包含 A B 的点，看是否存在一点 C ，满足以下任意一项：</p><ol><li><p>A 点至 C 点通过水平或垂直检测，C 点至 B 点可通过一个拐角连接。（图中用 C 表示）</p></li><li><p>A 点至 C 点可通过一个拐角连接，C 点至 B 点通过水平或垂直连接。（图中用 C 下划线表示）</p></li></ol><p>代码如下：</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">turn_twice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> y2)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (x1 == x2 &amp;&amp; y1 == y2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= MAX_X; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= MAX_Y; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (i != x1 &amp;&amp; i != x2 &amp;&amp; j != y1 &amp;&amp; j != y2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> ((i == x1 &amp;&amp; j == y1) || (i == x2 &amp;&amp; j == y2))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> (isBlocked(i, j))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> (turn_once(x1, y1, i, j) &amp;&amp; (horizon(i, j, x2, y2) || vertical(i, j, x2, y2)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> (turn_once(i, j, x2, y2) &amp;&amp; (horizon(x1, y1, i, j) || vertical(x1, y1, i, j)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h2><p>最后，整合以上四种情况，判断两点是否能消除的代码可以写成：</p><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> y2)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> ret = <span class="hljs-literal">false</span>;</span><br><span class="line"></span><br><span class="line">    ret = horizon(x1, y1, x2, y2);</span><br><span class="line">    <span class="hljs-keyword">if</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = vertical(x1, y1, x2, y2);</span><br><span class="line">    <span class="hljs-keyword">if</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = turn_once(x1, y1, x2, y2);</span><br><span class="line">    <span class="hljs-keyword">if</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = turn_twice(x1, y1, x2, y2);</span><br><span class="line">    <span class="hljs-keyword">if</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在收到一道的面试题，觉得比较有意思，决定记录下来，整个题目与解答过程大概如下。&lt;/p&gt;&lt;p&gt;连连看是一种很受大家欢迎的小游戏。下面四张图给出了最基本的消除规则：&lt;/p&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="算法" scheme="http://whypro.github.io/hexo-blog/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="连连看" scheme="http://whypro.github.io/hexo-blog/tags/%E8%BF%9E%E8%BF%9E%E7%9C%8B/"/>
    
      <category term="游戏" scheme="http://whypro.github.io/hexo-blog/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
</feed>
