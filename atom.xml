<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EVERLASTING</title>
  
  
  <link href="/hexo-blog/atom.xml" rel="self"/>
  
  <link href="http://whypro.github.io/hexo-blog/"/>
  <updated>2020-05-02T14:33:00.000Z</updated>
  <id>http://whypro.github.io/hexo-blog/</id>
  
  <author>
    <name>whypro</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>云聪金融交易分析入门笔记</title>
    <link href="http://whypro.github.io/hexo-blog/20200420/%E4%BA%91%E8%81%AA%E9%87%91%E8%9E%8D%E4%BA%A4%E6%98%93%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://whypro.github.io/hexo-blog/20200420/云聪金融交易分析入门笔记/</id>
    <published>2020-04-20T15:49:00.000Z</published>
    <updated>2020-05-02T14:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="01-金融交易入门"><a href="#01-金融交易入门" class="headerlink" title="01 金融交易入门"></a>01 金融交易入门</h2><p>迷宫理论</p><p>A 基本面分析<br>B 道氏理论<br>C 江恩理论<br>E 破浪理论<br>F 盘口<br>G 指标</p><p>大师<br>骗子<br>偏执狂</p><p><a href="https://www.youtube.com/watch?v=Jy6mkzDsbmE" target="_blank" rel="noopener">https://www.youtube.com/watch?v=Jy6mkzDsbmE</a></p><h2 id="02-基本面、技术、盘口"><a href="#02-基本面、技术、盘口" class="headerlink" title="02 基本面、技术、盘口"></a>02 基本面、技术、盘口</h2><p>基本面：全球、行业、市盈率、财务、天气、供求、政策<br>技术面：</p><ol><li>道氏理论：趋势线、形态、位置</li><li>波浪理论：认识、划分、分型</li><li>江恩理论：时间、周期、28条、占星</li><li>其他：点位、箱子、缠论<br>指标派：MACD、KDJ、RAS<br>盘口分析（炒单）</li></ol><p>交易方法：中长线，短线，日内，超短线</p><p>交易心理</p><p><a href="https://www.youtube.com/watch?v=bgZBeaa3H6Y" target="_blank" rel="noopener">https://www.youtube.com/watch?v=bgZBeaa3H6Y</a></p><a id="more"></a><h2 id="03-股票及其历史"><a href="#03-股票及其历史" class="headerlink" title="03 股票及其历史"></a>03 股票及其历史</h2><ol><li>股票：有价证券</li><li><p>历史<br>起源于 1602 年荷兰，东印度公司<br>牛顿 1720 年买入南海公司，亏损 5万英镑<br>丘吉尔 1929 年，大萧条，大亏</p></li><li><p>中国：<br>1872 年，招商局，第一支股票<br>1920/1921 上海，蒋介石，陈果夫，大亏，黄金荣</p></li></ol><ol start="4"><li>A股特点：T+1，10% 涨停，不能做空</li><li>美股特点：T+0，无涨停（有熔断），可做空（双向）</li></ol><p><a href="https://www.youtube.com/watch?v=HIFQkF4Wi2o" target="_blank" rel="noopener">https://www.youtube.com/watch?v=HIFQkF4Wi2o</a></p><h2 id="04-什么是-T-1？如何做成-T-0？"><a href="#04-什么是-T-1？如何做成-T-0？" class="headerlink" title="04 什么是 T+1？如何做成 T+0？"></a>04 什么是 T+1？如何做成 T+0？</h2><p>当日交易的证券隔日才能交易<br>问题：早盘午盘买容易被套<br>方案：尽量在下午收盘前买</p><p>如何将 T+1 做成 T+0<br>底仓+滚动</p><p><a href="https://www.youtube.com/watch?v=id4J8z8lyD8" target="_blank" rel="noopener">https://www.youtube.com/watch?v=id4J8z8lyD8</a></p><h2 id="05-涨停跌停"><a href="#05-涨停跌停" class="headerlink" title="05 涨停跌停"></a>05 涨停跌停</h2><p>定义：每日涨跌上限（正常：10%；ST（连续2年亏损）：5%）<br>目的：降低市场波动，保护小股东利益<br>原因：重大利好利空，主力控盘<br>意义：趋势交易者判断趋势的利器，主力资金冲锋号角，涨停位置非常关键</p><p>一字涨停：吸货、出货</p><p>（暴风影音、长生）</p><p><a href="https://www.youtube.com/watch?v=WC2K5-zdmA4" target="_blank" rel="noopener">https://www.youtube.com/watch?v=WC2K5-zdmA4</a></p><h2 id="06-ST股"><a href="#06-ST股" class="headerlink" title="06 ST股"></a>06 ST股</h2><p>ST：连续两年亏损<br>*ST：连续三年亏损<br>摘帽，摘星：三项指标为正（净资产、市盈率、……）<br>乌鸡变凤凰：资产重组，卖壳资源</p><p>（ST聚酯 -&gt; 广晟有色）</p><p><a href="https://www.youtube.com/watch?v=airgZmhAbBg" target="_blank" rel="noopener">https://www.youtube.com/watch?v=airgZmhAbBg</a></p><h2 id="07-什么是期货？期货的历史？"><a href="#07-什么是期货？期货的历史？" class="headerlink" title="07 什么是期货？期货的历史？"></a>07 什么是期货？期货的历史？</h2><p>现货：一手交钱一手交货<br>期货：一手交钱（订金）一手交合同（交货时间、地点、数量、价格）</p><p>历史：<br>1848 年美国芝加哥，48 名商人组成交易市场（水、陆、铁路、商品集散地）<br>大豆农场主，年初预算，出售合约（明年3月份，1吨大豆，5000人民币）</p><p>特点：</p><ol><li>保证金制度（杠杆）：买 10 万，只需 1万（10%）</li><li>双向交易（做多，做空）<br>人性夸大：小钱大赚；巨资巨亏（99%）</li></ol><p>举例：</p><ol><li>中国 327 国债事件</li><li>搞垮200年银行（巴黎银行）</li><li>索罗斯</li></ol><p><a href="https://www.youtube.com/watch?v=-KnwjmuaC_8" target="_blank" rel="noopener">https://www.youtube.com/watch?v=-KnwjmuaC_8</a></p><h2 id="08-做空是投机吗？为什么要做空？"><a href="#08-做空是投机吗？为什么要做空？" class="headerlink" title="08 做空是投机吗？为什么要做空？"></a>08 做空是投机吗？为什么要做空？</h2><p>价值投资？（美股）<br>做空投机？（A股、期货）</p><p><a href="https://www.youtube.com/watch?v=_NXz2vVhKi0" target="_blank" rel="noopener">https://www.youtube.com/watch?v=_NXz2vVhKi0</a></p><h2 id="09-什么叫做空？如何做空？（投机）"><a href="#09-什么叫做空？如何做空？（投机）" class="headerlink" title="09 什么叫做空？如何做空？（投机）"></a>09 什么叫做空？如何做空？（投机）</h2><p>做空就是：先卖再买<br>股票：融券（借股票，卖，买，还股票）<br>期货：买卖合同（预期）（卖合约，买合约）</p><p>对冲：股票和股指对冲<br>股票持有，股指做空<br>股票涨（大赚），股指涨（小亏）<br>股票跌（小亏），股指跌（大赚）</p><p><a href="https://www.youtube.com/watch?v=kSDVKYvl7Kg" target="_blank" rel="noopener">https://www.youtube.com/watch?v=kSDVKYvl7Kg</a></p><h2 id="11-历史故事讲述基本面分析、技术分析、盘口分析区别"><a href="#11-历史故事讲述基本面分析、技术分析、盘口分析区别" class="headerlink" title="11 历史故事讲述基本面分析、技术分析、盘口分析区别"></a>11 历史故事讲述基本面分析、技术分析、盘口分析区别</h2><p>基本面分析：宏观经济环境，行业，公司。主流（内功），长线（月、年）<br>技术分析：图表决定一切。非主流（招式，实在），中短线（周、月）<br>盘口分析：报价、成交数据、跳动、炒单。极小众（极难学，极有用）（日内）</p><p>盘口：哪分钟入手？（选价）<br>技术面：哪天？哪周？（择时）<br>基本面：买什么东西？（选股）</p><p><a href="https://www.youtube.com/watch?v=05FxrzqZ_c0" target="_blank" rel="noopener">https://www.youtube.com/watch?v=05FxrzqZ_c0</a></p><h2 id="12-什么是趋势线？如何画？如何调整校对？"><a href="#12-什么是趋势线？如何画？如何调整校对？" class="headerlink" title="12 什么是趋势线？如何画？如何调整校对？"></a>12 什么是趋势线？如何画？如何调整校对？</h2><ol><li>时间越长越有效</li><li>触点越多越有效</li></ol><p><a href="https://www.youtube.com/watch?v=E6ZTBfow2xQ" target="_blank" rel="noopener">https://www.youtube.com/watch?v=E6ZTBfow2xQ</a></p><h2 id="13-趋势线的角度，突破、回抽（假突破）"><a href="#13-趋势线的角度，突破、回抽（假突破）" class="headerlink" title="13 趋势线的角度，突破、回抽（假突破）"></a>13 趋势线的角度，突破、回抽（假突破）</h2><p>趋势线角度：</p><ol><li>小于 30/45，上升趋势不稳定</li><li>45 左右，稳定（放心持有）</li><li>60 以上（特别 75/80），短时间反转可能性大</li></ol><p>趋势线回抽</p><p><a href="https://www.youtube.com/watch?v=xlgUocdRUrY" target="_blank" rel="noopener">https://www.youtube.com/watch?v=xlgUocdRUrY</a></p><h2 id="14-比特币后市走势（趋势线）"><a href="#14-比特币后市走势（趋势线）" class="headerlink" title="14 比特币后市走势（趋势线）"></a>14 比特币后市走势（趋势线）</h2><p><a href="https://www.youtube.com/watch?v=oD-FVuZjiOo" target="_blank" rel="noopener">https://www.youtube.com/watch?v=oD-FVuZjiOo</a></p><h2 id="15-比特币行情走向（K线图）"><a href="#15-比特币行情走向（K线图）" class="headerlink" title="15 比特币行情走向（K线图）"></a>15 比特币行情走向（K线图）</h2><p><a href="https://www.youtube.com/watch?v=3FyPI6Ih5wA" target="_blank" rel="noopener">https://www.youtube.com/watch?v=3FyPI6Ih5wA</a></p><h2 id="16-通道理论以及拐点理论"><a href="#16-通道理论以及拐点理论" class="headerlink" title="16 通道理论以及拐点理论"></a>16 通道理论以及拐点理论</h2><p>趋势线，平行移动<br>作用：用于作为走势参考<br>突破，注意！<br>有效突破：通道拐点，趋势线突破点</p><p>拐点意义：确认趋势转折</p><p><a href="https://www.youtube.com/watch?v=MpNecRMGbJ4" target="_blank" rel="noopener">https://www.youtube.com/watch?v=MpNecRMGbJ4</a></p><h2 id="18-形态理论及其意义"><a href="#18-形态理论及其意义" class="headerlink" title="18 形态理论及其意义"></a>18 形态理论及其意义</h2><ol><li>三角形：突破，转折</li><li>平行四边形：多空还在战斗</li><li>圆顶/圆底</li><li>钻石形态（菱形）（顶/底）</li><li>喇叭形态（反三角形）</li></ol><p>意义：突破后的应对，而不是预测</p><p><a href="https://www.youtube.com/watch?v=4Yavr4-cmRo" target="_blank" rel="noopener">https://www.youtube.com/watch?v=4Yavr4-cmRo</a></p><h2 id="20-理查德-沙贝克-逆转与持续理论"><a href="#20-理查德-沙贝克-逆转与持续理论" class="headerlink" title="20 理查德 沙贝克 逆转与持续理论"></a>20 理查德 沙贝克 逆转与持续理论</h2><p>头肩形态：头肩顶（M形态），头肩底（W形态）</p><p>市场：逆转和持续，构成基本方式</p><p>市场 -&gt; 逆转 -&gt; 持续 -&gt; 直到有外力出现造成另一轮逆转</p><p>如何判断：头肩形态，颈线，趋势线</p><p><a href="https://www.youtube.com/watch?v=uVqQfYwKqPo" target="_blank" rel="noopener">https://www.youtube.com/watch?v=uVqQfYwKqPo</a></p><h2 id="21-裂口（缺口）理论与实战"><a href="#21-裂口（缺口）理论与实战" class="headerlink" title="21 裂口（缺口）理论与实战"></a>21 裂口（缺口）理论与实战</h2><p>什么是裂口？</p><p>分类：<br>普通型裂口<br>突破型裂口（重要）（上升趋势买入，下降趋势卖出、做空）<br>持续型裂口<br>衰退型裂口（平仓）</p><p>意义（实战）</p><p>回补（无意义）</p><p><a href="https://www.youtube.com/watch?v=EySicvCWvaE" target="_blank" rel="noopener">https://www.youtube.com/watch?v=EySicvCWvaE</a></p><h2 id="23-支撑与阻力的概念与实战"><a href="#23-支撑与阻力的概念与实战" class="headerlink" title="23 支撑与阻力的概念与实战"></a>23 支撑与阻力的概念与实战</h2><ol><li>什么是支撑与阻力？<br>支撑：低点、量能或成交密集区（位）<br>阻力：高点、量能或成交密集区（位）</li><li>互换</li><li>用法：<br>趋势交易 -&gt; 突破<br>反趋势 -&gt; 买卖点</li></ol><p><a href="https://www.youtube.com/watch?v=Kc8WbTiHFlc" target="_blank" rel="noopener">https://www.youtube.com/watch?v=Kc8WbTiHFlc</a></p><h2 id="24-河宽（沽压带）的概念与实战"><a href="#24-河宽（沽压带）的概念与实战" class="headerlink" title="24. 河宽（沽压带）的概念与实战"></a>24. 河宽（沽压带）的概念与实战</h2><p>河宽：两个沽压带之间的距离<br>短：压力大<br>长：压力小<br>用法：仓位控制</p><p><a href="https://www.youtube.com/watch?v=b8FtYUpt8xg" target="_blank" rel="noopener">https://www.youtube.com/watch?v=b8FtYUpt8xg</a></p><h2 id="25-什么是真-假突破？"><a href="#25-什么是真-假突破？" class="headerlink" title="25 什么是真/假突破？"></a>25 什么是真/假突破？</h2><p>突破：趋势交易者<br>形态突破<br>假突破：突破失败<br>如何判断真假突破：量，价<br>意义：无法提前判断，靠止损</p><p><a href="https://www.youtube.com/watch?v=UsmRukuSUdo" target="_blank" rel="noopener">https://www.youtube.com/watch?v=UsmRukuSUdo</a></p><h2 id="26-道氏理论总结"><a href="#26-道氏理论总结" class="headerlink" title="26 道氏理论总结"></a>26 道氏理论总结</h2><ol><li>指数决定一切（图表决定一切）</li><li>判断/找出趋势（主要趋势、次级趋势、小趋势）</li><li>形态（三角、四边、菱形、喇叭形）（位置）</li><li>趋势线（工具）</li><li>逆转与持续</li><li>M顶、W底、突破、河宽、沽压位，……</li></ol><p><a href="https://www.youtube.com/watch?v=pk9ylwn7nj4" target="_blank" rel="noopener">https://www.youtube.com/watch?v=pk9ylwn7nj4</a></p><h2 id="27-主观交易与客观交易"><a href="#27-主观交易与客观交易" class="headerlink" title="27 主观交易与客观交易"></a>27 主观交易与客观交易</h2><p>客观交易：趋势，趋势线；（不猜、不空想）；反人性的；控制自己的聪明；高买低卖（永远不可能买到最好点）<br>主观交易：提前预测；波浪、江恩（时间周期、几何形态）、迪拉波特（黄金分割）、斐波那契、缠论；顺人性的</p><p><a href="https://www.youtube.com/watch?v=N55sbGRvu_k" target="_blank" rel="noopener">https://www.youtube.com/watch?v=N55sbGRvu_k</a></p><h2 id="28-波浪理论-1-数学基础"><a href="#28-波浪理论-1-数学基础" class="headerlink" title="28 波浪理论(1) 数学基础"></a>28 波浪理论(1) 数学基础</h2><p>艾略特，唯一没有金融投资经验的</p><ol><li>黄金分割：0.618，0.382</li><li>斐波那契数列：兔子繁殖</li><li>黄金螺旋</li></ol><p><a href="https://www.youtube.com/watch?v=dI_fZoNViIY" target="_blank" rel="noopener">https://www.youtube.com/watch?v=dI_fZoNViIY</a></p><h2 id="29-波浪理论-2-8浪结构"><a href="#29-波浪理论-2-8浪结构" class="headerlink" title="29 波浪理论(2) 8浪结构"></a>29 波浪理论(2) 8浪结构</h2><p>周期：5浪上升，3浪下跌</p><ol><li>第3浪不是最短浪</li><li>第4浪的底不低于第一浪的顶</li><li>第2浪不能跌破第一浪低点</li></ol><p><a href="https://www.youtube.com/watch?v=3q2T9QdbyRY" target="_blank" rel="noopener">https://www.youtube.com/watch?v=3q2T9QdbyRY</a></p><h2 id="30-波浪理论-3-大小波浪与周期"><a href="#30-波浪理论-3-大小波浪与周期" class="headerlink" title="30 波浪理论(3) 大小波浪与周期"></a>30 波浪理论(3) 大小波浪与周期</h2><p>分形</p><p><a href="https://www.youtube.com/watch?v=CQfSav3ep78" target="_blank" rel="noopener">https://www.youtube.com/watch?v=CQfSav3ep78</a></p><h2 id="31-波浪理论精髓-4-牛熊周期，8浪对应，机构操盘"><a href="#31-波浪理论精髓-4-牛熊周期，8浪对应，机构操盘" class="headerlink" title="31 波浪理论精髓(4) 牛熊周期，8浪对应，机构操盘"></a>31 波浪理论精髓(4) 牛熊周期，8浪对应，机构操盘</h2><p><a href="https://www.youtube.com/watch?v=cJ4OjLOWxco" target="_blank" rel="noopener">https://www.youtube.com/watch?v=cJ4OjLOWxco</a></p><h2 id="32-波浪理论-5-延长浪，推动浪和调整浪形态结构"><a href="#32-波浪理论-5-延长浪，推动浪和调整浪形态结构" class="headerlink" title="32 波浪理论(5) 延长浪，推动浪和调整浪形态结构"></a>32 波浪理论(5) 延长浪，推动浪和调整浪形态结构</h2><p><a href="https://www.youtube.com/watch?v=jSP3dD6U2pQ" target="_blank" rel="noopener">https://www.youtube.com/watch?v=jSP3dD6U2pQ</a></p><h2 id="33-波浪理论-6-如何精确计算回调以及顶和底"><a href="#33-波浪理论-6-如何精确计算回调以及顶和底" class="headerlink" title="33 波浪理论(6) 如何精确计算回调以及顶和底"></a>33 波浪理论(6) 如何精确计算回调以及顶和底</h2><ol><li>时间周期： 斐波那契数列</li><li>回调/反抽的计算：黄金分割</li><li>顶和底的计算</li></ol><p><a href="https://www.youtube.com/watch?v=rJibrXvqxxo" target="_blank" rel="noopener">https://www.youtube.com/watch?v=rJibrXvqxxo</a></p><h2 id="35-波浪理论-7-K线数浪实战分析"><a href="#35-波浪理论-7-K线数浪实战分析" class="headerlink" title="35 波浪理论(7) K线数浪实战分析"></a>35 波浪理论(7) K线数浪实战分析</h2><p><a href="https://www.youtube.com/watch?v=G4fIWHIX7WA" target="_blank" rel="noopener">https://www.youtube.com/watch?v=G4fIWHIX7WA</a></p><h2 id="38-江恩理论入门-1-江恩是如何被神化的？如何正确学习江恩理论？"><a href="#38-江恩理论入门-1-江恩是如何被神化的？如何正确学习江恩理论？" class="headerlink" title="38 江恩理论入门(1) 江恩是如何被神化的？如何正确学习江恩理论？"></a>38 江恩理论入门(1) 江恩是如何被神化的？如何正确学习江恩理论？</h2><p>前期：青年，中年（经纪人，时间控制因素，印度、英国、埃及，神秘文化，数学）（几何、占星、神秘学）<br>后期：60、70岁，老年时代，《华尔街45年+》</p><p>A 趋势大师：不知道，看趋势<br>B 波浪+指标大师：第5浪，kdj死叉，要下跌<br>C 江恩大师：当时间与价格呈正方形，转势就在其中，我给你一个神奇数字，可以精确测到一个月后高点（神秘性、复杂性、自圆其说）</p><p><a href="https://www.youtube.com/watch?v=hT7Niue9vSg" target="_blank" rel="noopener">https://www.youtube.com/watch?v=hT7Niue9vSg</a></p><h2 id="39-江恩理论-2-江恩神奇数字"><a href="#39-江恩理论-2-江恩神奇数字" class="headerlink" title="39 江恩理论(2) 江恩神奇数字"></a>39 江恩理论(2) 江恩神奇数字</h2><ol><li>3,4: 最重要（四日法则），4根K线法则</li><li>7: 14, 21, 28, 35, 42, (49), 56</li><li>12: 占星；24: 12*2</li><li>平方数（价格，时间）：4, 9, 16, 25, 36, 49, 64</li></ol><p><a href="https://www.youtube.com/watch?v=9Lxx32BeFv4" target="_blank" rel="noopener">https://www.youtube.com/watch?v=9Lxx32BeFv4</a></p><h2 id="42-江恩理论-5-后期江恩（精髓），循环、周期"><a href="#42-江恩理论-5-后期江恩（精髓），循环、周期" class="headerlink" title="42 江恩理论(5) 后期江恩（精髓），循环、周期"></a>42 江恩理论(5) 后期江恩（精髓），循环、周期</h2><p>自然科学 -&gt; 金融奥秘<br>波动率：小波动率，大波动率周期</p><p>周期：期货高手，五万，几百万，媒体（造神），基金，大亏<br>股票、价格有周期，方法也有周期</p><p>春播，夏耕，秋收（赚到钱），冬藏（收手）</p><p><a href="https://www.youtube.com/watch?v=s35mpPi-uJU" target="_blank" rel="noopener">https://www.youtube.com/watch?v=s35mpPi-uJU</a></p><h2 id="44-江恩《华尔街45年》精华讲解-1-为什么会在股票中亏损？什么是双底三底买入？"><a href="#44-江恩《华尔街45年》精华讲解-1-为什么会在股票中亏损？什么是双底三底买入？" class="headerlink" title="44 江恩《华尔街45年》精华讲解(1) 为什么会在股票中亏损？什么是双底三底买入？"></a>44 江恩《华尔街45年》精华讲解(1) 为什么会在股票中亏损？什么是双底三底买入？</h2><ol><li>经验：12条买入方法，24条规则（军规）</li><li>方法：高低点位/时间记录</li></ol><p>为什么会亏损：</p><ol><li>过度交易</li><li>不止损</li><li>不了解市场</li></ol><p>江恩12条买卖规则：</p><ol><li>判断趋势</li><li>单底、双底、三底买入（4次法则）</li><li>按百分比买卖（道式、波浪、江恩），顺大势、逆小势</li></ol><p><a href="https://www.youtube.com/watch?v=zXqufm_4Me8" target="_blank" rel="noopener">https://www.youtube.com/watch?v=zXqufm_4Me8</a></p><h2 id="45-《华尔街45年》精华部分-2"><a href="#45-《华尔街45年》精华部分-2" class="headerlink" title="45 《华尔街45年》精华部分(2)"></a>45 《华尔街45年》精华部分(2)</h2><ol start="4"><li>3周上涨或下降（顺大势、逆小势）</li><li>市场分段运动（波浪理论）</li><li>按 5~7 点运动买卖</li><li>成交量（量价配合：上涨、量、钱；下跌、不需要量、恐惧）（量在价先）</li><li>时间周期</li></ol><p><a href="https://www.youtube.com/watch?v=k--Fc0f1DR8" target="_blank" rel="noopener">https://www.youtube.com/watch?v=k--Fc0f1DR8</a></p><h2 id="46-《华尔街45年》精华部分-3"><a href="#46-《华尔街45年》精华部分-3" class="headerlink" title="46 《华尔街45年》精华部分(3)"></a>46 《华尔街45年》精华部分(3)</h2><ol start="9"><li>在高低点上移时买入（开仓），下移时卖出（道式理论）</li><li>牛市中趋势的变化（重大日期，节假日）</li><li>最安全的买卖点：W底、M头，2B点（《专业投机原理》）</li><li>快速运动中的利润</li></ol><p>看似平谈无奇，真理就在其中</p><p><a href="https://www.youtube.com/watch?v=Rw5or5MKiSM" target="_blank" rel="noopener">https://www.youtube.com/watch?v=Rw5or5MKiSM</a></p><h2 id="47-巴菲特，格林厄姆，查理芒格价值投资理念"><a href="#47-巴菲特，格林厄姆，查理芒格价值投资理念" class="headerlink" title="47 巴菲特，格林厄姆，查理芒格价值投资理念"></a>47 巴菲特，格林厄姆，查理芒格价值投资理念</h2><p>格林厄姆（老师）：<br>1894年出生，1914年毕业于哥大，1923-1929 辉煌（百万富翁）<br>1929-1932破产，抄底，亏损70%-80%<br>1939-1949，出书，《证券分析》，《财报解读》，《聪明的投资者》</p><ol><li>指数法：多元投资</li><li>预期法：获利前景</li><li>安全边际法：内在价值一定要大于价格</li></ol><p>查理芒格（战友）：<br>1924年出生，毕业于哈佛学院，《滚雪球》</p><ol><li>盈利预期法</li><li>集中：只分析可理解</li><li>关联（定价、报表、无形资产），找企业护城河</li><li>整体评估</li></ol><p>巴菲特：<br>5个原则：行业、企业、价格、长期持有、适当分散</p><p><a href="https://www.youtube.com/watch?v=hZRXWQNGyk8" target="_blank" rel="noopener">https://www.youtube.com/watch?v=hZRXWQNGyk8</a></p><h2 id="48-乔治索罗斯"><a href="#48-乔治索罗斯" class="headerlink" title="48 乔治索罗斯"></a>48 乔治索罗斯</h2><p>巴菲特（神）<br>索罗斯（魔）：做空，三大战役</p><p>1930年出生，匈牙利人，1944年（14岁）逃亡至英国，1949年考上伦敦经济学院，1956年移民美国（证券分析），1973年成立基金（26年），1979年量子基金（哲学）（测不准原理）<br>1992年狙击英镑（20亿美元），1997年泰铢引爆亚洲金融危机，2012年做空日元（10亿美元），伟大的慈善家（80亿美元）</p><p>卡尔波普（哲学家）：</p><ol><li>反归纳主义（有限不能证明无限、过去不能证明未来）</li><li>科学与非科学（证伪主义）</li><li>三个世界：物质世界、精神世界、物质和精神世界的结合（美术金融）</li></ol><p><a href="https://www.youtube.com/watch?v=p3hjQnmDld0" target="_blank" rel="noopener">https://www.youtube.com/watch?v=p3hjQnmDld0</a></p><h2 id="49-索罗斯反身性理论"><a href="#49-索罗斯反身性理论" class="headerlink" title="49 索罗斯反身性理论"></a>49 索罗斯反身性理论</h2><p>《金融炼金术》反身性理论</p><p>参与者：思想，偏见、偏激，未知量<br>现实：基本面、财报，参与者参与过程，已知量<br>相互干涉的过程，反身性</p><p>投资理念：当市场大幅偏离、背离、共振时重仓</p><p><a href="https://www.youtube.com/watch?v=aK5R97gNqrM" target="_blank" rel="noopener">https://www.youtube.com/watch?v=aK5R97gNqrM</a></p><h2 id="50-伟大的杰西利佛莫尔-1-一生故事（四起四落）"><a href="#50-伟大的杰西利佛莫尔-1-一生故事（四起四落）" class="headerlink" title="50 伟大的杰西利佛莫尔(1) 一生故事（四起四落）"></a>50 伟大的杰西利佛莫尔(1) 一生故事（四起四落）</h2><p>1877年出生于美国，农场主儿子，贫穷（小学毕业）<br>1890年（13岁）杂工、擦黑板、行情记录（2年的记录数字行情）<br>1892-1899，从 3.12 赚到 1万美元（15岁）<br>1900-1901，亏光1万，又赚5万，又亏光了（23岁）<br>1906年，做空太平洋铁路，赚25万<br>1907年，做空股指，大赚100万？300万？<br>1908年（31岁），做多棉花，亏损加仓，摊成本，亏损，破产<br>1915年（38岁），东山再起，7年<br>1915-1916，38岁，14.5万，39岁，300万<br>1917年（40岁），给家族买了80万信托基金，又赚了150万<br>1922年（45岁），《股市大作手回忆录》<br>1929年，华尔街大崩盘，赚了1亿美元（当年美国财政收入45亿）（相当于2018年687亿）<br>1931-1934，（抄底，政策不允许/限制做空），破产<br>1935年，家庭，老婆开枪打死小儿子（酗酒）<br>1939年，《如何在股市中交易》<br>1940年，自杀（看到自己的父亲尸体，父亲去世后自杀）</p><p>自律 -&gt; 失控</p><p><a href="https://www.youtube.com/watch?v=GhQM-6sTv0g" target="_blank" rel="noopener">https://www.youtube.com/watch?v=GhQM-6sTv0g</a></p><h2 id="51-杰西利佛莫尔-交易方法及关键理念"><a href="#51-杰西利佛莫尔-交易方法及关键理念" class="headerlink" title="51 杰西利佛莫尔 交易方法及关键理念"></a>51 杰西利佛莫尔 交易方法及关键理念</h2><p>《股市大作手回忆录》1922<br>《如何交易股票》 （丁圣元译）</p><p>方法：</p><ol><li>突破法（最小阻力），外力（波动率加大）</li><li>关键点：<br>进场：突破失败，回抽；纯突破<br>出场：高点不再创新高；波动突然加大，向下关键点突破</li><li>资金策略：盈利加仓（止损）</li></ol><p>经典句子：<br>人性是永远不变的，市场也不变。<br>一定要慢半拍，不要去预测市场。<br>控制情绪，耐心等待机会，耐心等待关键点的出现，耐心获利。<br>绝对不要拉均价，绝对不要亏损加仓。<br>绝对不要听小道消息、内部消息。</p><p><a href="https://www.youtube.com/watch?v=lCKcC3XpyWM" target="_blank" rel="noopener">https://www.youtube.com/watch?v=lCKcC3XpyWM</a></p><h2 id="52-比特币分析-2018-12-26"><a href="#52-比特币分析-2018-12-26" class="headerlink" title="52 比特币分析 (2018-12-26)"></a>52 比特币分析 (2018-12-26)</h2><ol><li>周线，日线，60分钟，5/15分钟，盘口买/卖</li><li>有仓位（币）：<br>止盈：趋势线，支撑与压力（量价），1/2, 1/3, 2/3线</li><li>没有仓位（币）：<br>顺势交易：共振点（周、日、60、5分钟同一方向）<br>逆势交易：顺大势、逆小势（关键点）</li><li>开仓买/卖：止损点在哪？</li></ol><p><a href="https://www.youtube.com/watch?v=OycHeGg62WA" target="_blank" rel="noopener">https://www.youtube.com/watch?v=OycHeGg62WA</a></p><h2 id="53-盘口交易法及炒单（唯一小资金变成大资金）"><a href="#53-盘口交易法及炒单（唯一小资金变成大资金）" class="headerlink" title="53. 盘口交易法及炒单（唯一小资金变成大资金）"></a>53. 盘口交易法及炒单（唯一小资金变成大资金）</h2><p>高频交易：人工 50-200，计算机：几千次<br>屠龙刀</p><ol><li>手续费：低（返手续费）关键！！！</li><li>长时间经验摸索（几个月~1年到数年）</li><li>每天交易至少数十次/百次，性格，忍耐（几十次止损）</li><li>国家（手续费）/品种（特征）/平台能看到的信息</li></ol><p><a href="https://www.youtube.com/watch?v=2UNKCWNYhxg" target="_blank" rel="noopener">https://www.youtube.com/watch?v=2UNKCWNYhxg</a></p><h2 id="54-盘口交易法及炒单方法（高频交易）"><a href="#54-盘口交易法及炒单方法（高频交易）" class="headerlink" title="54. 盘口交易法及炒单方法（高频交易）"></a>54. 盘口交易法及炒单方法（高频交易）</h2><p>网名：初级炒单，一缕青烟，侯婷婷；公羽捷，翁文捷，何俊（何天王）</p><ol><li>判大方向：日线、分钟线（趋势：单边；振荡：双向）</li><li>记四价：昨日开盘价、收盘价、最高价、最低价，（今开盘）</li><li>判强弱：没有涨跌，只有强弱</li><li>开仓点：<br>4.1 支撑/压力点位/量能（意向）<br>4.2 看挂单/五档买卖盘（意向）<br>4.3 看成交记录（实实在在）<br>开仓/平仓（大单/吃单速度/密度）</li><li>止损</li></ol><p><a href="https://www.youtube.com/watch?v=3oLYgqc87hc" target="_blank" rel="noopener">https://www.youtube.com/watch?v=3oLYgqc87hc</a></p><h2 id="55-总结（十年总结）金融交易赚钱核心秘密"><a href="#55-总结（十年总结）金融交易赚钱核心秘密" class="headerlink" title="55 总结（十年总结）金融交易赚钱核心秘密"></a>55 总结（十年总结）金融交易赚钱核心秘密</h2><ol><li>是什么？赚钱 5%（杠杆），20%（股票）。亏损占绝大多数</li><li>为什么？<br>门槛：<br>门槛越低，赚钱越难（赌博、金融交易）（无时间要求、无专业、无纪律、无限制）。<br>门槛越高，赚钱越容易（医生、律师、高级翻译、科学家、工程师）。<br>符合哲学自然规律。</li><li>怎么办？<br>学习，迷宫理论，第一步<br>金字塔认知结构：赚钱核心秘密<br>方法，规则，概率，情绪控制</li></ol><p>方法，规则：每个人观念不一样，感激不同观念的人，观念/方法越认同，方法越难交易 （80%）<br>概率：止损，（方法既有用又无用），资金比例 （15%）<br>大部分亏损者都是对随机激励的上瘾，和小概率事件的痴迷。（照顾疯老太太理论）<br>情绪控制：生理控制（多巴胺），心理控制（宗教、哲学） （5%）</p><p>认识概率，控制情绪，知行合一</p><p><a href="https://www.youtube.com/watch?v=iY8OzJ92hoI" target="_blank" rel="noopener">https://www.youtube.com/watch?v=iY8OzJ92hoI</a></p><h2 id="57-K线的画法，关键K线的意义"><a href="#57-K线的画法，关键K线的意义" class="headerlink" title="57 K线的画法，关键K线的意义"></a>57 K线的画法，关键K线的意义</h2><p>K线只是规则的载体，离开规则谈K线毫无意义</p><ol><li>历史：<br>1750年左右，日本，本间宗久，米商（K线记录4个信息）<br>1960-70年代，史蒂夫尼森，引入华尔街<br>（点线图；分时图；竹节图；柱状图）</li><li>周期：（月、周、日、小时、30分钟、15分钟、5分钟）<br>4个信息（开盘价、收盘价、最高价、最低价）</li><li>画法：<br>阳线：大阳<em>、下影线大阳、上影线大阳、上下影线大阳、十字星、锤子</em>、倒锤子<em><br>阴线：大阴</em>、上影线大阴、下影线大阴、上下影线大阴、十字星、锤子<em>、倒锤子</em></li></ol><p>有价值：大阳、大阴、锤子、倒锤子（V型反转）、波动很大的十字星<br>资金作盘（流入）</p><p><a href="https://www.youtube.com/watch?v=hvUtGI3rqkc" target="_blank" rel="noopener">https://www.youtube.com/watch?v=hvUtGI3rqkc</a></p><h2 id="58-看清K线组合实质"><a href="#58-看清K线组合实质" class="headerlink" title="58 看清K线组合实质"></a>58 看清K线组合实质</h2><p>《本间宗久秘录》<br>三川、三山、三空、三兵、三法</p><ol><li>三川：底部</li><li>三山：顶部</li><li>三空：跳空（缺口）</li><li>三兵（三个红小兵、黑小兵）：45%趋势</li><li><p>三法：盘整，中继</p></li><li><p>吞没：看涨吞没，看跌吞没（突破）</p></li><li>孕线：看跌孕线，看涨孕线</li><li>反转：下跌反转、上升反转（M顶、W底）</li><li>乌云盖顶/断头砸刀</li></ol><p><a href="https://www.youtube.com/watch?v=06C5dEQVLbM" target="_blank" rel="noopener">https://www.youtube.com/watch?v=06C5dEQVLbM</a></p><h2 id="59-K线核心用法"><a href="#59-K线核心用法" class="headerlink" title="59 K线核心用法"></a>59 K线核心用法</h2><ol><li>K线、关键K线、大阳/大阴/锤子/倒锤子、位置</li><li>交易规则（交易系统）+关键位置+关键K线</li></ol><p>交易系统：<br>趋势线突破<br>形态突破<br>W、M、三川、三山突破<br>支撑于阻力（点位）<br>百分比回调（点）<br>均线（金叉死叉）<br>指标：MACD、KDJ、布林线、量比</p><p>关键位置：<br>前位、后位</p><p>关键K线：只有后位有意义</p><p>本间宗久四大原则：风林火山<br>风：疾如风 —— 转折（快）<br>林：徐如林 —— 盘整（慢）<br>火：掠如火 —— 突破/加速（加仓）<br>山：不动如山 —— 持续（抱紧头寸）</p><p><a href="https://www.youtube.com/watch?v=nFRBghQNqLA" target="_blank" rel="noopener">https://www.youtube.com/watch?v=nFRBghQNqLA</a></p><h2 id="60-《海龟交易法》-1-之理查德丹尼斯和他的海龟们"><a href="#60-《海龟交易法》-1-之理查德丹尼斯和他的海龟们" class="headerlink" title="60 《海龟交易法》(1)之理查德丹尼斯和他的海龟们"></a>60 《海龟交易法》(1)之理查德丹尼斯和他的海龟们</h2><p>17岁，做委托单的传递（跑腿），学习，用父亲账户操作（不到 21 岁）场内场外，亏损，期间完成哲学学位<br>23岁，买交易席位，1200 美元 + 400美元（赚了1亿美元）<br>26岁，400 USD -&gt; 3000 USD -&gt; 100K USD -&gt; 500K USD -&gt; 1M 美元</p><p>正确的方法 + 历史给的机会 = 暴赚/第一桶金</p><p>1972-1973年，苏联粮食大劫案。苏联买了美国 30%的粮食，粮食疯狂涨价。</p><p>35岁，亿万富翁，《海龟计划》，哲学思考，优秀的交易员是天生的还是后天培养的？<br>丹尼斯，威廉，打赌，实验</p><p>新加坡养海龟，人工培养</p><p>1000人里选 12 + 10人（22个人，淘汰2人），1周培训，1个实盘测试，25万美元-200万美元初始资金。<br>结果：20个人每年100%盈利，赚数亿，其他公司做基金经理</p><p>教训：</p><ol><li>1978年失败，亏50%，个人</li><li>1987年，基金亏50%，个人（据说）亏90%，海龟团队解散，1988年丹尼斯金盆洗手退出金融界</li></ol><p>原因：采访，黑天鹅（顺空），高开 40%</p><p><a href="https://www.youtube.com/watch?v=OWSf_Jwdmko" target="_blank" rel="noopener">https://www.youtube.com/watch?v=OWSf_Jwdmko</a></p><h2 id="62-《海龟交易法》-2"><a href="#62-《海龟交易法》-2" class="headerlink" title="62 《海龟交易法》(2)"></a>62 《海龟交易法》(2)</h2><p>趋势交易法：</p><ol><li>点位突破（前高点）杰西</li><li>趋势线突破</li><li>形态突破</li><li>W底M顶突破与逆转</li><li>通道突破（唐奇安、布林线）</li><li>海龟交易法</li><li>均线系统</li><li>四周法则</li><li>三重滤网</li><li>点位交易法（百分比）（斐波那契点位）</li></ol><p>量化交易法：<br>开仓点（头寸规模）<br>止损点<br>加仓点<br>平仓点</p><p>趋势突破，坚定止损，盈利加仓</p><ol><li>买什么？（低关联、流动好、容量大）</li><li>买多少？（头寸单位 U）</li></ol><p>单一市场：4U<br>关联市场：6U<br>低关联：10U<br>最多同方向：12U</p><p>头寸规模（U） = (账户 1%)/市场绝对波幅<br>市场绝对波幅 = N <em>合约每一点所代表价值<br>N = (19</em>PDN + TR)/20<br>PDN: 前一日 N 值<br>TR（真实波幅）= 最大值（当日最高价 - 当日最低价， 当日最高价 - 前一日收盘价，前一日收盘价 - 当日最低）<br>TR = max(H-L, H-PDC, PDC-L)<br>（前期波动率大少买，前期波动率小多买）</p><ol start="3"><li><p>什么时候买？<br>短线：价格超过20日最高价（做空反之）<br>长线：价格超过55日最高价（做空反之）</p></li><li><p>止损：2N</p></li><li>加仓： 0.5N 的间隔每次增加 1U 单位</li><li>平仓：<br>短线：10日最低价（做空反之）<br>长线：20日最低价（做空反之）</li></ol><p>海龟交易法的问题：</p><ol><li>趋势的稀缺性，特别是单一品种</li><li>低胜率对执行力的考验</li><li>大幅回撤反人性，对持仓的考验</li></ol><p><a href="https://www.youtube.com/watch?v=P_7dqLHySF8" target="_blank" rel="noopener">https://www.youtube.com/watch?v=P_7dqLHySF8</a></p><h2 id="63-《混沌交易法》混沌与分形"><a href="#63-《混沌交易法》混沌与分形" class="headerlink" title="63 《混沌交易法》混沌与分形"></a>63 《混沌交易法》混沌与分形</h2><p>经典牛顿物理学：宇宙由自然规律、数学支配<br>量子力学（20世纪20,30年代）：微观上不可测量，概率性存在。（索罗斯：量子基金）<br>混沌理论（20世纪60,70年代）：宏观上不可测量（人口移动、化学反应、社会行为、金融交易）<br>历史：</p><ol><li>19世纪末：庞加莱，三体问题</li><li>20世纪60年代：气象学家洛化兹，蝴蝶效应</li><li>费根鲍常熟：周期加倍<br>金融学：社会行为+大众心理（混沌中的混沌）</li></ol><p>金融市场的不可预测性，止损的理论基础</p><p>混沌理论的特点：</p><ol><li>能量永远会遵循阻力最小途径（杰西利佛莫尔）</li><li>始终存在不可见的根本结构，这个结构决定最小阻力路径</li><li>根本结构可被发现，且可以被改变<br>技术交易，分形（重要）</li></ol><p><a href="https://www.youtube.com/watch?v=9640U79EPSU" target="_blank" rel="noopener">https://www.youtube.com/watch?v=9640U79EPSU</a></p><h2 id="64-《混沌交易法》混沌与分形实战运用（精华）"><a href="#64-《混沌交易法》混沌与分形实战运用（精华）" class="headerlink" title="64 《混沌交易法》混沌与分形实战运用（精华）"></a>64 《混沌交易法》混沌与分形实战运用（精华）</h2><ol><li>不同周期经典分形无处不在</li><li>最小周期（1分钟，5分钟，15分钟，60分钟，日线，周线，月线），分形与最大周期具有相似性（开仓、平仓，交易规则）</li><li>小级别分形构成大级别分形的一小部分</li><li>周期共振往往是出大行情的机会</li></ol><p>分形结构：</p><ol><li>两段式分形</li><li>N字分形</li><li>M、W分形</li><li>M、W突破回抽分形</li><li>形态结构分形</li><li>最经典结构（理查德沙贝克）</li></ol><p>混沌，找到一种模式，确定规则</p><p>分形结构（客观、混沌）+交易规则（可控）+止损（可控）+一致性（可控）=成功</p><p><a href="https://www.youtube.com/watch?v=izA9iPEhfoo" target="_blank" rel="noopener">https://www.youtube.com/watch?v=izA9iPEhfoo</a></p><h2 id="66-《我如何在股市中赚了200万美元》-尼古拉斯达瓦斯箱体理论"><a href="#66-《我如何在股市中赚了200万美元》-尼古拉斯达瓦斯箱体理论" class="headerlink" title="66 《我如何在股市中赚了200万美元》 尼古拉斯达瓦斯箱体理论"></a>66 《我如何在股市中赚了200万美元》 尼古拉斯达瓦斯箱体理论</h2><p>1920年，匈牙利，布达佩斯出生<br>1943年，逃到土耳其和欧洲，与同父异母妹妹跳舞为生<br>1952年，史密斯兄弟6000股（每股0.5美元）作为酬劳，0.5涨到1.9美元，赚了8000美元。看200本书，每天8个小时<br>1957年-1958年，从市场上赚了200万美元<br>1959年，《时代杂志》采访，成名，写书 “How I made $2 million in the stock market?” “Wall Street, the other Las Vegas”(《我如何在股市中活了下来》)<br>1960年，被调查，争议（书，误导，22万美元？）</p><p>学习交易的四个阶段：</p><ol><li>赌徒：听消息，找“专家”，看“选股”杂志，“精英”荐股（预测）。无方法、无规则、无纪律。（亏损）</li><li>基本面分析：收益，财报，市盈率。（亏损）</li><li>技术面分析：价格变动，突破后的走向。200本书，买卖实践，箱体理论。（成功）</li><li>基本面和技术面相结合：有前途的行业+突破。1957-1958。（成功）</li></ol><p><a href="https://www.youtube.com/watch?v=IjPnzEkFdSI" target="_blank" rel="noopener">https://www.youtube.com/watch?v=IjPnzEkFdSI</a></p><h2 id="68-尼古拉斯达瓦斯箱体理论演变、定义、实战"><a href="#68-尼古拉斯达瓦斯箱体理论演变、定义、实战" class="headerlink" title="68 尼古拉斯达瓦斯箱体理论演变、定义、实战"></a>68 尼古拉斯达瓦斯箱体理论演变、定义、实战</h2><p>定义：股价在高低点之间波动，围绕波动区间画的区域就代表一个箱体。</p><p>买卖点：<br>开仓：突破箱体，箱体内<br>止损：箱体突破点往下几个价位<br>加仓：突破后盈利，下一个箱体neilliu<br>平仓：突破最后一个箱体下沿</p><p>试验：两次盈利、一次亏损</p><p>总结：</p><ol><li>市场不可预测</li><li>坚定止损</li><li>盈亏比</li><li>移动止盈</li></ol><p>修正：<br>开仓：成交量扩大+突破+基本面<br>止损：箱体理论<br>加仓：箱体理论<br>平仓：移动止盈</p><p>实战：<br>罗瑞拉德香烟<br>布鲁斯实木板</p><p>“我绝不卖掉一支正在上涨的股票”</p><p>问题：</p><ol><li>1957-1958年大成功（大牛市）<br>熊市：稳定的亏损</li><li>定义不明确</li></ol><p><a href="https://www.youtube.com/watch?v=Fc7eEfsok2E" target="_blank" rel="noopener">https://www.youtube.com/watch?v=Fc7eEfsok2E</a></p><h2 id="70-《旅行•交易》道德排第一，智力，学历和金融专业并非交易成功必要条件"><a href="#70-《旅行•交易》道德排第一，智力，学历和金融专业并非交易成功必要条件" class="headerlink" title="70 《旅行•交易》道德排第一，智力，学历和金融专业并非交易成功必要条件"></a>70 《旅行•交易》道德排第一，智力，学历和金融专业并非交易成功必要条件</h2><p><a href="https://www.youtube.com/watch?v=psvfwyTEWZM" target="_blank" rel="noopener">https://www.youtube.com/watch?v=psvfwyTEWZM</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;01-金融交易入门&quot;&gt;&lt;a href=&quot;#01-金融交易入门&quot; class=&quot;headerlink&quot; title=&quot;01 金融交易入门&quot;&gt;&lt;/a&gt;01 金融交易入门&lt;/h2&gt;&lt;p&gt;迷宫理论&lt;/p&gt;&lt;p&gt;A 基本面分析&lt;br&gt;B 道氏理论&lt;br&gt;C 江恩理论&lt;br&gt;E 破浪理论&lt;br&gt;F 盘口&lt;br&gt;G 指标&lt;/p&gt;&lt;p&gt;大师&lt;br&gt;骗子&lt;br&gt;偏执狂&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=Jy6mkzDsbmE&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.youtube.com/watch?v=Jy6mkzDsbmE&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;02-基本面、技术、盘口&quot;&gt;&lt;a href=&quot;#02-基本面、技术、盘口&quot; class=&quot;headerlink&quot; title=&quot;02 基本面、技术、盘口&quot;&gt;&lt;/a&gt;02 基本面、技术、盘口&lt;/h2&gt;&lt;p&gt;基本面：全球、行业、市盈率、财务、天气、供求、政策&lt;br&gt;技术面：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;道氏理论：趋势线、形态、位置&lt;/li&gt;&lt;li&gt;波浪理论：认识、划分、分型&lt;/li&gt;&lt;li&gt;江恩理论：时间、周期、28条、占星&lt;/li&gt;&lt;li&gt;其他：点位、箱子、缠论&lt;br&gt;指标派：MACD、KDJ、RAS&lt;br&gt;盘口分析（炒单）&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;交易方法：中长线，短线，日内，超短线&lt;/p&gt;&lt;p&gt;交易心理&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=bgZBeaa3H6Y&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.youtube.com/watch?v=bgZBeaa3H6Y&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="投资" scheme="http://whypro.github.io/hexo-blog/tags/%E6%8A%95%E8%B5%84/"/>
    
      <category term="金融" scheme="http://whypro.github.io/hexo-blog/tags/%E9%87%91%E8%9E%8D/"/>
    
      <category term="交易" scheme="http://whypro.github.io/hexo-blog/tags/%E4%BA%A4%E6%98%93/"/>
    
      <category term="股票" scheme="http://whypro.github.io/hexo-blog/tags/%E8%82%A1%E7%A5%A8/"/>
    
      <category term="期货" scheme="http://whypro.github.io/hexo-blog/tags/%E6%9C%9F%E8%B4%A7/"/>
    
  </entry>
  
  <entry>
    <title>解决 “Windows 安装程序无法将 Windows 配置为在此计算机的硬件上运行”</title>
    <link href="http://whypro.github.io/hexo-blog/20200324/%E8%A7%A3%E5%86%B3%20%E2%80%9CWindows%20%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F%E6%97%A0%E6%B3%95%E5%B0%86%20Windows%20%E9%85%8D%E7%BD%AE%E4%B8%BA%E5%9C%A8%E6%AD%A4%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E7%A1%AC%E4%BB%B6%E4%B8%8A%E8%BF%90%E8%A1%8C%E2%80%9D/"/>
    <id>http://whypro.github.io/hexo-blog/20200324/解决 “Windows 安装程序无法将 Windows 配置为在此计算机的硬件上运行”/</id>
    <published>2020-03-23T16:39:00.000Z</published>
    <updated>2020-05-03T12:02:32.869Z</updated>
    
    <content type="html"><![CDATA[<p>我的 NAS 的配置是 HP Gen8 + Intel 志强 1220L v2，之前用 1T 的机械硬盘作为系统盘，因为感觉日常 IO 速度有些慢，恰好台式电脑淘汰下一个 Samsung 860 EVO SSD，所以决定替换磁盘。而此前一直是 Debian 10 + Windows Server 2008 R2 双系统，Linux 备份还原很简单，<code>dd</code> 命令使用起来非常方便，用 LiveCD chroot 刷新一次 grub 即可，但 Windows 就要重新安装和配置了。</p><p>因为 Windows 安装程序会覆盖掉硬盘的主引导记录 (MBR)，所以一般是先安装 Windows，再安装 Linux 用 grub 重写 MBR。</p><p>然而，当我认为一切尽在掌握之时，Windows Server 2008 R2 的安装程序在复制完文件重启配置时弹出“Windows 安装程序无法将 Windows 配置为在此计算机的硬件上运行”错误，然后就中断重启了。</p><img src="/hexo-blog/20200324/解决%20“Windows%20安装程序无法将%20Windows%20配置为在此计算机的硬件上运行”/error.jpg"><a id="more"></a><p>之前从来没有遇到过这个问题，于是在网上查了很多帖子，尝试了以下几个方法：</p><p>首先尝试了<a href="https://www.dell.com/support/article/zh-cn/sln293812/windows-7-%E6%88%96-windows-10-%E5%AE%89%E8%A3%85%E6%9C%9F%E9%97%B4-windows-%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F%E6%97%A0%E6%B3%95%E9%85%8D%E7%BD%AE%E4%B8%BA%E5%9C%A8%E6%AD%A4%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E7%A1%AC%E4%BB%B6%E4%B8%8A%E8%BF%90%E8%A1%8C-%E9%94%99%E8%AF%AF?lang=zh" target="_blank" rel="noopener">这个方法</a>：</p><ol><li>在错误屏幕中, 按 <code>Shift + F10</code> 打开命令提示符 (或在 Windows 搜索栏中键入 <code>cmd</code>, 并从搜索结果菜单中选择 “命令提示符”)。</li><li>键入 <code>cd \</code> , 然后按 <code>enter</code> 键。</li><li>键入 <code>cd x:\windows\system32\oobe</code> ( <code>x</code> 是安装 Windows 的驱动器号, 例如 <code>c:\windows\system32\oobe</code>), 然后按 <code>enter</code> 键。</li><li>键入 <code>msoobe</code> , 然后按 <code>enter</code> 键。安装过程现在应该会自动继续。</li><li>卸下安装介质, 系统应完成安装并引导至 Windows。</li></ol><p>按这种方法操作后虽然安装程序继续进行了，但是重启后蓝屏。</p><p>有说分区问题的，我的硬盘是 250G，我用了 MBR 分区表，分了两个主分区，第一个分区是 Linux ext4 bootable，第二个分区是 Windows NTFS。我用 fdisk 重新分区，将分区互换，将 NTFS 分区放在了第一个分区，依然没用。</p><p>正在一筹莫展时，发现了这两篇文章：</p><p><a href="https://www.cnblogs.com/niray/p/3931419.html" target="_blank" rel="noopener">https://www.cnblogs.com/niray/p/3931419.html</a></p><p><a href="http://blog.sina.com.cn/s/blog_495113340100ovfe.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_495113340100ovfe.html</a></p><p>这两篇文章都提到了 Intel RST 驱动，觉得分析的有点道理，可能是新版本的 SSD 造成了安装程序无法识别。</p><p>但这个驱动芯片组不同一般不能通用。查了相关文档，我的 Gen8 主板是 Intel C204 芯片组，也就是 Intel 6 Series/C200 系列芯片组，对应的 RST 版本应该是 <a href="https://www.techspot.com/drivers/driver/file/information/17341/" target="_blank" rel="noopener">12.8.0.1016</a>。很遗憾，不管是 Intel <a href="https://downloadcenter.intel.com/zh-cn/download/29339/-RST-" target="_blank" rel="noopener">中文</a>还是<a href="https://downloadcenter.intel.com/download/29094/Intel-Rapid-Storage-Technology-Intel-RST-User-Interface-and-Driver" target="_blank" rel="noopener">英文</a>官网都没有找到该版本的驱动程序。</p><p>正在要放弃的时候，发现了一根<a href="https://www.chiphell.com/forum.php?mod=redirect&amp;goto=findpost&amp;ptid=1037686&amp;pid=23415933" target="_blank" rel="noopener">救命稻草</a>，这里分享了一个地址： <a href="http://pan.baidu.com/s/1ntLTF65" target="_blank" rel="noopener">http://pan.baidu.com/s/1ntLTF65</a> 。赶紧下载下来，将 exe 解压（注意不要直接打开安装），找到 <code>Chipset_Intel_9.3.0.1025\Intel\All\cougahci.cat</code> 和 <code>cougahci.inf</code>，将这两个文件拷出来放到 U 盘或者用 iLO 加载至可移动设备，在 Windows 安装分区选择界面加载驱动程序时加载进去，再安装，问题完美解决，系统成功安装！（但这个驱动版本并不是 <code>12.8.0.1016</code>，只要 AHCI 驱动兼容就可以了。）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我的 NAS 的配置是 HP Gen8 + Intel 志强 1220L v2，之前用 1T 的机械硬盘作为系统盘，因为感觉日常 IO 速度有些慢，恰好台式电脑淘汰下一个 Samsung 860 EVO SSD，所以决定替换磁盘。而此前一直是 Debian 10 + Windows Server 2008 R2 双系统，Linux 备份还原很简单，&lt;code&gt;dd&lt;/code&gt; 命令使用起来非常方便，用 LiveCD chroot 刷新一次 grub 即可，但 Windows 就要重新安装和配置了。&lt;/p&gt;&lt;p&gt;因为 Windows 安装程序会覆盖掉硬盘的主引导记录 (MBR)，所以一般是先安装 Windows，再安装 Linux 用 grub 重写 MBR。&lt;/p&gt;&lt;p&gt;然而，当我认为一切尽在掌握之时，Windows Server 2008 R2 的安装程序在复制完文件重启配置时弹出“Windows 安装程序无法将 Windows 配置为在此计算机的硬件上运行”错误，然后就中断重启了。&lt;/p&gt;&lt;img src=&quot;/hexo-blog/20200324/解决%20“Windows%20安装程序无法将%20Windows%20配置为在此计算机的硬件上运行”/error.jpg&quot;&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="NAS" scheme="http://whypro.github.io/hexo-blog/tags/NAS/"/>
    
      <category term="Windows" scheme="http://whypro.github.io/hexo-blog/tags/Windows/"/>
    
      <category term="Intel" scheme="http://whypro.github.io/hexo-blog/tags/Intel/"/>
    
      <category term="固态硬盘" scheme="http://whypro.github.io/hexo-blog/tags/%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/"/>
    
      <category term="SSD" scheme="http://whypro.github.io/hexo-blog/tags/SSD/"/>
    
  </entry>
  
  <entry>
    <title>2020 年 3 月手记</title>
    <link href="http://whypro.github.io/hexo-blog/20200308/2020-%E5%B9%B4-3-%E6%9C%88%E6%89%8B%E8%AE%B0/"/>
    <id>http://whypro.github.io/hexo-blog/20200308/2020-年-3-月手记/</id>
    <published>2020-03-08T12:59:00.000Z</published>
    <updated>2020-05-03T15:27:01.898Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><h3 id="client-go-leader-election-源码分析"><a href="#client-go-leader-election-源码分析" class="headerlink" title="client-go leader election 源码分析"></a>client-go leader election 源码分析</h3><p><a href="https://zhengyinyong.com/post/kubernetes-pod-leader-election/" target="_blank" rel="noopener">https://zhengyinyong.com/post/kubernetes-pod-leader-election/</a></p><p><a href="https://mathspanda.github.io/2017/05/11/k8s-leader-election/" target="_blank" rel="noopener">https://mathspanda.github.io/2017/05/11/k8s-leader-election/</a></p><h3 id="kubernetes-networks"><a href="#kubernetes-networks" class="headerlink" title="kubernetes networks"></a>kubernetes networks</h3><p><a href="https://draveness.me/kubernetes-service" target="_blank" rel="noopener">https://draveness.me/kubernetes-service</a></p><p><a href="https://blog.scottlowe.org/2013/09/04/introducing-linux-network-namespaces/" target="_blank" rel="noopener">https://blog.scottlowe.org/2013/09/04/introducing-linux-network-namespaces/</a></p><p><a href="https://www.cyberciti.biz/faq/linux-ip-command-examples-usage-syntax/" target="_blank" rel="noopener">https://www.cyberciti.biz/faq/linux-ip-command-examples-usage-syntax/</a></p><h3 id="kubectl-plugin"><a href="#kubectl-plugin" class="headerlink" title="kubectl plugin"></a>kubectl plugin</h3><p><a href="https://kubernetes.io/docs/tasks/extend-kubectl/kubectl-plugins/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/extend-kubectl/kubectl-plugins/</a></p><p><a href="https://github.com/fatsheep9146/kubectl-pvc" target="_blank" rel="noopener">https://github.com/fatsheep9146/kubectl-pvc</a></p><a id="more"></a><h2 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h2><h3 id="compress-qcow2-images"><a href="#compress-qcow2-images" class="headerlink" title="compress qcow2 images"></a>compress qcow2 images</h3><p><a href="https://wiki.liutyi.info/display/DEVOPS/compress+qcow2+images" target="_blank" rel="noopener">https://wiki.liutyi.info/display/DEVOPS/compress+qcow2+images</a></p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="cgroup-page-cache-accounting"><a href="#cgroup-page-cache-accounting" class="headerlink" title="cgroup page cache accounting"></a>cgroup page cache accounting</h3><p><a href="https://serverfault.com/questions/903432/page-cache-usage-listed-in-cgroups-memory-stat-file" target="_blank" rel="noopener">https://serverfault.com/questions/903432/page-cache-usage-listed-in-cgroups-memory-stat-file</a></p><p><a href="https://www.kernel.org/doc/Documentation/cgroup-v1/memory.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/cgroup-v1/memory.txt</a></p><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><h3 id="go-101"><a href="#go-101" class="headerlink" title="go 101"></a>go 101</h3><p><a href="https://github.com/go101/go101" target="_blank" rel="noopener">https://github.com/go101/go101</a></p><p><a href="https://gfw.go101.org/article/101.html" target="_blank" rel="noopener">https://gfw.go101.org/article/101.html</a></p><h2 id="Productive"><a href="#Productive" class="headerlink" title="Productive"></a>Productive</h2><h3 id="alfred"><a href="#alfred" class="headerlink" title="alfred"></a>alfred</h3><p><a href="https://sspai.com/post/55553" target="_blank" rel="noopener">https://sspai.com/post/55553</a></p><p><a href="https://sspai.com/post/32979" target="_blank" rel="noopener">https://sspai.com/post/32979</a></p><p><a href="https://sspai.com/post/32457" target="_blank" rel="noopener">https://sspai.com/post/32457</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="tensorflow-教程"><a href="#tensorflow-教程" class="headerlink" title="tensorflow 教程"></a>tensorflow 教程</h3><p><a href="https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/</a></p><p><a href="https://www.tensorflow.org/tutorials/quickstart/beginner?hl=zh-cn" target="_blank" rel="noopener">https://www.tensorflow.org/tutorials/quickstart/beginner?hl=zh-cn</a></p><p><a href="https://github.com/machinelearningmindset/TensorFlow-Course" target="_blank" rel="noopener">https://github.com/machinelearningmindset/TensorFlow-Course</a></p><h3 id="分布式锁的实现"><a href="#分布式锁的实现" class="headerlink" title="分布式锁的实现"></a>分布式锁的实现</h3><p><a href="https://juejin.im/post/5bbb0d8df265da0abd3533a5" target="_blank" rel="noopener">https://juejin.im/post/5bbb0d8df265da0abd3533a5</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Kubernetes&quot;&gt;&lt;a href=&quot;#Kubernetes&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes&quot;&gt;&lt;/a&gt;Kubernetes&lt;/h2&gt;&lt;h3 id=&quot;client-go-leader-election-源码分析&quot;&gt;&lt;a href=&quot;#client-go-leader-election-源码分析&quot; class=&quot;headerlink&quot; title=&quot;client-go leader election 源码分析&quot;&gt;&lt;/a&gt;client-go leader election 源码分析&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://zhengyinyong.com/post/kubernetes-pod-leader-election/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhengyinyong.com/post/kubernetes-pod-leader-election/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mathspanda.github.io/2017/05/11/k8s-leader-election/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mathspanda.github.io/2017/05/11/k8s-leader-election/&lt;/a&gt;&lt;/p&gt;&lt;h3 id=&quot;kubernetes-networks&quot;&gt;&lt;a href=&quot;#kubernetes-networks&quot; class=&quot;headerlink&quot; title=&quot;kubernetes networks&quot;&gt;&lt;/a&gt;kubernetes networks&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://draveness.me/kubernetes-service&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://draveness.me/kubernetes-service&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.scottlowe.org/2013/09/04/introducing-linux-network-namespaces/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.scottlowe.org/2013/09/04/introducing-linux-network-namespaces/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.cyberciti.biz/faq/linux-ip-command-examples-usage-syntax/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cyberciti.biz/faq/linux-ip-command-examples-usage-syntax/&lt;/a&gt;&lt;/p&gt;&lt;h3 id=&quot;kubectl-plugin&quot;&gt;&lt;a href=&quot;#kubectl-plugin&quot; class=&quot;headerlink&quot; title=&quot;kubectl plugin&quot;&gt;&lt;/a&gt;kubectl plugin&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/docs/tasks/extend-kubectl/kubectl-plugins/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://kubernetes.io/docs/tasks/extend-kubectl/kubectl-plugins/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/fatsheep9146/kubectl-pvc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/fatsheep9146/kubectl-pvc&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="云计算" scheme="http://whypro.github.io/hexo-blog/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Golang" scheme="http://whypro.github.io/hexo-blog/tags/Golang/"/>
    
      <category term="Kubernetes" scheme="http://whypro.github.io/hexo-blog/tags/Kubernetes/"/>
    
      <category term="K8S" scheme="http://whypro.github.io/hexo-blog/tags/K8S/"/>
    
      <category term="笔记" scheme="http://whypro.github.io/hexo-blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2020 年 2 月手记</title>
    <link href="http://whypro.github.io/hexo-blog/20200216/2020-%E5%B9%B4-2-%E6%9C%88%E6%89%8B%E8%AE%B0/"/>
    <id>http://whypro.github.io/hexo-blog/20200216/2020-年-2-月手记/</id>
    <published>2020-02-16T08:44:00.000Z</published>
    <updated>2020-05-03T15:22:07.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><h3 id="deletion-timestamp"><a href="#deletion-timestamp" class="headerlink" title="deletion timestamp"></a>deletion timestamp</h3><p>如果 Pod 的 <code>DeletionGracePeriodSeconds</code> 与 <code>TerminationGracePeriodSeconds</code> 同时存在时，哪个生效？</p><p><a href="https://sourcegraph.com/github.com/anfernee11/kubernetes/-/commit/72ee028cab61493d2180782114a1e54281b5b4d1" target="_blank" rel="noopener">kubelet 代码</a>里 <code>DeletionGracePeriodSeconds</code> 的优先级高。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Kubernetes&quot;&gt;&lt;a href=&quot;#Kubernetes&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes&quot;&gt;&lt;/a&gt;Kubernetes&lt;/h2&gt;&lt;h3 id=&quot;deletion-timestamp&quot;&gt;&lt;a href=&quot;#del
      
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="云计算" scheme="http://whypro.github.io/hexo-blog/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Kubernetes" scheme="http://whypro.github.io/hexo-blog/tags/Kubernetes/"/>
    
      <category term="K8S" scheme="http://whypro.github.io/hexo-blog/tags/K8S/"/>
    
      <category term="笔记" scheme="http://whypro.github.io/hexo-blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2020 年 1 月手记</title>
    <link href="http://whypro.github.io/hexo-blog/20200109/2020-%E5%B9%B4-1-%E6%9C%88%E6%89%8B%E8%AE%B0/"/>
    <id>http://whypro.github.io/hexo-blog/20200109/2020-年-1-月手记/</id>
    <published>2020-01-09T00:54:00.000Z</published>
    <updated>2020-05-03T15:22:01.072Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><h3 id="kubernetes-dynamic-client"><a href="#kubernetes-dynamic-client" class="headerlink" title="kubernetes dynamic client"></a>kubernetes dynamic client</h3><p>typed client 接收固定类型的对象，只能对固定类型对象进行操作。dynamic client 我们只要告诉它 group，version，kind 信息，传入 unstructured object，便可操作“任意类型”的对象。</p><p><a href="https://stackoverflow.com/questions/53341727/how-to-submit-generic-runtime-object-to-kubernetes-api-using-client-go" target="_blank" rel="noopener">https://stackoverflow.com/questions/53341727/how-to-submit-generic-runtime-object-to-kubernetes-api-using-client-go</a></p><p><a href="https://soggy.space/namespaced-crds-dynamic-client/" target="_blank" rel="noopener">https://soggy.space/namespaced-crds-dynamic-client/</a></p><p><a href="https://www.oreilly.com/library/view/programming-kubernetes/9781492047094/ch04.html" target="_blank" rel="noopener">https://www.oreilly.com/library/view/programming-kubernetes/9781492047094/ch04.html</a></p><h3 id="node-topology-manager"><a href="#node-topology-manager" class="headerlink" title="node topology manager"></a>node topology manager</h3><p>node topology manager 在绑核时可以感知设备拓扑（例如 NUMA Node）：</p><p><a href="https://github.com/kubernetes/kubernetes/issues/49964" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/issues/49964</a></p><p><a href="https://docs.google.com/document/d/1lSwVh2ZfJ2FeLXIeyyiNqN_hKPYpahJiwN5X5cszjOk/edit#" target="_blank" rel="noopener">https://docs.google.com/document/d/1lSwVh2ZfJ2FeLXIeyyiNqN_hKPYpahJiwN5X5cszjOk/edit#</a></p><p><a href="https://upcommons.upc.edu/bitstream/handle/2117/114851/Topology-Aware%20GPU%20Scheduling%20for%20Learning%20Workloads.pdf" target="_blank" rel="noopener">https://upcommons.upc.edu/bitstream/handle/2117/114851/Topology-Aware%20GPU%20Scheduling%20for%20Learning%20Workloads.pdf</a></p><p><a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/0035-20190130-topology-manager.md" target="_blank" rel="noopener">https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/0035-20190130-topology-manager.md</a></p><a id="more"></a><h3 id="sealos"><a href="#sealos" class="headerlink" title="sealos"></a>sealos</h3><p>一个生产环境可以使用的 Kubernetes 高可用方案</p><p><a href="https://github.com/fanux/sealos" target="_blank" rel="noopener">https://github.com/fanux/sealos</a></p><h3 id="openebs"><a href="#openebs" class="headerlink" title="openebs"></a>openebs</h3><p><a href="https://docs.openebs.io/" target="_blank" rel="noopener">https://docs.openebs.io/</a></p><p><a href="https://github.com/openebs/openebs" target="_blank" rel="noopener">https://github.com/openebs/openebs</a></p><h3 id="Pod-Readiness-Gate"><a href="#Pod-Readiness-Gate" class="headerlink" title="Pod Readiness Gate"></a>Pod Readiness Gate</h3><p>第三方组件通过该接口，可以主动设置 Pod 的 Ready 状态，从而控制 endpoints 的更新。</p><p><a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate</a></p><p><a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-network/0007-pod-ready%2B%2B.md" target="_blank" rel="noopener">https://github.com/kubernetes/enhancements/blob/master/keps/sig-network/0007-pod-ready%2B%2B.md</a></p><p><a href="https://docs.google.com/document/d/1VFZbc_IqPf_Msd-jul7LKTmGjvQ5qRldYOFV0lGqxf8/edit#" target="_blank" rel="noopener">https://docs.google.com/document/d/1VFZbc_IqPf_Msd-jul7LKTmGjvQ5qRldYOFV0lGqxf8/edit#</a></p><h3 id="client-go-informer"><a href="#client-go-informer" class="headerlink" title="client-go informer"></a>client-go informer</h3><p><a href="https://blog.csdn.net/weixin_42663840/article/details/81699303" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42663840/article/details/81699303</a></p><h3 id="kubernetes-gitlab-repository"><a href="#kubernetes-gitlab-repository" class="headerlink" title="kubernetes gitlab repository"></a>kubernetes gitlab repository</h3><p><a href="https://gitlab.cncf.ci/kubernetes/kubernetes" target="_blank" rel="noopener">https://gitlab.cncf.ci/kubernetes/kubernetes</a></p><h3 id="eBay-Search-On-K8s-Mohnish-Kodnani-amp-Yashwanth-Vempati-eBay"><a href="#eBay-Search-On-K8s-Mohnish-Kodnani-amp-Yashwanth-Vempati-eBay" class="headerlink" title="eBay Search On K8s - Mohnish Kodnani &amp; Yashwanth Vempati, eBay"></a>eBay Search On K8s - Mohnish Kodnani &amp; Yashwanth Vempati, eBay</h3><p><a href="https://www.youtube.com/watch?v=chGN44Kqpd8" target="_blank" rel="noopener">https://www.youtube.com/watch?v=chGN44Kqpd8</a></p><h2 id="Networks"><a href="#Networks" class="headerlink" title="Networks"></a>Networks</h2><h3 id="tcpdump-教程"><a href="#tcpdump-教程" class="headerlink" title="tcpdump 教程"></a>tcpdump 教程</h3><p><a href="https://danielmiessler.com/study/tcpdump/" target="_blank" rel="noopener">https://danielmiessler.com/study/tcpdump/</a></p><h3 id="socket-编程"><a href="#socket-编程" class="headerlink" title="socket 编程"></a>socket 编程</h3><p><a href="https://www.geeksforgeeks.org/socket-programming-cc/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/socket-programming-cc/</a></p><h3 id="tcp-server-实现"><a href="#tcp-server-实现" class="headerlink" title="tcp server 实现"></a>tcp server 实现</h3><p><a href="https://www.geeksforgeeks.org/tcp-server-client-implementation-in-c/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/tcp-server-client-implementation-in-c/</a></p><h3 id="udp-server-实现"><a href="#udp-server-实现" class="headerlink" title="udp server 实现"></a>udp server 实现</h3><p><a href="https://www.geeksforgeeks.org/udp-server-client-implementation-c/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/udp-server-client-implementation-c/</a></p><p><a href="https://linuxacademy.com/blog/linux/netstat-network-analysis-and-troubleshooting-explained/" target="_blank" rel="noopener">https://linuxacademy.com/blog/linux/netstat-network-analysis-and-troubleshooting-explained/</a></p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="资源限制rlimit-nofile的调整细节及内部实现"><a href="#资源限制rlimit-nofile的调整细节及内部实现" class="headerlink" title="资源限制rlimit_nofile的调整细节及内部实现"></a>资源限制rlimit_nofile的调整细节及内部实现</h3><p><a href="https://wweir.cc/post/%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6rlimit_nofile%E7%9A%84%E8%B0%83%E6%95%B4%E7%BB%86%E8%8A%82%E5%8F%8A%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">https://wweir.cc/post/%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6rlimit_nofile%E7%9A%84%E8%B0%83%E6%95%B4%E7%BB%86%E8%8A%82%E5%8F%8A%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0/</a></p><h3 id="模拟进程-d-状态"><a href="#模拟进程-d-状态" class="headerlink" title="模拟进程 d 状态"></a>模拟进程 d 状态</h3><p><a href="https://unix.stackexchange.com/questions/134888/simulate-an-unkillable-process-in-d-state" target="_blank" rel="noopener">https://unix.stackexchange.com/questions/134888/simulate-an-unkillable-process-in-d-state</a></p><h3 id="cfs-throttling-issues"><a href="#cfs-throttling-issues" class="headerlink" title="cfs throttling issues"></a>cfs throttling issues</h3><p><a href="https://www.youtube.com/watch?v=UE7QX98-kO0" target="_blank" rel="noopener">https://www.youtube.com/watch?v=UE7QX98-kO0</a></p><p><a href="https://github.com/kubernetes/kubernetes/issues/67577" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/issues/67577</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Kubernetes&quot;&gt;&lt;a href=&quot;#Kubernetes&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes&quot;&gt;&lt;/a&gt;Kubernetes&lt;/h2&gt;&lt;h3 id=&quot;kubernetes-dynamic-client&quot;&gt;&lt;a href=&quot;#kubernetes-dynamic-client&quot; class=&quot;headerlink&quot; title=&quot;kubernetes dynamic client&quot;&gt;&lt;/a&gt;kubernetes dynamic client&lt;/h3&gt;&lt;p&gt;typed client 接收固定类型的对象，只能对固定类型对象进行操作。dynamic client 我们只要告诉它 group，version，kind 信息，传入 unstructured object，便可操作“任意类型”的对象。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/53341727/how-to-submit-generic-runtime-object-to-kubernetes-api-using-client-go&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://stackoverflow.com/questions/53341727/how-to-submit-generic-runtime-object-to-kubernetes-api-using-client-go&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://soggy.space/namespaced-crds-dynamic-client/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://soggy.space/namespaced-crds-dynamic-client/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.oreilly.com/library/view/programming-kubernetes/9781492047094/ch04.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oreilly.com/library/view/programming-kubernetes/9781492047094/ch04.html&lt;/a&gt;&lt;/p&gt;&lt;h3 id=&quot;node-topology-manager&quot;&gt;&lt;a href=&quot;#node-topology-manager&quot; class=&quot;headerlink&quot; title=&quot;node topology manager&quot;&gt;&lt;/a&gt;node topology manager&lt;/h3&gt;&lt;p&gt;node topology manager 在绑核时可以感知设备拓扑（例如 NUMA Node）：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/kubernetes/issues/49964&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/kubernetes/kubernetes/issues/49964&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://docs.google.com/document/d/1lSwVh2ZfJ2FeLXIeyyiNqN_hKPYpahJiwN5X5cszjOk/edit#&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.google.com/document/d/1lSwVh2ZfJ2FeLXIeyyiNqN_hKPYpahJiwN5X5cszjOk/edit#&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://upcommons.upc.edu/bitstream/handle/2117/114851/Topology-Aware%20GPU%20Scheduling%20for%20Learning%20Workloads.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://upcommons.upc.edu/bitstream/handle/2117/114851/Topology-Aware%20GPU%20Scheduling%20for%20Learning%20Workloads.pdf&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/0035-20190130-topology-manager.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/0035-20190130-topology-manager.md&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="云计算" scheme="http://whypro.github.io/hexo-blog/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Kubernetes" scheme="http://whypro.github.io/hexo-blog/tags/Kubernetes/"/>
    
      <category term="K8S" scheme="http://whypro.github.io/hexo-blog/tags/K8S/"/>
    
      <category term="笔记" scheme="http://whypro.github.io/hexo-blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2019 年 10 月手记</title>
    <link href="http://whypro.github.io/hexo-blog/20191009/2019-%E5%B9%B4-10-%E6%9C%88%E6%89%8B%E8%AE%B0/"/>
    <id>http://whypro.github.io/hexo-blog/20191009/2019-年-10-月手记/</id>
    <published>2019-10-09T13:28:00.000Z</published>
    <updated>2020-05-03T15:21:53.697Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><h3 id="etcd-运维文档"><a href="#etcd-运维文档" class="headerlink" title="etcd 运维文档"></a>etcd 运维文档</h3><p><a href="https://github.com/etcd-io/etcd/blob/master/Documentation/op-guide/maintenance.md" target="_blank" rel="noopener">https://github.com/etcd-io/etcd/blob/master/Documentation/op-guide/maintenance.md</a></p><h3 id="etcd-压测"><a href="#etcd-压测" class="headerlink" title="etcd 压测"></a>etcd 压测</h3><p>不断写入同一个 key，产生大量 revision。<br>可以通过 compact 和 defrag 解决。</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">while</span> [ 1 ]; <span class="hljs-keyword">do</span></span><br><span class="line">  dd <span class="hljs-keyword">if</span>=/dev/urandom bs=1024 count=1024 | ETCDCTL_API=3 ./etcdctl --endpoints=https://10.0.2.15:2379 --cacert=/etc/kubernetes/pki/etcd/ca.crt --cert=/etc/kubernetes/pki/etcd/server.crt --key=/etc/kubernetes/pki/etcd/server.key put /<span class="hljs-built_in">test</span> || <span class="hljs-built_in">break</span></span><br><span class="line"><span class="hljs-keyword">done</span></span><br></pre></td></tr></table></figure><p>写入不同的 key。<br>通过删除 key 解决。</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> &#123;1..10&#125;; <span class="hljs-keyword">do</span></span><br><span class="line">  dd <span class="hljs-keyword">if</span>=/dev/urandom bs=1024 count=1024 | ETCDCTL_API=3 ./etcdctl --endpoints=https://10.0.2.15:2379 --cacert=/etc/kubernetes/pki/etcd/ca.crt --cert=/etc/kubernetes/pki/etcd/server.crt --key=/etc/kubernetes/pki/etcd/server.key put /<span class="hljs-built_in">test</span>/key/<span class="hljs-variable">$&#123;j&#125;</span> || <span class="hljs-built_in">break</span></span><br><span class="line"><span class="hljs-keyword">done</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="node-shutdown-KEP"><a href="#node-shutdown-KEP" class="headerlink" title="node shutdown KEP"></a>node shutdown KEP</h3><p>提出了一种安全处理节点宕机或节点重启时，有状态服务故障自动恢复的方案：</p><p><a href="https://github.com/kubernetes/enhancements/pull/1116/files" target="_blank" rel="noopener">https://github.com/kubernetes/enhancements/pull/1116/files</a></p><h3 id="cloud-controller-manager"><a href="#cloud-controller-manager" class="headerlink" title="cloud controller manager"></a>cloud controller manager</h3><p>自定义 cloud controller manager 的实现：</p><p><a href="https://kubernetes.io/docs/tasks/administer-cluster/running-cloud-controller/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/administer-cluster/running-cloud-controller/</a></p><p><a href="https://kubernetes.io/docs/tasks/administer-cluster/developing-cloud-controller-manager/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/administer-cluster/developing-cloud-controller-manager/</a></p><h3 id="pod-disruption-budget-简介"><a href="#pod-disruption-budget-简介" class="headerlink" title="pod disruption budget 简介"></a>pod disruption budget 简介</h3><p><a href="https://kubernetes.io/docs/tasks/run-application/configure-pdb/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/run-application/configure-pdb/</a></p><h3 id="kubetest"><a href="#kubetest" class="headerlink" title="kubetest"></a>kubetest</h3><p><a href="https://github.com/vapor-ware/kubetest" target="_blank" rel="noopener">https://github.com/vapor-ware/kubetest</a></p><p><a href="https://kubetest.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">https://kubetest.readthedocs.io/en/latest/index.html</a></p><h2 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h2><h3 id="KVM-各种管理工具"><a href="#KVM-各种管理工具" class="headerlink" title="KVM 各种管理工具"></a>KVM 各种管理工具</h3><p><a href="https://www.linux-kvm.org/page/Management_Tools" target="_blank" rel="noopener">https://www.linux-kvm.org/page/Management_Tools</a></p><h3 id="KVM-cloud-image-的使用"><a href="#KVM-cloud-image-的使用" class="headerlink" title="KVM cloud image 的使用"></a>KVM cloud image 的使用</h3><p><a href="https://serverascode.com/2018/06/26/using-cloud-images.html" target="_blank" rel="noopener">https://serverascode.com/2018/06/26/using-cloud-images.html</a></p><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><h3 id="golang-flag"><a href="#golang-flag" class="headerlink" title="golang flag"></a>golang flag</h3><p><a href="https://medium.com/what-i-talk-about-when-i-talk-about-technology/dealing-with-command-line-options-in-golang-flag-package-e5fb6ef1a79e" target="_blank" rel="noopener">https://medium.com/what-i-talk-about-when-i-talk-about-technology/dealing-with-command-line-options-in-golang-flag-package-e5fb6ef1a79e</a></p><p><a href="https://blog.rapid7.com/2016/08/04/build-a-simple-cli-tool-with-golang/" target="_blank" rel="noopener">https://blog.rapid7.com/2016/08/04/build-a-simple-cli-tool-with-golang/</a></p><h2 id="Productive"><a href="#Productive" class="headerlink" title="Productive"></a>Productive</h2><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>将 gfwlist 转换为 privoxy 配置：</p><p><a href="https://github.com/snachx/gfwlist2privoxy" target="_blank" rel="noopener">https://github.com/snachx/gfwlist2privoxy</a></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install gfwlist2privoxy</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gfwlist2privoxy -f gfwlist.action -p 127.0.0.1:1080 -t socks5t</span><br></pre></td></tr></table></figure><p><code>/etc/privoxy/config</code></p><p><code>actionsfile gfwlist.action</code></p><h3 id="inlets"><a href="#inlets" class="headerlink" title="inlets"></a>inlets</h3><p><a href="https://github.com/inlets/inlets" target="_blank" rel="noopener">https://github.com/inlets/inlets</a><br><a href="https://blog.alexellis.io/https-inlets-local-endpoints/" target="_blank" rel="noopener">https://blog.alexellis.io/https-inlets-local-endpoints/</a></p><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><h3 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h3><p><a href="https://www.cnblogs.com/sunddenly/p/4143306.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunddenly/p/4143306.html</a></p><p><a href="https://zhukeyao.wordpress.com/2016/11/15/understanding-paxosraftzab-algorithm/" target="_blank" rel="noopener">https://zhukeyao.wordpress.com/2016/11/15/understanding-paxosraftzab-algorithm/</a></p><h3 id="HepollC-Server"><a href="#HepollC-Server" class="headerlink" title="HepollC Server"></a>HepollC Server</h3><p>HepollC Server 是以C语言开发的单进程异步高性能 http 服务器框架，实现了 PostgreSQL、Oracle 异步调用，异步 http(s)客户端，array、dict 等数据结构，以共享库形式实现灵活扩展。</p><p><a href="http://www.1hua.top/hepollc.html" target="_blank" rel="noopener">http://www.1hua.top/hepollc.html</a></p><h3 id="Hux-Blog"><a href="#Hux-Blog" class="headerlink" title="Hux Blog"></a>Hux Blog</h3><p><a href="http://huangxuan.me/" target="_blank" rel="noopener">http://huangxuan.me/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Kubernetes&quot;&gt;&lt;a href=&quot;#Kubernetes&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes&quot;&gt;&lt;/a&gt;Kubernetes&lt;/h2&gt;&lt;h3 id=&quot;etcd-运维文档&quot;&gt;&lt;a href=&quot;#etcd-运维文档&quot; class=&quot;headerlink&quot; title=&quot;etcd 运维文档&quot;&gt;&lt;/a&gt;etcd 运维文档&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/etcd-io/etcd/blob/master/Documentation/op-guide/maintenance.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/etcd-io/etcd/blob/master/Documentation/op-guide/maintenance.md&lt;/a&gt;&lt;/p&gt;&lt;h3 id=&quot;etcd-压测&quot;&gt;&lt;a href=&quot;#etcd-压测&quot; class=&quot;headerlink&quot; title=&quot;etcd 压测&quot;&gt;&lt;/a&gt;etcd 压测&lt;/h3&gt;&lt;p&gt;不断写入同一个 key，产生大量 revision。&lt;br&gt;可以通过 compact 和 defrag 解决。&lt;/p&gt;&lt;figure class=&quot;highlight sh hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; [ 1 ]; &lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  dd &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;=/dev/urandom bs=1024 count=1024 | ETCDCTL_API=3 ./etcdctl --endpoints=https://10.0.2.15:2379 --cacert=/etc/kubernetes/pki/etcd/ca.crt --cert=/etc/kubernetes/pki/etcd/server.crt --key=/etc/kubernetes/pki/etcd/server.key put /&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt; || &lt;span class=&quot;hljs-built_in&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;done&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;写入不同的 key。&lt;br&gt;通过删除 key 解决。&lt;/p&gt;&lt;figure class=&quot;highlight sh hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &amp;#123;1..10&amp;#125;; &lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  dd &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;=/dev/urandom bs=1024 count=1024 | ETCDCTL_API=3 ./etcdctl --endpoints=https://10.0.2.15:2379 --cacert=/etc/kubernetes/pki/etcd/ca.crt --cert=/etc/kubernetes/pki/etcd/server.crt --key=/etc/kubernetes/pki/etcd/server.key put /&lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;/key/&lt;span class=&quot;hljs-variable&quot;&gt;$&amp;#123;j&amp;#125;&lt;/span&gt; || &lt;span class=&quot;hljs-built_in&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;done&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="云计算" scheme="http://whypro.github.io/hexo-blog/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Golang" scheme="http://whypro.github.io/hexo-blog/tags/Golang/"/>
    
      <category term="Kubernetes" scheme="http://whypro.github.io/hexo-blog/tags/Kubernetes/"/>
    
      <category term="K8S" scheme="http://whypro.github.io/hexo-blog/tags/K8S/"/>
    
      <category term="笔记" scheme="http://whypro.github.io/hexo-blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2019 年 9 月手记</title>
    <link href="http://whypro.github.io/hexo-blog/20190903/2019-%E5%B9%B4-9-%E6%9C%88%E6%89%8B%E8%AE%B0/"/>
    <id>http://whypro.github.io/hexo-blog/20190903/2019-年-9-月手记/</id>
    <published>2019-09-03T03:56:00.000Z</published>
    <updated>2020-05-03T15:21:49.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><h3 id="kubernetes-生产环境性能优化"><a href="#kubernetes-生产环境性能优化" class="headerlink" title="kubernetes 生产环境性能优化"></a>kubernetes 生产环境性能优化</h3><p><a href="https://caicloud.io/blog/57392eca8241681100000003" target="_blank" rel="noopener">https://caicloud.io/blog/57392eca8241681100000003</a></p><h3 id="容器内信息注入"><a href="#容器内信息注入" class="headerlink" title="容器内信息注入"></a>容器内信息注入</h3><p><a href="https://kubernetes.io/docs/concepts/storage/volumes/#using-subpath-with-expanded-environment-variables" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/storage/volumes/#using-subpath-with-expanded-environment-variables</a></p><p><a href="https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/#capabilities-of-the-downward-api" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/#capabilities-of-the-downward-api</a></p><h3 id="kubernetes-scheduler"><a href="#kubernetes-scheduler" class="headerlink" title="kubernetes scheduler"></a>kubernetes scheduler</h3><p><a href="https://ggaaooppeenngg.github.io/zh-CN/2017/09/26/kubernetes-%E6%8C%87%E5%8C%97/" target="_blank" rel="noopener">https://ggaaooppeenngg.github.io/zh-CN/2017/09/26/kubernetes-%E6%8C%87%E5%8C%97/</a></p><p><a href="https://caicloud.io/blog/57392eca8241681100000003" target="_blank" rel="noopener">https://caicloud.io/blog/57392eca8241681100000003</a></p><p><a href="https://coreos.com/blog/improving-kubernetes-scheduler-performance.html" target="_blank" rel="noopener">https://coreos.com/blog/improving-kubernetes-scheduler-performance.html</a></p><a id="more"></a><h3 id="kubernetes-cpu-manager"><a href="#kubernetes-cpu-manager" class="headerlink" title="kubernetes cpu manager"></a>kubernetes cpu manager</h3><p><a href="https://github.com/kubernetes/kubernetes/issues/67577" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/issues/67577</a></p><p><a href="https://kubernetes.io/blog/2018/07/24/feature-highlight-cpu-manager/" target="_blank" rel="noopener">https://kubernetes.io/blog/2018/07/24/feature-highlight-cpu-manager/</a></p><p><a href="https://cloud.tencent.com/developer/article/1402119" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1402119</a></p><p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/commit/?id=de53fd7aedb100f03e5d2231cfce0e4993282425" target="_blank" rel="noopener">https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/commit/?id=de53fd7aedb100f03e5d2231cfce0e4993282425</a></p><p><a href="https://bugzilla.kernel.org/show_bug.cgi?id=198197" target="_blank" rel="noopener">https://bugzilla.kernel.org/show_bug.cgi?id=198197</a></p><p><a href="https://gist.github.com/bobrik/2030ff040fad360327a5fab7a09c4ff1" target="_blank" rel="noopener">https://gist.github.com/bobrik/2030ff040fad360327a5fab7a09c4ff1</a></p><p><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/cpu-manager.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/cpu-manager.md</a></p><p><a href="https://www.slideshare.net/try_except_/ensuring-kubernetes-cost-efficiency-across-many-clusters-devops-gathering-2019" target="_blank" rel="noopener">https://www.slideshare.net/try_except_/ensuring-kubernetes-cost-efficiency-across-many-clusters-devops-gathering-2019</a></p><p><a href="https://github.com/kubernetes/kubernetes/issues/66614" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/issues/66614</a></p><p><a href="https://github.com/opencontainers/runc/issues/1635" target="_blank" rel="noopener">https://github.com/opencontainers/runc/issues/1635</a></p><p><a href="https://twitter.com/try_except_/status/1131459031376252928" target="_blank" rel="noopener">https://twitter.com/try_except_/status/1131459031376252928</a></p><p><a href="https://www.slideshare.net/try_except_/ensuring-kubernetes-cost-efficiency-across-many-clusters-devops-gathering-2019" target="_blank" rel="noopener">https://www.slideshare.net/try_except_/ensuring-kubernetes-cost-efficiency-across-many-clusters-devops-gathering-2019</a></p><h3 id="debug-kubernetes-service"><a href="#debug-kubernetes-service" class="headerlink" title="debug kubernetes service"></a>debug kubernetes service</h3><p>排查 kubernetes service 问题的步骤：</p><p><a href="https://kubernetes.io/docs/tasks/debug-application-cluster/debug-service/#does-the-service-work-by-ip" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/debug-application-cluster/debug-service/#does-the-service-work-by-ip</a></p><h3 id="关于容器内-sysctl-的问题"><a href="#关于容器内-sysctl-的问题" class="headerlink" title="关于容器内 sysctl 的问题"></a>关于容器内 sysctl 的问题</h3><p><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/sysctl.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/sysctl.md</a></p><p><a href="https://github.com/kubernetes/kubernetes/issues/29572#issuecomment-236193826" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/issues/29572#issuecomment-236193826</a></p><p><a href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt</a></p><p><a href="https://kubernetes.io/docs/tasks/configure-pod-container/security-context/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/configure-pod-container/security-context/</a></p><p><a href="https://github.com/moby/moby/issues/4611" target="_blank" rel="noopener">https://github.com/moby/moby/issues/4611</a></p><p><a href="https://github.com/moby/moby/issues/35993" target="_blank" rel="noopener">https://github.com/moby/moby/issues/35993</a></p><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><h3 id="镜像-sha256-地址"><a href="#镜像-sha256-地址" class="headerlink" title="镜像 sha256 地址"></a>镜像 sha256 地址</h3><p>根据镜像的 id 获取 sha256 地址：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image inspect --format=&apos;&#123;&#123;index .RepoDigests 0&#125;&#125;&apos; $&#123;IMAGE&#125;</span><br></pre></td></tr></table></figure><p>根据镜像的 sha256 地址拉取镜像：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2</span><br></pre></td></tr></table></figure><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="exit-code-和-signal-的对应关系"><a href="#exit-code-和-signal-的对应关系" class="headerlink" title="exit code 和 signal 的对应关系"></a>exit code 和 signal 的对应关系</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal = exit code - 128</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kill -l</span><br><span class="line"></span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL</span><br><span class="line"> 5) SIGTRAP      6) SIGABRT      7) SIGEMT       8) SIGFPE</span><br><span class="line"> 9) SIGKILL     10) SIGBUS      11) SIGSEGV     12) SIGSYS</span><br><span class="line">13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGUSR1</span><br><span class="line">17) SIGUSR2     18) SIGCHLD     19) SIGPWR      20) SIGWINCH</span><br><span class="line">21) SIGURG      22) SIGIO       23) SIGSTOP     24) SIGTSTP</span><br><span class="line">25) SIGCONT     26) SIGTTIN     27) SIGTTOU     28) SIGVTALRM</span><br><span class="line">29) SIGPROF     30) SIGXCPU     31) SIGXFSZ     32) SIGWAITING</span><br><span class="line">33) SIGLWP      34) SIGFREEZE   35) SIGTHAW     36) SIGCANCEL</span><br><span class="line">37) SIGLOST     38) SIGXRES     41) SIGRTMIN    42) SIGRTMIN+1</span><br><span class="line">43) SIGRTMIN+2  44) SIGRTMIN+3  45) SIGRTMAX-3  46) SIGRTMAX-2</span><br><span class="line">47) SIGRTMAX-1  48) SIGRTMAX</span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/23098695/strange-return-value-134-to-call-gawk-in-bash-script" target="_blank" rel="noopener">https://stackoverflow.com/questions/23098695/strange-return-value-134-to-call-gawk-in-bash-script</a></p><p>更详细的关于 linux exit code 的介绍：</p><p><a href="http://www.tldp.org/LDP/abs/html/exitcodes.html" target="_blank" rel="noopener">http://www.tldp.org/LDP/abs/html/exitcodes.html</a></p><h3 id="shell-学习"><a href="#shell-学习" class="headerlink" title="shell 学习"></a>shell 学习</h3><p><a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md" target="_blank" rel="noopener">https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md</a></p><p><a href="https://explainshell.com/" target="_blank" rel="noopener">https://explainshell.com/</a></p><p><a href="https://github.com/dylanaraps/pure-sh-bible" target="_blank" rel="noopener">https://github.com/dylanaraps/pure-sh-bible</a></p><h4 id="Advanced-Bash-Scripting-Guide"><a href="#Advanced-Bash-Scripting-Guide" class="headerlink" title="Advanced Bash-Scripting Guide"></a>Advanced Bash-Scripting Guide</h4><p><a href="https://www.tldp.org/LDP/abs/html/index.html" target="_blank" rel="noopener">https://www.tldp.org/LDP/abs/html/index.html</a></p><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><h3 id="一个用-golang-实现的执行-cron-定时任务的库"><a href="#一个用-golang-实现的执行-cron-定时任务的库" class="headerlink" title="一个用 golang 实现的执行 cron 定时任务的库"></a>一个用 golang 实现的执行 cron 定时任务的库</h3><p><a href="https://github.com/robfig/cron" target="_blank" rel="noopener">https://github.com/robfig/cron</a></p><h3 id="Testing-Your-HTTP-Handlers-in-Go"><a href="#Testing-Your-HTTP-Handlers-in-Go" class="headerlink" title="Testing Your (HTTP) Handlers in Go"></a>Testing Your (HTTP) Handlers in Go</h3><p><a href="https://blog.questionable.services/article/testing-http-handlers-go/" target="_blank" rel="noopener">https://blog.questionable.services/article/testing-http-handlers-go/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Kubernetes&quot;&gt;&lt;a href=&quot;#Kubernetes&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes&quot;&gt;&lt;/a&gt;Kubernetes&lt;/h2&gt;&lt;h3 id=&quot;kubernetes-生产环境性能优化&quot;&gt;&lt;a href=&quot;#kubernetes-生产环境性能优化&quot; class=&quot;headerlink&quot; title=&quot;kubernetes 生产环境性能优化&quot;&gt;&lt;/a&gt;kubernetes 生产环境性能优化&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://caicloud.io/blog/57392eca8241681100000003&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://caicloud.io/blog/57392eca8241681100000003&lt;/a&gt;&lt;/p&gt;&lt;h3 id=&quot;容器内信息注入&quot;&gt;&lt;a href=&quot;#容器内信息注入&quot; class=&quot;headerlink&quot; title=&quot;容器内信息注入&quot;&gt;&lt;/a&gt;容器内信息注入&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/docs/concepts/storage/volumes/#using-subpath-with-expanded-environment-variables&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://kubernetes.io/docs/concepts/storage/volumes/#using-subpath-with-expanded-environment-variables&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/#capabilities-of-the-downward-api&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/#capabilities-of-the-downward-api&lt;/a&gt;&lt;/p&gt;&lt;h3 id=&quot;kubernetes-scheduler&quot;&gt;&lt;a href=&quot;#kubernetes-scheduler&quot; class=&quot;headerlink&quot; title=&quot;kubernetes scheduler&quot;&gt;&lt;/a&gt;kubernetes scheduler&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://ggaaooppeenngg.github.io/zh-CN/2017/09/26/kubernetes-%E6%8C%87%E5%8C%97/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ggaaooppeenngg.github.io/zh-CN/2017/09/26/kubernetes-%E6%8C%87%E5%8C%97/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://caicloud.io/blog/57392eca8241681100000003&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://caicloud.io/blog/57392eca8241681100000003&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://coreos.com/blog/improving-kubernetes-scheduler-performance.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://coreos.com/blog/improving-kubernetes-scheduler-performance.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="云计算" scheme="http://whypro.github.io/hexo-blog/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Golang" scheme="http://whypro.github.io/hexo-blog/tags/Golang/"/>
    
      <category term="Docker" scheme="http://whypro.github.io/hexo-blog/tags/Docker/"/>
    
      <category term="Kubernetes" scheme="http://whypro.github.io/hexo-blog/tags/Kubernetes/"/>
    
      <category term="K8S" scheme="http://whypro.github.io/hexo-blog/tags/K8S/"/>
    
      <category term="笔记" scheme="http://whypro.github.io/hexo-blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2019 年 8 月手记</title>
    <link href="http://whypro.github.io/hexo-blog/20190801/2019-%E5%B9%B4-8-%E6%9C%88%E6%89%8B%E8%AE%B0/"/>
    <id>http://whypro.github.io/hexo-blog/20190801/2019-年-8-月手记/</id>
    <published>2019-08-01T12:05:00.000Z</published>
    <updated>2020-05-03T15:21:38.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><h3 id="object-GroupVersionKind-is-empty"><a href="#object-GroupVersionKind-is-empty" class="headerlink" title="object GroupVersionKind is empty"></a>object GroupVersionKind is empty</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>从 client-go （无论是从 server 还是 cache）获取到的 object 的 TypeMeta 为空</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pod := podLister.Pods(namespace).Get(name)</span><br><span class="line">gvk := pod.GetObjectKind().GroupVersionKind()</span><br><span class="line">fmt.Printf(&quot;%#v\n&quot;, gvk)</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GroupVersionKind&#123;Group:&quot;&quot;, Version:&quot;&quot;, Kind:&quot;&quot;&#125;</span><br></pre></td></tr></table></figure><p>(kubernetes 1.14)</p><a id="more"></a><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p><a href="https://github.com/kubernetes/client-go/issues/308#issuecomment-378165425" target="_blank" rel="noopener">https://github.com/kubernetes/client-go/issues/308#issuecomment-378165425</a></p><p><a href="https://github.com/kubernetes/kubernetes/pull/59264#issuecomment-362575608" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/pull/59264#issuecomment-362575608</a></p><p><a href="https://github.com/kubernetes/apiextensions-apiserver/issues/29#issuecomment-378057230" target="_blank" rel="noopener">https://github.com/kubernetes/apiextensions-apiserver/issues/29#issuecomment-378057230</a></p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>在需要 GVK 的地方，需要和 object 一起显式传入</p><p>controller-runtime 框架从 cache 中获取到对象之后设置了 GVK</p><p><a href="https://github.com/kubernetes-sigs/controller-runtime/pull/212" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/controller-runtime/pull/212</a></p><p><a href="https://github.com/kubernetes-sigs/controller-runtime/pull/389" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/controller-runtime/pull/389</a></p><h3 id="kubernetes-PATCH-operations"><a href="#kubernetes-PATCH-operations" class="headerlink" title="kubernetes PATCH operations"></a>kubernetes PATCH operations</h3><p>这篇文档介绍了 kubernetes PATCH 操作的三种策略：</p><p><a href="https://github.com/kubernetes/kubernetes/blob/release-1.1/docs/devel/api-conventions.md#patch-operations" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/blob/release-1.1/docs/devel/api-conventions.md#patch-operations</a></p><ul><li><p><a href="https://tools.ietf.org/html/rfc6902" target="_blank" rel="noopener">json patch</a></p></li><li><p><a href="https://tools.ietf.org/html/rfc7386" target="_blank" rel="noopener">json merge patch</a></p><p>是 json patch 的简化版</p></li><li><p>strategic merge patch</p><p>这篇文档介绍了 kubectl apply 的原理，比如如何通过 patchMergeKey 计算资源的改动，如何通过 strategic merge patch 更新资源：</p><p><a href="https://kubernetes.io/docs/tasks/manage-kubernetes-objects/declarative-config/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/manage-kubernetes-objects/declarative-config/</a></p></li></ul><p>这两篇文章分别介绍了如何通过 PATCH API 和 kubectl patch 对资源进行修改操作：</p><p><a href="https://dwmkerr.com/patching-kubernetes-resources-in-golang/" target="_blank" rel="noopener">https://dwmkerr.com/patching-kubernetes-resources-in-golang/</a></p><p><a href="https://kubernetes.io/docs/tasks/run-application/update-api-object-kubectl-patch/#notes-on-the-strategic-merge-patch" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/run-application/update-api-object-kubectl-patch/#notes-on-the-strategic-merge-patch</a></p><h3 id="daemonset-调度问题"><a href="#daemonset-调度问题" class="headerlink" title="daemonset 调度问题"></a>daemonset 调度问题</h3><p><a href="https://github.com/kubernetes/enhancements/issues/548" target="_blank" rel="noopener">https://github.com/kubernetes/enhancements/issues/548</a></p><p><a href="https://docs.google.com/document/d/10Ch3dhD88mnHYTq9q4jtX3e9e6gpndC78g5Ea6q4JY4/edit#" target="_blank" rel="noopener">https://docs.google.com/document/d/10Ch3dhD88mnHYTq9q4jtX3e9e6gpndC78g5Ea6q4JY4/edit#</a></p><p><a href="https://docs.google.com/document/d/1v7hsusMaeImQrOagktQb40ePbK6Jxp1hzgFB9OZa_ew/edit#" target="_blank" rel="noopener">https://docs.google.com/document/d/1v7hsusMaeImQrOagktQb40ePbK6Jxp1hzgFB9OZa_ew/edit#</a></p><p>node 从资源不足变为满足条件时，daemonset controller 感知不到</p><p><a href="https://github.com/kubernetes/kubernetes/issues/46935" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/issues/46935</a></p><p><a href="https://github.com/kubernetes/kubernetes/issues/45628" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/issues/45628</a></p><h3 id="webhook"><a href="#webhook" class="headerlink" title="webhook"></a>webhook</h3><p><a href="https://medium.com/ibm-cloud/diving-into-kubernetes-mutatingadmissionwebhook-6ef3c5695f74" target="_blank" rel="noopener">https://medium.com/ibm-cloud/diving-into-kubernetes-mutatingadmissionwebhook-6ef3c5695f74</a></p><p><a href="https://github.com/morvencao/kube-mutating-webhook-tutorial" target="_blank" rel="noopener">https://github.com/morvencao/kube-mutating-webhook-tutorial</a></p><h3 id="base-image"><a href="#base-image" class="headerlink" title="base image"></a>base image</h3><p><a href="https://github.com/kubernetes/kubernetes/issues/70249" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/issues/70249</a></p><p><a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-release/20190316-rebase-images-to-distroless.md" target="_blank" rel="noopener">https://github.com/kubernetes/enhancements/blob/master/keps/sig-release/20190316-rebase-images-to-distroless.md</a></p><p><a href="https://github.com/kubernetes/sig-release/blob/master/release-engineering/baseimage-exception-list.md" target="_blank" rel="noopener">https://github.com/kubernetes/sig-release/blob/master/release-engineering/baseimage-exception-list.md</a></p><h3 id="cilium"><a href="#cilium" class="headerlink" title="cilium"></a>cilium</h3><p><a href="https://cilium.io/blog/2019/08/20/cilium-16" target="_blank" rel="noopener">https://cilium.io/blog/2019/08/20/cilium-16</a></p><h3 id="kubectl-source-code"><a href="#kubectl-source-code" class="headerlink" title="kubectl source code"></a>kubectl source code</h3><p><a href="https://developer.ibm.com/opentech/2017/06/21/tour-kubernetes-source-code-part-one-kubectl-api-server/" target="_blank" rel="noopener">https://developer.ibm.com/opentech/2017/06/21/tour-kubernetes-source-code-part-one-kubectl-api-server/</a></p><h2 id="Productive"><a href="#Productive" class="headerlink" title="Productive"></a>Productive</h2><h3 id="iterm2-rz-sz"><a href="#iterm2-rz-sz" class="headerlink" title="iterm2 rz sz"></a>iterm2 rz sz</h3><p><a href="https://segmentfault.com/a/1190000012166969" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012166969</a></p><h3 id="Proxy-配置"><a href="#Proxy-配置" class="headerlink" title="Proxy 配置"></a>Proxy 配置</h3><p><a href="https://github.com/shadowsocks/shadowsocks/wiki/Convert-Shadowsocks-into-an-HTTP-proxy" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks/wiki/Convert-Shadowsocks-into-an-HTTP-proxy</a></p><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><h3 id="cgo"><a href="#cgo" class="headerlink" title="cgo"></a>cgo</h3><p><a href="https://blog.golang.org/c-go-cgo" target="_blank" rel="noopener">https://blog.golang.org/c-go-cgo</a></p><p><a href="https://golang.org/cmd/cgo/" target="_blank" rel="noopener">https://golang.org/cmd/cgo/</a></p><p><a href="https://golang.org/src/cmd/cgo/doc.go" target="_blank" rel="noopener">https://golang.org/src/cmd/cgo/doc.go</a></p><p><a href="https://dave.cheney.net/tag/cgo" target="_blank" rel="noopener">https://dave.cheney.net/tag/cgo</a></p><p><a href="https://dominik.honnef.co/posts/2015/06/statically_compiled_go_programs__always__even_with_cgo__using_musl/" target="_blank" rel="noopener">https://dominik.honnef.co/posts/2015/06/statically_compiled_go_programs__always__even_with_cgo__using_musl/</a></p><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><h3 id="braft"><a href="#braft" class="headerlink" title="braft"></a>braft</h3><p><a href="https://github.com/brpc/braft/blob/master/docs/cn/overview.md" target="_blank" rel="noopener">https://github.com/brpc/braft/blob/master/docs/cn/overview.md</a></p><h3 id="tcp-delayed-ack"><a href="#tcp-delayed-ack" class="headerlink" title="tcp delayed ack"></a>tcp delayed ack</h3><p><a href="https://serverfault.com/questions/834326/questions-about-nagle-vs-delayed-ack" target="_blank" rel="noopener">https://serverfault.com/questions/834326/questions-about-nagle-vs-delayed-ack</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Kubernetes&quot;&gt;&lt;a href=&quot;#Kubernetes&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes&quot;&gt;&lt;/a&gt;Kubernetes&lt;/h2&gt;&lt;h3 id=&quot;object-GroupVersionKind-is-empty&quot;&gt;&lt;a href=&quot;#object-GroupVersionKind-is-empty&quot; class=&quot;headerlink&quot; title=&quot;object GroupVersionKind is empty&quot;&gt;&lt;/a&gt;object GroupVersionKind is empty&lt;/h3&gt;&lt;h4 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h4&gt;&lt;p&gt;从 client-go （无论是从 server 还是 cache）获取到的 object 的 TypeMeta 为空&lt;/p&gt;&lt;figure class=&quot;highlight plain hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pod := podLister.Pods(namespace).Get(name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gvk := pod.GetObjectKind().GroupVersionKind()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fmt.Printf(&amp;quot;%#v\n&amp;quot;, gvk)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;figure class=&quot;highlight plain hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GroupVersionKind&amp;#123;Group:&amp;quot;&amp;quot;, Version:&amp;quot;&amp;quot;, Kind:&amp;quot;&amp;quot;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;(kubernetes 1.14)&lt;/p&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="云计算" scheme="http://whypro.github.io/hexo-blog/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Golang" scheme="http://whypro.github.io/hexo-blog/tags/Golang/"/>
    
      <category term="Docker" scheme="http://whypro.github.io/hexo-blog/tags/Docker/"/>
    
      <category term="Kubernetes" scheme="http://whypro.github.io/hexo-blog/tags/Kubernetes/"/>
    
      <category term="K8S" scheme="http://whypro.github.io/hexo-blog/tags/K8S/"/>
    
      <category term="笔记" scheme="http://whypro.github.io/hexo-blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2019 年 7 月手记</title>
    <link href="http://whypro.github.io/hexo-blog/20190719/2019-%E5%B9%B4-7-%E6%9C%88%E6%89%8B%E8%AE%B0/"/>
    <id>http://whypro.github.io/hexo-blog/20190719/2019-年-7-月手记/</id>
    <published>2019-07-19T15:40:09.000Z</published>
    <updated>2019-08-04T08:27:29.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><h3 id="api-conventions"><a href="#api-conventions" class="headerlink" title="api conventions"></a>api conventions</h3><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md</a></p><h3 id="kube-node-lease"><a href="#kube-node-lease" class="headerlink" title="kube node lease"></a>kube node lease</h3><p>kube node lease 用来改善 kubelet 定时更新节点状态对 etcd 造成的压力。</p><p><a href="https://containers.goffinet.org/k8s/kubectlget.html#what-about-kube-node-lease" target="_blank" rel="noopener">https://containers.goffinet.org/k8s/kubectlget.html#what-about-kube-node-lease</a></p><p><a href="https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/0009-node-heartbeat.md" target="_blank" rel="noopener">https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/0009-node-heartbeat.md</a></p><p><a href="https://kubernetes.io/docs/concepts/architecture/nodes/#node-controller" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/architecture/nodes/#node-controller</a></p><p><a href="https://github.com/kubernetes-sigs/kubespray/blob/master/docs/kubernetes-reliability.md" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/kubespray/blob/master/docs/kubernetes-reliability.md</a></p><a id="more"></a><h3 id="Finalizers"><a href="#Finalizers" class="headerlink" title="Finalizers"></a>Finalizers</h3><p><a href="https://book-v1.book.kubebuilder.io/beyond_basics/using_finalizers.html" target="_blank" rel="noopener">https://book-v1.book.kubebuilder.io/beyond_basics/using_finalizers.html</a></p><h3 id="controller-history"><a href="#controller-history" class="headerlink" title="controller history"></a>controller history</h3><p><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/apps/controller_history.md" target="_blank" rel="noopener">ControllerRevision</a> 是为 StatefulSet 和 DaemonSet 保存历史的资源类型。因为设计得比较通用，第三方控制器 + CRD 也可以借助它来实现版本管理。</p><h3 id="client-go-informer"><a href="#client-go-informer" class="headerlink" title="client-go informer"></a>client-go informer</h3><p><a href="https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md" target="_blank" rel="noopener">https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md</a></p><h3 id="kubebuilder"><a href="#kubebuilder" class="headerlink" title="kubebuilder"></a>kubebuilder</h3><p><a href="https://github.com/kubernetes-sigs/kubebuilder" target="_blank" rel="noopener">kubebuilder</a> 是开发第三方 controller 或 operator 的代码框架生成工具。它的实现基于 <a href="https://github.com/kubernetes-sigs/controller-runtime" target="_blank" rel="noopener">controller-runtime</a> 这个项目。</p><h3 id="Create-Kubernetes-Cluster"><a href="#Create-Kubernetes-Cluster" class="headerlink" title="Create Kubernetes Cluster"></a>Create Kubernetes Cluster</h3><p>使用 kubeadm 快速搭建一个可用的开发集群：</p><ol><li><p><a href="https://kubernetes.io/docs/setup/production-environment/container-runtimes/" target="_blank" rel="noopener">Install Container Runtimes</a></p></li><li><p><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">Get Docker CE for Ubuntu</a></p></li><li><p><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/" target="_blank" rel="noopener">Install kubeadm</a></p></li><li><p><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/" target="_blank" rel="noopener">Create Cluster</a></p></li><li><p><a href="https://docs.projectcalico.org/v3.8/getting-started/kubernetes/" target="_blank" rel="noopener">Install CNI Plugin</a></p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://docs.projectcalico.org/v3.8/manifests/calico.yaml</span><br></pre></td></tr></table></figure></li></ol><h3 id="KubeCon-2019-Videos"><a href="#KubeCon-2019-Videos" class="headerlink" title="KubeCon 2019 Videos"></a>KubeCon 2019 Videos</h3><p><a href="https://www.youtube.com/watch?v=5yKheFRMflQ&amp;list=PLj6h78yzYM2Njj5PvNc4Mtcril2YyR95d" target="_blank" rel="noopener">https://www.youtube.com/watch?v=5yKheFRMflQ&amp;list=PLj6h78yzYM2Njj5PvNc4Mtcril2YyR95d</a></p><h3 id="阿里技术"><a href="#阿里技术" class="headerlink" title="阿里技术"></a>阿里技术</h3><h4 id="基于多租户的虚拟集群"><a href="#基于多租户的虚拟集群" class="headerlink" title="基于多租户的虚拟集群"></a>基于多租户的虚拟集群</h4><p><a href="https://drive.google.com/file/d/1DX3jBwueEpSRhJ6n3VcqS1S3GDVvhF1B/view" target="_blank" rel="noopener">https://drive.google.com/file/d/1DX3jBwueEpSRhJ6n3VcqS1S3GDVvhF1B/view</a></p><p><a href="https://docs.google.com/document/d/1EELeVaduYZ65j4AXg9bp3Kyn38GKDU5fAJ5LFcxt2ZU/edit" target="_blank" rel="noopener">https://docs.google.com/document/d/1EELeVaduYZ65j4AXg9bp3Kyn38GKDU5fAJ5LFcxt2ZU/edit</a></p><h4 id="容器迁移"><a href="#容器迁移" class="headerlink" title="容器迁移"></a>容器迁移</h4><p><a href="http://blog.itpub.net/31555606/viewspace-2564791/" target="_blank" rel="noopener">“迁移策略+新容器运行时”应对有状态应用的冷热迁移挑战</a></p><h3 id="CRI"><a href="#CRI" class="headerlink" title="CRI"></a>CRI</h3><p><a href="https://medium.com/cri-o/container-runtimes-clarity-342b62172dc3" target="_blank" rel="noopener">Container runtimes: clarity</a></p><p><a href="https://github.com/kubernetes-sigs/cri-tools/blob/master/docs/crictl.md" target="_blank" rel="noopener">Container Runtime Interface (CRI) CLI</a></p><p><a href="https://github.com/containerd/cri/blob/master/docs/crictl.md" target="_blank" rel="noopener">CRICTL User Guide</a></p><h3 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h3><h4 id="Flex-Volume"><a href="#Flex-Volume" class="headerlink" title="Flex Volume"></a>Flex Volume</h4><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-storage/flexvolume.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-storage/flexvolume.md</a></p><p><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/flexvolume-deployment.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/flexvolume-deployment.md</a></p><h4 id="CSI"><a href="#CSI" class="headerlink" title="CSI"></a>CSI</h4><p><a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md</a></p><h3 id="Kubernetes-Handbook"><a href="#Kubernetes-Handbook" class="headerlink" title="Kubernetes Handbook"></a>Kubernetes Handbook</h3><p><a href="https://jimmysong.io/kubernetes-handbook/" target="_blank" rel="noopener">https://jimmysong.io/kubernetes-handbook/</a></p><h3 id="Kubernetes-testing"><a href="#Kubernetes-testing" class="headerlink" title="Kubernetes testing"></a>Kubernetes testing</h3><p><a href="https://jimmysong.io/kubernetes-handbook/develop/testing.html" target="_blank" rel="noopener">https://jimmysong.io/kubernetes-handbook/develop/testing.html</a></p><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/testing.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/testing.md</a></p><h4 id="integration-testing"><a href="#integration-testing" class="headerlink" title="integration testing"></a>integration testing</h4><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/integration-tests.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/integration-tests.md</a></p><h4 id="e2e-testing"><a href="#e2e-testing" class="headerlink" title="e2e testing"></a>e2e testing</h4><p><a href="https://kubernetes.io/blog/2019/03/22/kubernetes-end-to-end-testing-for-everyone/" target="_blank" rel="noopener">https://kubernetes.io/blog/2019/03/22/kubernetes-end-to-end-testing-for-everyone/</a></p><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/e2e-tests.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/e2e-tests.md</a></p><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/writing-good-e2e-tests.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-testing/writing-good-e2e-tests.md</a></p><p><a href="https://www.cnblogs.com/jinsdu/p/7465434.html" target="_blank" rel="noopener">https://www.cnblogs.com/jinsdu/p/7465434.html</a></p><p><a href="https://github.com/onsi/ginkgo" target="_blank" rel="noopener">https://github.com/onsi/ginkgo</a></p><p><a href="http://onsi.github.io/ginkgo/" target="_blank" rel="noopener">http://onsi.github.io/ginkgo/</a></p><p><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/conformance-tests.md" target="_blank" rel="noopener">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/conformance-tests.md</a></p><h4 id="可以参考的项目"><a href="#可以参考的项目" class="headerlink" title="可以参考的项目"></a>可以参考的项目</h4><ul><li><a href="https://github.com/kubernetes-sigs/sig-storage-local-static-provisioner" target="_blank" rel="noopener">local-static-provisioner</a></li><li><a href="https://github.com/kubernetes/kubernetes" target="_blank" rel="noopener">kubernetes</a></li><li><a href="https://github.com/openkruise/kruise" target="_blank" rel="noopener">kruise</a></li><li><a href="https://github.com/coreos/prometheus-operator" target="_blank" rel="noopener">prometheus-operator</a></li></ul><h3 id="deletion-and-garbage-collection"><a href="#deletion-and-garbage-collection" class="headerlink" title="deletion and garbage collection"></a>deletion and garbage collection</h3><p><a href="https://thenewstack.io/deletion-garbage-collection-kubernetes-objects/" target="_blank" rel="noopener">这篇文章</a> 介绍了 kubernetes 的删除和垃圾回收机制。</p><h3 id="ingress"><a href="#ingress" class="headerlink" title="ingress"></a>ingress</h3><p><a href="https://traefik.io/" target="_blank" rel="noopener">https://traefik.io/</a></p><h3 id="Useful-Commands"><a href="#Useful-Commands" class="headerlink" title="Useful Commands"></a>Useful Commands</h3><h4 id="查看-control-plane-状态"><a href="#查看-control-plane-状态" class="headerlink" title="查看 control-plane 状态"></a>查看 control-plane 状态</h4><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get componentstatus</span><br><span class="line">kubectl get cs</span><br><span class="line">kubectl cluster-info</span><br></pre></td></tr></table></figure><h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><h3 id="RunC-简介"><a href="#RunC-简介" class="headerlink" title="RunC 简介"></a>RunC 简介</h3><p><a href="https://www.cnblogs.com/sparkdev/p/9032209.html" target="_blank" rel="noopener">RunC 简介</a></p><h3 id="docker-registry-self-signed-certificates"><a href="#docker-registry-self-signed-certificates" class="headerlink" title="docker registry self-signed certificates"></a>docker registry self-signed certificates</h3><p>自建 docker registry 自签名方法：</p><p><a href="https://docs.docker.com/registry/insecure/" target="_blank" rel="noopener">https://docs.docker.com/registry/insecure/</a></p><h3 id="容器安全性"><a href="#容器安全性" class="headerlink" title="容器安全性"></a>容器安全性</h3><p><a href="https://jtreminio.com/blog/running-docker-containers-as-current-host-user/" target="_blank" rel="noopener">Running Docker Containers as Current Host User</a></p><h3 id="Useful-Commands-1"><a href="#Useful-Commands-1" class="headerlink" title="Useful Commands"></a>Useful Commands</h3><h4 id="debug-container"><a href="#debug-container" class="headerlink" title="debug container"></a>debug container</h4><p>通过以下命令可以很方便的调试容器网络：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nsenter -t &lt;container-pid&gt; -n ip addr</span><br></pre></td></tr></table></figure><h4 id="start-mongodb-locally"><a href="#start-mongodb-locally" class="headerlink" title="start mongodb locally"></a>start mongodb locally</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 27017:27017 -v $PWD/db:/data/db -d mongo:3.2</span><br></pre></td></tr></table></figure><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><h3 id="go-modules-vgo"><a href="#go-modules-vgo" class="headerlink" title="go modules (vgo)"></a>go modules (vgo)</h3><p>go modules 已经逐渐取代其他依赖管理工具，很多社区项目都在逐步向 go modules 迁移。</p><ul><li><a href="https://talks.godoc.org/github.com/myitcv/talks/2018-08-15-glug-modules/main.slide#1" target="_blank" rel="noopener">What are Go modules and how do I use them?</a></li><li><a href="https://segmentfault.com/a/1190000016703769" target="_blank" rel="noopener">Go Modules使用教程</a></li><li><a href="https://xuanwo.io/2019/05/27/go-modules/" target="_blank" rel="noopener">Go Modules 内部分享</a></li></ul><h4 id="go-modules-with-kubernetes-的坑"><a href="#go-modules-with-kubernetes-的坑" class="headerlink" title="go modules with kubernetes 的坑"></a>go modules with kubernetes 的坑</h4><p>使用 go modules 导入 <code>k8s.io/kubernetes</code> 主库会有问题，因为主库的 <code>go.mod</code> 文件里 replace 了一大堆依赖，<a href="https://github.com/kubernetes/kubernetes/issues/79384#issuecomment-505725449" target="_blank" rel="noopener">官方给的建议</a> 是在自己的 <code>go.mod</code> 文件里再次 replace 会正确的版本，或者干脆不要依赖主库。</p><h3 id="golang-内存逃逸"><a href="#golang-内存逃逸" class="headerlink" title="golang 内存逃逸"></a>golang 内存逃逸</h3><p><a href="https://www.do1618.com/archives/1328/go-%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">Go 内存逃逸详细分析</a></p><h3 id="golang-测试"><a href="#golang-测试" class="headerlink" title="golang 测试"></a>golang 测试</h3><p><a href="https://colobu.com/2016/07/06/dive-into-go-12/" target="_blank" rel="noopener">测试、性能测试以及代码示例的编写</a></p><p>Package <a href="https://golang.org/pkg/cmd/go/internal/test/" target="_blank" rel="noopener">test</a></p><h2 id="Productive"><a href="#Productive" class="headerlink" title="Productive"></a>Productive</h2><h3 id="StarUML-Crack"><a href="#StarUML-Crack" class="headerlink" title="StarUML Crack"></a>StarUML Crack</h3><p><a href="https://gist.github.com/trandaison/40b1d83618ae8e3d2da59df8c395093a#gistcomment-2723165" target="_blank" rel="noopener">https://gist.github.com/trandaison/40b1d83618ae8e3d2da59df8c395093a#gistcomment-2723165</a></p><h3 id="Dictionary-Extension"><a href="#Dictionary-Extension" class="headerlink" title="Dictionary Extension"></a>Dictionary Extension</h3><p>用 DictUnifier（已改名为 <a href="https://github.com/jjgod/mac-dictionary-kit" target="_blank" rel="noopener">mac-dictionary-kit</a>）可以将 <a href="http://download.huzheng.org/zh_CN/" target="_blank" rel="noopener">stardict</a> 词典格式转换为 Apple Dict 格式。</p><p>转换教程参考：</p><ul><li><a href="https://www.douban.com/group/topic/9591106/" target="_blank" rel="noopener">https://www.douban.com/group/topic/9591106/</a></li><li><a href="https://github.com/tsoliangwu0130/my-macos/blob/master/misc/dictunifier-stardict.md" target="_blank" rel="noopener">https://github.com/tsoliangwu0130/my-macos/blob/master/misc/dictunifier-stardict.md</a></li></ul><p><a href="https://github.com/ilius/pyglossary" target="_blank" rel="noopener">PyGlossary</a> 是另外一种词典转换工具，不过需要在 <a href="https://developer.apple.com/download/more/" target="_blank" rel="noopener">Apple Developer Downloads</a> 单独下载 Additional Tools for Xcode.</p><p>词典转换后可能会有 css 显示问题，可以参考：</p><ul><li><a href="https://discussions.apple.com/thread/3736067" target="_blank" rel="noopener">https://discussions.apple.com/thread/3736067</a></li></ul><h3 id="禁用-DS-Store"><a href="#禁用-DS-Store" class="headerlink" title="禁用 .DS_Store"></a>禁用 <code>.DS_Store</code></h3><p>如果在 macOS 的 Finder 里访问网络文件系统（比如 samba），打开目录是会自动在目录下生成 <code>.DS_Store</code> 来存储一些元信息（标签、文件夹颜色、排序等等），这个在其他系统上看起来就非常不顺眼，因此可以通过下面的命令禁用：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.desktopservices DSDontWriteNetworkStores true</span><br></pre></td></tr></table></figure><p>但是这个命令只对网络存储有用，对于本地磁盘还是会生成 <code>.DS_Store</code> 文件，暂时没有方便的办法禁用。</p><h3 id="Jetbrains-back-forward-with-mouse"><a href="#Jetbrains-back-forward-with-mouse" class="headerlink" title="Jetbrains back/forward with mouse"></a>Jetbrains back/forward with mouse</h3><p>有的鼠标有 Button4 和 Button5 可以在浏览代码时很方便地前进和后退，macOS 系统，在 Visual Studio Code 上正常，但在 Jetbrains 系的 IDE 上默认却是跳转到行首和行尾，解决方法是修改 Button4 和 Button5 默认的键盘快捷键。可以参考<a href="https://stackoverflow.com/questions/14360112/intellij-idea-back-forward-with-mouse" target="_blank" rel="noopener">这个方法</a>修改。</p><h3 id="Vagrant-KVM"><a href="#Vagrant-KVM" class="headerlink" title="Vagrant + KVM"></a>Vagrant + KVM</h3><p>KVM 比 VirtualBox 的性能更好，在 Linux 环境下推荐使用：</p><p><a href="https://medium.com/@gauthierleonard/kvm-machines-for-vagrant-on-archlinux-1d8863344cb7" target="_blank" rel="noopener">https://medium.com/@gauthierleonard/kvm-machines-for-vagrant-on-archlinux-1d8863344cb7</a></p><p><a href="https://docs.cumulusnetworks.com/display/VX/Vagrant+and+Libvirt+with+KVM+or+QEMU" target="_blank" rel="noopener">https://docs.cumulusnetworks.com/display/VX/Vagrant+and+Libvirt+with+KVM+or+QEMU</a></p><p><a href="https://gist.github.com/yuanying/924ce2ce61b75ab818b5" target="_blank" rel="noopener">https://gist.github.com/yuanying/924ce2ce61b75ab818b5</a></p><h3 id="Windows-10-Ubuntu-18-04"><a href="#Windows-10-Ubuntu-18-04" class="headerlink" title="Windows 10 + Ubuntu 18.04"></a>Windows 10 + Ubuntu 18.04</h3><p>在 MacOS 上刻录镜像</p><p><a href="https://www.cybrary.it/0p3n/macos-terminal-create-bootable-usb-iso-using-dd/" target="_blank" rel="noopener">https://www.cybrary.it/0p3n/macos-terminal-create-bootable-usb-iso-using-dd/</a></p><p>Ubuntu Installer 无法识别 GPT 分区</p><p><a href="https://arstechnica.com/civis/viewtopic.php?p=36107737&amp;sid=108632491878b9fa937dcbc6d433765f#p36107737" target="_blank" rel="noopener">https://arstechnica.com/civis/viewtopic.php?p=36107737&amp;sid=108632491878b9fa937dcbc6d433765f#p36107737</a></p><p><a href="https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/disabling-secure-boot" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/disabling-secure-boot</a></p><p><a href="https://www.technorms.com/45538/disable-enable-secure-boot-asus-motherboard-uefi-bios-utility" target="_blank" rel="noopener">https://www.technorms.com/45538/disable-enable-secure-boot-asus-motherboard-uefi-bios-utility</a></p><p>NVMe 安装 Ubuntu</p><p><a href="https://ubuntuforums.org/showthread.php?t=2390475" target="_blank" rel="noopener">https://ubuntuforums.org/showthread.php?t=2390475</a></p><p><a href="https://ubuntu-mate.community/t/cant-see-nvme-m-2-drive-for-fresh-install/18463/3" target="_blank" rel="noopener">https://ubuntu-mate.community/t/cant-see-nvme-m-2-drive-for-fresh-install/18463/3</a></p><h3 id="VSC-Remote"><a href="#VSC-Remote" class="headerlink" title="VSC Remote"></a>VSC Remote</h3><p>使用 <a href="https://code.visualstudio.com/docs/remote/ssh" target="_blank" rel="noopener">VSC Remote</a> 可以方便地在 Windows 或者 macOS 下利用 ssh 进行 Linux 环境远程开发和调试。需要安装 <a href="https://code.visualstudio.com/insiders/" target="_blank" rel="noopener">Visual Studio Code insiders</a> 版本。</p><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h4 id="change-author-of-commits"><a href="#change-author-of-commits" class="headerlink" title="change author of commits"></a>change author of commits</h4><p><a href="https://makandracards.com/makandra/1717-git-change-author-of-a-commit" target="_blank" rel="noopener">https://makandracards.com/makandra/1717-git-change-author-of-a-commit</a></p><h4 id="grep-logs"><a href="#grep-logs" class="headerlink" title="grep logs"></a>grep logs</h4><p>有时候需要确认某个 PR 或者 commit 有没有合入特定版本或者分支，可以用下面的命令：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="hljs-built_in">log</span> &lt;branch-or-tag-name&gt; --since 3.weeks --grep &lt;pattern&gt;</span><br></pre></td></tr></table></figure><h4 id="git-status-显示-UTF-8-字符"><a href="#git-status-显示-UTF-8-字符" class="headerlink" title="git status 显示 UTF-8 字符"></a>git status 显示 UTF-8 字符</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath false</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/u012145252/article/details/81775362" target="_blank" rel="noopener">git status 显示中文和解决中文乱码</a></p><h3 id="Bazel"><a href="#Bazel" class="headerlink" title="Bazel"></a>Bazel</h3><p>Bazel 是 Google 的构建工具，CMake 或者 Makefile 的替代品。</p><p><a href="https://medium.com/windmill-engineering/bazel-is-the-worst-build-system-except-for-all-the-others-b369396a9e26" target="_blank" rel="noopener">https://medium.com/windmill-engineering/bazel-is-the-worst-build-system-except-for-all-the-others-b369396a9e26</a></p><h3 id="jq"><a href="#jq" class="headerlink" title="jq"></a>jq</h3><p>json 的命令行解析工具。参考：<a href="https://stedolan.github.io/jq/tutorial/" target="_blank" rel="noopener">https://stedolan.github.io/jq/tutorial/</a></p><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p><a href="https://wiki.bash-hackers.org/start" target="_blank" rel="noopener">The Bash Hackers Wiki</a></p><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><h3 id="服务名与端口号映射"><a href="#服务名与端口号映射" class="headerlink" title="服务名与端口号映射"></a>服务名与端口号映射</h3><p><a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml" target="_blank" rel="noopener">https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml</a></p><h3 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h3><p><a href="https://segmentfault.com/a/1190000016901447" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016901447</a></p><p><a href="https://flink.apache.org/" target="_blank" rel="noopener">https://flink.apache.org/</a></p><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>一个学习 css 的网站，支持边学边练：<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/white-space" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/CSS/white-space</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Kubernetes&quot;&gt;&lt;a href=&quot;#Kubernetes&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes&quot;&gt;&lt;/a&gt;Kubernetes&lt;/h2&gt;&lt;h3 id=&quot;api-conventions&quot;&gt;&lt;a href=&quot;#api-conventions&quot; class=&quot;headerlink&quot; title=&quot;api conventions&quot;&gt;&lt;/a&gt;api conventions&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md&lt;/a&gt;&lt;/p&gt;&lt;h3 id=&quot;kube-node-lease&quot;&gt;&lt;a href=&quot;#kube-node-lease&quot; class=&quot;headerlink&quot; title=&quot;kube node lease&quot;&gt;&lt;/a&gt;kube node lease&lt;/h3&gt;&lt;p&gt;kube node lease 用来改善 kubelet 定时更新节点状态对 etcd 造成的压力。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://containers.goffinet.org/k8s/kubectlget.html#what-about-kube-node-lease&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://containers.goffinet.org/k8s/kubectlget.html#what-about-kube-node-lease&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/0009-node-heartbeat.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/0009-node-heartbeat.md&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/docs/concepts/architecture/nodes/#node-controller&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://kubernetes.io/docs/concepts/architecture/nodes/#node-controller&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes-sigs/kubespray/blob/master/docs/kubernetes-reliability.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/kubernetes-sigs/kubespray/blob/master/docs/kubernetes-reliability.md&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="云计算" scheme="http://whypro.github.io/hexo-blog/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Golang" scheme="http://whypro.github.io/hexo-blog/tags/Golang/"/>
    
      <category term="Docker" scheme="http://whypro.github.io/hexo-blog/tags/Docker/"/>
    
      <category term="Kubernetes" scheme="http://whypro.github.io/hexo-blog/tags/Kubernetes/"/>
    
      <category term="K8S" scheme="http://whypro.github.io/hexo-blog/tags/K8S/"/>
    
      <category term="笔记" scheme="http://whypro.github.io/hexo-blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Kubelet PLEG 源码解析</title>
    <link href="http://whypro.github.io/hexo-blog/20190604/Kubelet-PLEG-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://whypro.github.io/hexo-blog/20190604/Kubelet-PLEG-源码解析/</id>
    <published>2019-06-04T04:48:26.000Z</published>
    <updated>2019-07-04T03:44:51.756Z</updated>
    
    <content type="html"><![CDATA[<p>PLEG (pod lifecycle event generator) 是 kubelet 中一个非常重要的模块，它主要完成以下几个目标：</p><ol><li>从 runtime 中获取 pod 当前状态，产生 pod lifecycle events</li><li>从 runtime 中获取 pod 当前状态，更新 kubelet pod cache</li></ol><p>本文我们通过分析 PLEG 模块的源码，来加深对 Kubernetes 的理解，也可以加速在使用过程对一些疑难问题的排查和处理，同时后期可以对一些问题源码进行优化，来解决一些 Kubernetes 本身的坑。</p><a id="more"></a><h2 id="PLEG-初始化"><a href="#PLEG-初始化" class="headerlink" title="PLEG 初始化"></a>PLEG 初始化</h2><p>PLEG 模块在 kubelet 实例创建时初始化，在 <code>pkg/kubelet/kubelet.go</code> 文件中：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMainKubelet</span><span class="hljs-params">(...)</span> <span class="hljs-params">(*Kubelet, error)</span></span> &#123;</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">    klet.pleg = pleg.NewGenericPLEG(klet.containerRuntime, plegChannelCapacity, plegRelistPeriod, klet.podCache, clock.RealClock&#123;&#125;)</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们简单看看 <code>NewGenericPLEG</code> 的实现，见 <code>pkg/kubelet/pleg/generic.go</code>：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// NewGenericPLEG instantiates a new GenericPLEG object and return it.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewGenericPLEG</span><span class="hljs-params">(runtime kubecontainer.Runtime, channelCapacity <span class="hljs-keyword">int</span>,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    relistPeriod time.Duration, cache kubecontainer.Cache, clock clock.Clock)</span> <span class="hljs-title">PodLifecycleEventGenerator</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> &amp;GenericPLEG&#123;</span><br><span class="line">        relistPeriod: relistPeriod,</span><br><span class="line">        runtime:      runtime,</span><br><span class="line">        eventChannel: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *PodLifecycleEvent, channelCapacity),</span><br><span class="line">        podRecords:   <span class="hljs-built_in">make</span>(podRecords),</span><br><span class="line">        cache:        cache,</span><br><span class="line">        clock:        clock,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NewGenericPLEG</code> 函数有几个重要的参数：</p><ul><li><p><code>runtime</code></p><p>实参为 <code>klet.containerRuntime</code>，负责容器运行时的管理，对 pod 或 container 状态的获取、同步和删除都通过 <code>runtime</code> 来操作。</p></li><li><p><code>channelCapacity</code></p><p>实参为 <code>plegChannelCapacity</code>，是 <code>eventChannel</code> 有缓冲 channel 的大小，默认值 <code>1000</code>，也就是单节点最大支持 1000 个 pod lifecycle event 同时触发。</p></li><li><p><code>relistPeriod</code></p><p>实参为 <code>plegRelistPeriod</code>，是 PLEG 检测的周期，默认值 <code>1s</code>。</p></li><li><p><code>cache</code></p><p>实参为 <code>klet.podCache</code>，保存着所有 pod 状态的缓存，kubelet 通过 container runtime 更新 pod 缓存。</p></li></ul><p><code>plegChannelCapacity</code> 和 <code>plegRelistPeriod</code> 这两个常量的定义在 <code>pkg/kubelet/kubelet.go</code> 文件里：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> (</span><br><span class="line">    plegChannelCapacity = <span class="hljs-number">1000</span></span><br><span class="line"></span><br><span class="line">    plegRelistPeriod = time.Second * <span class="hljs-number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="PLEG-接口定义"><a href="#PLEG-接口定义" class="headerlink" title="PLEG 接口定义"></a>PLEG 接口定义</h2><p><code>NewGenericPLEG</code> 返回的类型 <code>*GenericPLEG</code> 实现了 <code>PodLifecycleEventGenerator</code> 接口，我们暂且忽略 <code>GenericPLEG</code> 结构体的具体实现，先分析一下 <code>PodLifecycleEventGenerator</code> 接口，这个接口在 <code>pkg/kubelet/pleg/pleg.go</code> 文件中定义，包含三个方法：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// PodLifecycleEventGenerator contains functions for generating pod life cycle events.</span></span><br><span class="line"><span class="hljs-keyword">type</span> PodLifecycleEventGenerator <span class="hljs-keyword">interface</span> &#123;</span><br><span class="line">    Start()</span><br><span class="line">    Watch() <span class="hljs-keyword">chan</span> *PodLifecycleEvent</span><br><span class="line">    Healthy() (<span class="hljs-keyword">bool</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Start</code> 启动 PLEG。</li><li><code>Watch</code> 返回一个 channel，pod lifecycle events 会发送到这个 channel 里，kubelet 通过这个 channel 来获取事件，执行处理动作。</li><li><code>Healty</code> 返回 PLEG 的健康状态。kubelet 通过这个函数判断 PLEG 是否健康。</li></ul><p>我们再看看 pod lifecycle event 的定义，见 <code>pkg/kubelet/pleg/pleg.go</code> 文件：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// PodLifeCycleEventType define the event type of pod life cycle events.</span></span><br><span class="line"><span class="hljs-keyword">type</span> PodLifeCycleEventType <span class="hljs-keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> (</span><br><span class="line">    <span class="hljs-comment">// ContainerStarted - event type when the new state of container is running.</span></span><br><span class="line">    ContainerStarted PodLifeCycleEventType = <span class="hljs-string">"ContainerStarted"</span></span><br><span class="line">    <span class="hljs-comment">// ContainerDied - event type when the new state of container is exited.</span></span><br><span class="line">    ContainerDied PodLifeCycleEventType = <span class="hljs-string">"ContainerDied"</span></span><br><span class="line">    <span class="hljs-comment">// ContainerRemoved - event type when the old state of container is exited.</span></span><br><span class="line">    ContainerRemoved PodLifeCycleEventType = <span class="hljs-string">"ContainerRemoved"</span></span><br><span class="line">    <span class="hljs-comment">// PodSync is used to trigger syncing of a pod when the observed change of</span></span><br><span class="line">    <span class="hljs-comment">// the state of the pod cannot be captured by any single event above.</span></span><br><span class="line">    PodSync PodLifeCycleEventType = <span class="hljs-string">"PodSync"</span></span><br><span class="line">    <span class="hljs-comment">// ContainerChanged - event type when the new state of container is unknown.</span></span><br><span class="line">    ContainerChanged PodLifeCycleEventType = <span class="hljs-string">"ContainerChanged"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// PodLifecycleEvent is an event that reflects the change of the pod state.</span></span><br><span class="line"><span class="hljs-keyword">type</span> PodLifecycleEvent <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">    <span class="hljs-comment">// The pod ID.</span></span><br><span class="line">    ID types.UID</span><br><span class="line">    <span class="hljs-comment">// The type of the event.</span></span><br><span class="line">    Type PodLifeCycleEventType</span><br><span class="line">    <span class="hljs-comment">// The accompanied data which varies based on the event type.</span></span><br><span class="line">    <span class="hljs-comment">//   - ContainerStarted/ContainerStopped: the container name (string).</span></span><br><span class="line">    <span class="hljs-comment">//   - All other event types: unused.</span></span><br><span class="line">    Data <span class="hljs-keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PodLifecycleEvent</code> 结构保存着以下信息：</p><ul><li><p><code>ID</code>: pod ID</p></li><li><p><code>Type</code>: 事件类型</p><p><code>PodLifecycleEventType</code> 有以下几种：</p><ul><li><code>ContainerStarted</code>: 容器状态变为 <code>Running</code></li><li><code>ContainerDied</code>: 容器状态变为 <code>Exited</code></li><li><code>ContainerRemoved</code>: 容器消失</li><li><code>PodSync</code>: PLEG 中未使用</li><li><code>ContainerChanged</code>: 容器状态变为 <code>Unknown</code></li></ul></li><li><p><code>Data</code>: 容器 ID（源码注释是 container name，应该是错误）</p></li></ul><h2 id="PLEG-接口调用"><a href="#PLEG-接口调用" class="headerlink" title="PLEG 接口调用"></a>PLEG 接口调用</h2><p>下面我们看看 kubelet 是在哪里使用 <code>PodLifecycleEventGenerator</code> 接口里的三个方法的。</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>kubelet 在 <code>Run</code> 函数中执行 <code>Start</code>，启动 PLEG。</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Run starts the kubelet reacting to config updates</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *Kubelet)</span> <span class="hljs-title">Run</span><span class="hljs-params">(updates &lt;-<span class="hljs-keyword">chan</span> kubetypes.PodUpdate)</span></span> &#123;</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Start the pod lifecycle event generator.</span></span><br><span class="line">    kl.pleg.Start()</span><br><span class="line">    kl.syncLoop(updates, kl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>最后在 <code>syncLoop</code> 中执行 <code>Watch</code>，获取到这个关键的 channel <code>plegCh</code>，然后在 <code>syncLoopIteration</code> 函数中从 channel 中获取事件，进行处理。</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// syncLoop is the main loop for processing changes. It watches for changes from</span></span><br><span class="line"><span class="hljs-comment">// three channels (file, apiserver, and http) and creates a union of them. For</span></span><br><span class="line"><span class="hljs-comment">// any new change seen, will run a sync against desired state and running state. If</span></span><br><span class="line"><span class="hljs-comment">// no changes are seen to the configuration, will synchronize the last known desired</span></span><br><span class="line"><span class="hljs-comment">// state every sync-frequency seconds. Never returns.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *Kubelet)</span> <span class="hljs-title">syncLoop</span><span class="hljs-params">(updates &lt;-<span class="hljs-keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler)</span></span> &#123;</span><br><span class="line">    klog.Info(<span class="hljs-string">"Starting kubelet main sync loop."</span>)</span><br><span class="line">    <span class="hljs-comment">// The syncTicker wakes up kubelet to checks if there are any pod workers</span></span><br><span class="line">    <span class="hljs-comment">// that need to be sync'd. A one-second period is sufficient because the</span></span><br><span class="line">    <span class="hljs-comment">// sync interval is defaulted to 10s.</span></span><br><span class="line">    syncTicker := time.NewTicker(time.Second)</span><br><span class="line">    <span class="hljs-keyword">defer</span> syncTicker.Stop()</span><br><span class="line">    housekeepingTicker := time.NewTicker(housekeepingPeriod)</span><br><span class="line">    <span class="hljs-keyword">defer</span> housekeepingTicker.Stop()</span><br><span class="line">    plegCh := kl.pleg.Watch()</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">    <span class="hljs-keyword">for</span> &#123;</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">        <span class="hljs-keyword">if</span> !kl.syncLoopIteration(updates, handler, syncTicker.C, housekeepingTicker.C, plegCh) &#123;</span><br><span class="line">            <span class="hljs-keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>syncLoopIteration</code> 是 kubelet 事件处理的核心函数，它的职责是从多个不同类型的 channel 中获取事件，然后分发给不同的 handler 去处理。</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// syncLoopIteration reads from various channels and dispatches pods to the</span></span><br><span class="line"><span class="hljs-comment">// given handler.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *Kubelet)</span> <span class="hljs-title">syncLoopIteration</span><span class="hljs-params">(configCh &lt;-<span class="hljs-keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">    syncCh &lt;-<span class="hljs-keyword">chan</span> time.Time, housekeepingCh &lt;-<span class="hljs-keyword">chan</span> time.Time, plegCh &lt;-<span class="hljs-keyword">chan</span> *pleg.PodLifecycleEvent)</span> <span class="hljs-title">bool</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">select</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">case</span> u, open := &lt;-configCh:</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    <span class="hljs-keyword">case</span> e := &lt;-plegCh:</span><br><span class="line">        <span class="hljs-keyword">if</span> isSyncPodWorthy(e) &#123;</span><br><span class="line">            <span class="hljs-comment">// PLEG event for a pod; sync it.</span></span><br><span class="line">            <span class="hljs-keyword">if</span> pod, ok := kl.podManager.GetPodByUID(e.ID); ok &#123;</span><br><span class="line">                klog.V(<span class="hljs-number">2</span>).Infof(<span class="hljs-string">"SyncLoop (PLEG): %q, event: %#v"</span>, format.Pod(pod), e)</span><br><span class="line">                handler.HandlePodSyncs([]*v1.Pod&#123;pod&#125;)</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                <span class="hljs-comment">// If the pod no longer exists, ignore the event.</span></span><br><span class="line">                klog.V(<span class="hljs-number">4</span>).Infof(<span class="hljs-string">"SyncLoop (PLEG): ignore irrelevant event: %#v"</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> e.Type == pleg.ContainerDied &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> containerID, ok := e.Data.(<span class="hljs-keyword">string</span>); ok &#123;</span><br><span class="line">                kl.cleanUpContainersInPod(e.ID, containerID)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="hljs-keyword">case</span> &lt;-syncCh:</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    <span class="hljs-keyword">case</span> update := &lt;-kl.livenessManager.Updates():</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    <span class="hljs-keyword">case</span> &lt;-housekeepingCh:</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>configCh</code> 负责获取 pod 配置更新事件。</li><li><code>syncCh</code> 是一个定时器，定时获取 pod sync 事件，对需要的 pod 进行同步，默认是 <code>1s</code>。</li><li><code>housekeepingCh</code> 也是一个定时器，定时获取 pod Cleanup 事件，对需要的 pod 进行清理，默认值是 <code>2s</code></li><li><code>plegCh</code> 负责获取 pod lifecycle 事件</li><li><code>livenessManager.Updates</code> 负责获取 liveness probe 事件</li><li><code>handler</code> 是个事件处理接口 (<code>SyncHandler</code>)，获取到上面的时间后调用对应的事件处理方法，kubelet 主类本身默认实现了这个接口。</li></ul><p>在这里我们只关心对 pod lifecycle 事件的处理：从代码上看，kubelet 收到 pod lifecycle 事件之后，首先判断事件类型是不是值得触发 pod 同步，如果是 <code>ContainerRemoved</code>，则忽略该事件。如果是其他事件，且 pod 信息还没有被删除，调用 <code>HandlePodSyncs</code> 产生 UpdatePod 事件，交给 kubelet pod Worker 进行异步更新。最后，如果是 <code>ContainerDied</code> 事件，为了防止退出容器堆积，会按照一定的策略移除已退出的容器。</p><h3 id="健康检测"><a href="#健康检测" class="headerlink" title="健康检测"></a>健康检测</h3><p>kubelet 对 PLEG 模块的健康检测，通过 runtimeState 来管理，kubelet 在初始化 PLEG 后通过 <code>addHealthCheck</code> 将 <code>klet.pleg.Healthy</code> 健康监测方法注册至 runtimeState，runtimeState 定时调用 <code>Healthy</code> 方法检查 PLEG 的健康状态。参见 <code>pkg/kubelet/kubelet.go</code>：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMainKubelet</span><span class="hljs-params">(...)</span> <span class="hljs-params">(*Kubelet, error)</span></span> &#123;</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">    klet.runtimeState.addHealthCheck(<span class="hljs-string">"PLEG"</span>, klet.pleg.Healthy)</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addHealthCheck</code> 实现在 <code>pkg/kubelet/runtime.go</code> 中：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *runtimeState)</span> <span class="hljs-title">addHealthCheck</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, f healthCheckFnType)</span></span> &#123;</span><br><span class="line">    s.Lock()</span><br><span class="line">    <span class="hljs-keyword">defer</span> s.Unlock()</span><br><span class="line">    s.healthChecks = <span class="hljs-built_in">append</span>(s.healthChecks, &amp;healthCheck&#123;name: name, fn: f&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>syncLoop</code> 中定时执行 <code>runtimeErrors</code>，这里 <code>syncLoop</code> 采用了简单的 backoff 机制，如果 runtimeState 各个模块状态都正常，则每次循环默认 sleep <code>100ms</code>，如果出现异常状态，则 sleep duration * 2，最大变为 <code>5s</code>，参见 <code>pkg/kubelet/kubelet.go</code>：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kl *Kubelet)</span> <span class="hljs-title">syncLoop</span><span class="hljs-params">(updates &lt;-<span class="hljs-keyword">chan</span> kubetypes.PodUpdate, handler SyncHandler)</span></span> &#123;</span><br><span class="line">    klog.Info(<span class="hljs-string">"Starting kubelet main sync loop."</span>)</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">    <span class="hljs-keyword">const</span> (</span><br><span class="line">        base   = <span class="hljs-number">100</span> * time.Millisecond</span><br><span class="line">        max    = <span class="hljs-number">5</span> * time.Second</span><br><span class="line">        factor = <span class="hljs-number">2</span></span><br><span class="line">    )</span><br><span class="line">    duration := base</span><br><span class="line">    <span class="hljs-keyword">for</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> err := kl.runtimeState.runtimeErrors(); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">            klog.Infof(<span class="hljs-string">"skipping pod synchronization - %v"</span>, err)</span><br><span class="line">            <span class="hljs-comment">// exponential backoff</span></span><br><span class="line">            time.Sleep(duration)</span><br><span class="line">            duration = time.Duration(math.Min(<span class="hljs-keyword">float64</span>(max), factor*<span class="hljs-keyword">float64</span>(duration)))</span><br><span class="line">            <span class="hljs-keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// reset backoff if we have a success</span></span><br><span class="line">        duration = base</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runtimeErrors</code> 实现在 <code>pkg/kubelet/runtime.go</code> 中：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *runtimeState)</span> <span class="hljs-title">runtimeErrors</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line">    s.RLock()</span><br><span class="line">    <span class="hljs-keyword">defer</span> s.RUnlock()</span><br><span class="line">    errs := []error&#123;&#125;</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">    <span class="hljs-keyword">for</span> _, hc := <span class="hljs-keyword">range</span> s.healthChecks &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> ok, err := hc.fn(); !ok &#123;</span><br><span class="line">            errs = <span class="hljs-built_in">append</span>(errs, fmt.Errorf(<span class="hljs-string">"%s is not healthy: %v"</span>, hc.name, err))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> utilerrors.NewAggregate(errs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也是依次执行各个模块事先注册的 healthy check 函数，如果任何一个模块返回 false，则认为整个 runtimeState 的状态为 unhealthy。</p><h2 id="Generic-PLEG-实现"><a href="#Generic-PLEG-实现" class="headerlink" title="Generic PLEG 实现"></a>Generic PLEG 实现</h2><p>我们再回到 <code>PodLifecycleEventGenerator</code> 接口的实现 —— <code>GenericPLEG</code> 的定义，见 <code>pkg/kubelet/pleg/generic.go</code> 文件：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> GenericPLEG <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">    <span class="hljs-comment">// The period for relisting.</span></span><br><span class="line">    relistPeriod time.Duration</span><br><span class="line">    <span class="hljs-comment">// The container runtime.</span></span><br><span class="line">    runtime kubecontainer.Runtime</span><br><span class="line">    <span class="hljs-comment">// The channel from which the subscriber listens events.</span></span><br><span class="line">    eventChannel <span class="hljs-keyword">chan</span> *PodLifecycleEvent</span><br><span class="line">    <span class="hljs-comment">// The internal cache for pod/container information.</span></span><br><span class="line">    podRecords podRecords</span><br><span class="line">    <span class="hljs-comment">// Time of the last relisting.</span></span><br><span class="line">    relistTime atomic.Value</span><br><span class="line">    <span class="hljs-comment">// Cache for storing the runtime states required for syncing pods.</span></span><br><span class="line">    cache kubecontainer.Cache</span><br><span class="line">    <span class="hljs-comment">// For testability.</span></span><br><span class="line">    clock clock.Clock</span><br><span class="line">    <span class="hljs-comment">// Pods that failed to have their status retrieved during a relist. These pods will be</span></span><br><span class="line">    <span class="hljs-comment">// retried during the next relisting.</span></span><br><span class="line">    podsToReinspect <span class="hljs-keyword">map</span>[types.UID]*kubecontainer.Pod</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>relistPeriod</code> 是 PLEG 检测周期，默认为 <code>1s</code></li><li><code>runtime</code> 是 container runtime，负责获取 pod 和 container 的状态信息</li><li><code>podRecords</code> 缓存 pod 以及 Container 的基本信息</li><li><code>cache</code> 缓存 pod 的运行时状态</li><li><code>eventChannel</code> 是 PLEG 通过对比 pod 缓存信息和当前信息，生成 pod lifecycle events 的 channel</li><li><code>relistTime</code> 是上一次执行完 PLEG 检测的时刻</li><li><code>podsToReinspect</code> 保存 PLEG 检测失败的 Pod，以便下次再次检测</li><li><code>clock</code> 是一个时间管理对象，作用是获取当前时间</li></ul><p>然后我们基于接口方法，来分析 <code>GenericPLEG</code> 的实现：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Start spawns a goroutine to relist periodically.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *GenericPLEG)</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">go</span> wait.Until(g.relist, g.relistPeriod, wait.NeverStop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Start</code> 启动了一个 goroutine，以 <code>1s</code> 的间隔无限执行 <code>relist</code> 函数。这里要注意 <code>wait.Until</code> 的行为，如果 <code>relist</code> 执行时间大于 period 设置的值，则时间窗会滑动至 relist 执行完毕的那一时刻。也就是说如果 period 是 <code>1s</code>，relist 从第 <code>0s</code> 开始，花了 <code>10s</code>，结束时是第 <code>10s</code>，那么下一次 relist 会从第 <code>11s</code> 开始执行。</p><p>relist 函数的实现如下：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// relist queries the container runtime for list of pods/containers, compare</span></span><br><span class="line"><span class="hljs-comment">// with the internal pods/containers, and generates events accordingly.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *GenericPLEG)</span> <span class="hljs-title">relist</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    klog.V(<span class="hljs-number">5</span>).Infof(<span class="hljs-string">"GenericPLEG: Relisting"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> lastRelistTime := g.getRelistTime(); !lastRelistTime.IsZero() &#123;</span><br><span class="line">        metrics.PLEGRelistInterval.Observe(metrics.SinceInSeconds(lastRelistTime))</span><br><span class="line">        metrics.DeprecatedPLEGRelistInterval.Observe(metrics.SinceInMicroseconds(lastRelistTime))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timestamp := g.clock.Now()</span><br><span class="line">    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">        metrics.PLEGRelistDuration.Observe(metrics.SinceInSeconds(timestamp))</span><br><span class="line">        metrics.DeprecatedPLEGRelistLatency.Observe(metrics.SinceInMicroseconds(timestamp))</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Get all the pods.</span></span><br><span class="line">    podList, err := g.runtime.GetPods(<span class="hljs-literal">true</span>)</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        klog.Errorf(<span class="hljs-string">"GenericPLEG: Unable to retrieve pods: %v"</span>, err)</span><br><span class="line">        <span class="hljs-keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.updateRelistTime(timestamp)</span><br><span class="line"></span><br><span class="line">    pods := kubecontainer.Pods(podList)</span><br><span class="line">    g.podRecords.setCurrent(pods)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Compare the old and the current pods, and generate events.</span></span><br><span class="line">    eventsByPodID := <span class="hljs-keyword">map</span>[types.UID][]*PodLifecycleEvent&#123;&#125;</span><br><span class="line">    <span class="hljs-keyword">for</span> pid := <span class="hljs-keyword">range</span> g.podRecords &#123;</span><br><span class="line">        oldPod := g.podRecords.getOld(pid)</span><br><span class="line">        pod := g.podRecords.getCurrent(pid)</span><br><span class="line">        <span class="hljs-comment">// Get all containers in the old and the new pod.</span></span><br><span class="line">        allContainers := getContainersFromPods(oldPod, pod)</span><br><span class="line">        <span class="hljs-keyword">for</span> _, container := <span class="hljs-keyword">range</span> allContainers &#123;</span><br><span class="line">            events := computeEvents(oldPod, pod, &amp;container.ID)</span><br><span class="line">            <span class="hljs-keyword">for</span> _, e := <span class="hljs-keyword">range</span> events &#123;</span><br><span class="line">                updateEvents(eventsByPodID, e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">var</span> needsReinspection <span class="hljs-keyword">map</span>[types.UID]*kubecontainer.Pod</span><br><span class="line">    <span class="hljs-keyword">if</span> g.cacheEnabled() &#123;</span><br><span class="line">        needsReinspection = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[types.UID]*kubecontainer.Pod)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// If there are events associated with a pod, we should update the</span></span><br><span class="line">    <span class="hljs-comment">// podCache.</span></span><br><span class="line">    <span class="hljs-keyword">for</span> pid, events := <span class="hljs-keyword">range</span> eventsByPodID &#123;</span><br><span class="line">        pod := g.podRecords.getCurrent(pid)</span><br><span class="line">        <span class="hljs-keyword">if</span> g.cacheEnabled() &#123;</span><br><span class="line">            <span class="hljs-comment">// updateCache() will inspect the pod and update the cache. If an</span></span><br><span class="line">            <span class="hljs-comment">// error occurs during the inspection, we want PLEG to retry again</span></span><br><span class="line">            <span class="hljs-comment">// in the next relist. To achieve this, we do not update the</span></span><br><span class="line">            <span class="hljs-comment">// associated podRecord of the pod, so that the change will be</span></span><br><span class="line">            <span class="hljs-comment">// detect again in the next relist.</span></span><br><span class="line">            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> If many pods changed during the same relist period,</span></span><br><span class="line">            <span class="hljs-comment">// inspecting the pod and getting the PodStatus to update the cache</span></span><br><span class="line">            <span class="hljs-comment">// serially may take a while. We should be aware of this and</span></span><br><span class="line">            <span class="hljs-comment">// parallelize if needed.</span></span><br><span class="line">            <span class="hljs-keyword">if</span> err := g.updateCache(pod, pid); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">                <span class="hljs-comment">// Rely on updateCache calling GetPodStatus to log the actual error.</span></span><br><span class="line">                klog.V(<span class="hljs-number">4</span>).Infof(<span class="hljs-string">"PLEG: Ignoring events for pod %s/%s: %v"</span>, pod.Name, pod.Namespace, err)</span><br><span class="line"></span><br><span class="line">                <span class="hljs-comment">// make sure we try to reinspect the pod during the next relisting</span></span><br><span class="line">                needsReinspection[pid] = pod</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">continue</span></span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> _, found := g.podsToReinspect[pid]; found &#123;</span><br><span class="line">                <span class="hljs-comment">// this pod was in the list to reinspect and we did so because it had events, so remove it</span></span><br><span class="line">                <span class="hljs-comment">// from the list (we don't want the reinspection code below to inspect it a second time in</span></span><br><span class="line">                <span class="hljs-comment">// this relist execution)</span></span><br><span class="line">                <span class="hljs-built_in">delete</span>(g.podsToReinspect, pid)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// Update the internal storage and send out the events.</span></span><br><span class="line">        g.podRecords.update(pid)</span><br><span class="line">        <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> events &#123;</span><br><span class="line">            <span class="hljs-comment">// Filter out events that are not reliable and no other components use yet.</span></span><br><span class="line">            <span class="hljs-keyword">if</span> events[i].Type == ContainerChanged &#123;</span><br><span class="line">                <span class="hljs-keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">select</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">case</span> g.eventChannel &lt;- events[i]:</span><br><span class="line">            <span class="hljs-keyword">default</span>:</span><br><span class="line">                metrics.PLEGDiscardEvents.WithLabelValues().Inc()</span><br><span class="line">                klog.Error(<span class="hljs-string">"event channel is full, discard this relist() cycle event"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> g.cacheEnabled() &#123;</span><br><span class="line">        <span class="hljs-comment">// reinspect any pods that failed inspection during the previous relist</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(g.podsToReinspect) &gt; <span class="hljs-number">0</span> &#123;</span><br><span class="line">            klog.V(<span class="hljs-number">5</span>).Infof(<span class="hljs-string">"GenericPLEG: Reinspecting pods that previously failed inspection"</span>)</span><br><span class="line">            <span class="hljs-keyword">for</span> pid, pod := <span class="hljs-keyword">range</span> g.podsToReinspect &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> err := g.updateCache(pod, pid); err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">                    <span class="hljs-comment">// Rely on updateCache calling GetPodStatus to log the actual error.</span></span><br><span class="line">                    klog.V(<span class="hljs-number">5</span>).Infof(<span class="hljs-string">"PLEG: pod %s/%s failed reinspection: %v"</span>, pod.Name, pod.Namespace, err)</span><br><span class="line">                    needsReinspection[pid] = pod</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// Update the cache timestamp.  This needs to happen *after*</span></span><br><span class="line">        <span class="hljs-comment">// all pods have been properly updated in the cache.</span></span><br><span class="line">        g.cache.UpdateTime(timestamp)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// make sure we retain the list of pods that need reinspecting the next time relist is called</span></span><br><span class="line">    g.podsToReinspect = needsReinspection</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>relist 中 export 了两个监控指标：<code>relist_interval</code> 和 <code>relist_latency</code>，它们俩的关系是：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">relist_interval = relist_latency + relist_period</span><br></pre></td></tr></table></figure><p>整个 relist 的流程大致为：</p><ol><li>从 container runtime 获取所有 Pod，更新至 podRecords 的 current state</li><li>遍历 podRecords，对比 current state 和 old state，产生 lifecycle events 并按照 pod 分组</li><li>遍历 pod 和 对应的 events，从 container runtime 获取 pod status 更新 cache（记录失败的 Pod，准备下次重试），并将 PLEG event （除了 ContainerChanged 事件）放入 eventChannel</li><li>遍历上次 relist 更新 cache 失败的 Pod，尝试再次获取 pod status 更新 cache</li></ol><p>relist 函数通过访问 container runtime 将 pod 和 container 的实际状态更新至 kubelet 的 pod cache。其他模块 (pod worker) 使用的 pod cache，都由 PLEG 模块更新。</p><p>pod lifecycle event 的生成通过 <code>generateEvents</code> 函数比较 old state 和 new state 来实现：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateEvents</span><span class="hljs-params">(podID types.UID, cid <span class="hljs-keyword">string</span>, oldState, newState plegContainerState)</span> []*<span class="hljs-title">PodLifecycleEvent</span></span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> newState == oldState &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">klog.V(<span class="hljs-number">4</span>).Infof(<span class="hljs-string">"GenericPLEG: %v/%v: %v -&gt; %v"</span>, podID, cid, oldState, newState)</span><br><span class="line"><span class="hljs-keyword">switch</span> newState &#123;</span><br><span class="line"><span class="hljs-keyword">case</span> plegContainerRunning:</span><br><span class="line"><span class="hljs-keyword">return</span> []*PodLifecycleEvent&#123;&#123;ID: podID, Type: ContainerStarted, Data: cid&#125;&#125;</span><br><span class="line"><span class="hljs-keyword">case</span> plegContainerExited:</span><br><span class="line"><span class="hljs-keyword">return</span> []*PodLifecycleEvent&#123;&#123;ID: podID, Type: ContainerDied, Data: cid&#125;&#125;</span><br><span class="line"><span class="hljs-keyword">case</span> plegContainerUnknown:</span><br><span class="line"><span class="hljs-keyword">return</span> []*PodLifecycleEvent&#123;&#123;ID: podID, Type: ContainerChanged, Data: cid&#125;&#125;</span><br><span class="line"><span class="hljs-keyword">case</span> plegContainerNonExistent:</span><br><span class="line"><span class="hljs-keyword">switch</span> oldState &#123;</span><br><span class="line"><span class="hljs-keyword">case</span> plegContainerExited:</span><br><span class="line"><span class="hljs-comment">// We already reported that the container died before.</span></span><br><span class="line"><span class="hljs-keyword">return</span> []*PodLifecycleEvent&#123;&#123;ID: podID, Type: ContainerRemoved, Data: cid&#125;&#125;</span><br><span class="line"><span class="hljs-keyword">default</span>:</span><br><span class="line"><span class="hljs-keyword">return</span> []*PodLifecycleEvent&#123;&#123;ID: podID, Type: ContainerDied, Data: cid&#125;, &#123;ID: podID, Type: ContainerRemoved, Data: cid&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">default</span>:</span><br><span class="line"><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">"unrecognized container state: %v"</span>, newState))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便看看 Container Runtime 接口，对于 Container Runtime，我们主要关注 PLEG 用到的两个方法 <code>GetPods</code> 和 <code>GetPodStatus</code>，参照 <code>pkg/kubelet/container/runtime.go</code> 文件：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Runtime interface defines the interfaces that should be implemented</span></span><br><span class="line"><span class="hljs-comment">// by a container runtime.</span></span><br><span class="line"><span class="hljs-comment">// Thread safety is required from implementations of this interface.</span></span><br><span class="line"><span class="hljs-keyword">type</span> Runtime <span class="hljs-keyword">interface</span> &#123;</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">    <span class="hljs-comment">// GetPods returns a list of containers grouped by pods. The boolean parameter</span></span><br><span class="line">    <span class="hljs-comment">// specifies whether the runtime returns all containers including those already</span></span><br><span class="line">    <span class="hljs-comment">// exited and dead containers (used for garbage collection).</span></span><br><span class="line">    GetPods(all <span class="hljs-keyword">bool</span>) ([]*Pod, error)</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">    <span class="hljs-comment">// GetPodStatus retrieves the status of the pod, including the</span></span><br><span class="line">    <span class="hljs-comment">// information of all containers in the pod that are visible in Runtime.</span></span><br><span class="line">    GetPodStatus(uid types.UID, name, namespace <span class="hljs-keyword">string</span>) (*PodStatus, error)</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GetPods</code> 主要是获取 pod 列表和 pod/container 的基本信息，<code>GetPodStatus</code> 则获取单个 pod 内所有容器的详细状态信息（包括 pod IP 和 runtime 返回的一些状态）。</p><p>关于事件通知，上面提到 PLEG 会将 pod lifecycle events 放入一个 channel，<code>Watch</code> 方法返回了这个 channel。</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Watch returns a channel from which the subscriber can receive PodLifecycleEvent</span></span><br><span class="line"><span class="hljs-comment">// events.</span></span><br><span class="line"><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> support multiple subscribers.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *GenericPLEG)</span> <span class="hljs-title">Watch</span><span class="hljs-params">()</span> <span class="hljs-title">chan</span> *<span class="hljs-title">PodLifecycleEvent</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> g.eventChannel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 PLEG 如何判断自己工作是否正常呢？通过暴露 <code>Healthy</code> 方法，<code>GenericPLEG</code> 保存了上一次开始执行 relist 的时间戳，<code>Healthy</code> 方法判断与当前时间的间隔，只要大于阈值，则认为 PLEG unhealthy。</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Healthy check if PLEG work properly.</span></span><br><span class="line"><span class="hljs-comment">// relistThreshold is the maximum interval between two relist.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *GenericPLEG)</span> <span class="hljs-title">Healthy</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">    relistTime := g.getRelistTime()</span><br><span class="line">    <span class="hljs-keyword">if</span> relistTime.IsZero() &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, fmt.Errorf(<span class="hljs-string">"pleg has yet to be successful"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    elapsed := g.clock.Since(relistTime)</span><br><span class="line">    <span class="hljs-keyword">if</span> elapsed &gt; relistThreshold &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, fmt.Errorf(<span class="hljs-string">"pleg was last seen active %v ago; threshold is %v"</span>, elapsed, relistThreshold)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个阈值在 <code>pkg/kubelet/pleg/generic.go</code> 中定义：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> (</span><br><span class="line">    <span class="hljs-comment">// The threshold needs to be greater than the relisting period + the</span></span><br><span class="line">    <span class="hljs-comment">// relisting time, which can vary significantly. Set a conservative</span></span><br><span class="line">    <span class="hljs-comment">// threshold to avoid flipping between healthy and unhealthy.</span></span><br><span class="line">    relistThreshold = <span class="hljs-number">3</span> * time.Minute</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>默认是 <code>3m</code>，也就是说只要 relist 执行时间超过 3 分钟，则认为 PLEG unhealthy。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后我们总结一下整个流程：</p><ol><li>kubelet 创建并启动 PLEG 模块，watch pod lifecycle event</li><li>PLEG 模块每隔 <code>1s</code> 执行 relist，relist 完成两个目标：<ol><li>获取 pod list，对比 pod 的 old state 和 new state，产生 PLEG events</li><li>依次获取 pod status，并更新 pod cache</li></ol></li><li>kubelet watch 到 pod lifecycle events，产生 update pod 事件通知 pod worker 执行 sync pod 操作</li><li>kubelet 持续检查 runtime state (PLEG) 的健康状态</li></ol><p>本文对下面几个方面没有深入介绍，后面有空会写单独的文章将源码解析分享出来：</p><ul><li>kubelet sync loop iteration</li><li>pod worker 的 sync pod 机制</li><li>container runtime</li><li>node status 节点状态控制</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PLEG (pod lifecycle event generator) 是 kubelet 中一个非常重要的模块，它主要完成以下几个目标：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;从 runtime 中获取 pod 当前状态，产生 pod lifecycle events&lt;/li&gt;&lt;li&gt;从 runtime 中获取 pod 当前状态，更新 kubelet pod cache&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;本文我们通过分析 PLEG 模块的源码，来加深对 Kubernetes 的理解，也可以加速在使用过程对一些疑难问题的排查和处理，同时后期可以对一些问题源码进行优化，来解决一些 Kubernetes 本身的坑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="云计算" scheme="http://whypro.github.io/hexo-blog/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Kubernetes" scheme="http://whypro.github.io/hexo-blog/tags/Kubernetes/"/>
    
      <category term="K8S" scheme="http://whypro.github.io/hexo-blog/tags/K8S/"/>
    
      <category term="Kubelet" scheme="http://whypro.github.io/hexo-blog/tags/Kubelet/"/>
    
  </entry>
  
  <entry>
    <title>二叉树两个节点之间的最大距离</title>
    <link href="http://whypro.github.io/hexo-blog/20190523/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB/"/>
    <id>http://whypro.github.io/hexo-blog/20190523/二叉树两个节点之间的最大距离/</id>
    <published>2019-05-23T13:01:16.000Z</published>
    <updated>2019-06-02T09:10:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，求它两个节点之间的最大距离。</p><p>比如二叉树：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p>的最大距离为 3。</p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>刚看到这个题目时有点懵，仔细分析了一下，求根节点为 Root 的二叉树中两个节点的最大距离，需要分两种情况考虑：</p><h3 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h3><p>如果最大距离经过了 Root，则最大距离：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MaxDistance(root) = MaxDepth(root.Left) + MaxDepth(root.Right) + 2</span><br></pre></td></tr></table></figure><p>假设 <code>root</code> 节点为 <code>1</code>，示例图为：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">  // \\</span><br><span class="line">  2   3</span><br><span class="line">// \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><h3 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h3><p>如果最大距离没有经过 Root，则最大距离：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MaxDistance(root) = max(MaxDistance(root.Left), MaxDistance(root.Right))</span><br></pre></td></tr></table></figure><p>假设 <code>root</code> 节点为 <code>1</code>，示例图为：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     /</span><br><span class="line">    2</span><br><span class="line">  // \\</span><br><span class="line">  3   4</span><br><span class="line">//     \\</span><br><span class="line">5       6</span><br></pre></td></tr></table></figure><p>想必大家已经通过公式看出规律来了，父节点的 <code>maxDistance</code> 可以通过两个子节点的 <code>maxDistance</code> 和 <code>maxDepth</code> 求出，合并 <code>1</code> <code>2</code> 两种情况，最终的状态转移方程如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MaxDistance(root) = max(max(MaxDistance(root.Left), MaxDistance(root.Right)), MaxDepth(root.Left) + MaxDepth(root.Right) + 2)</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们需要有个数据结构保存中间结果，即 <code>maxDepth</code> 和 <code>maxDistance</code>。</p><p>另外，这里我们确定 <code>root</code> 节点的深度为 <code>0</code>，因此将 <code>nil</code> 节点的深度初始化为 <code>-1</code>。</p><p>整个算法使用了递归方式。</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> TreeNode <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="hljs-keyword">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">type</span> result <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">    maxDepth    <span class="hljs-keyword">int</span></span><br><span class="line">    maxDistance <span class="hljs-keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMaxDistance</span><span class="hljs-params">(root *TreeNode)</span> *<span class="hljs-title">result</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> &amp;result&#123;</span><br><span class="line">            maxDepth:    <span class="hljs-number">-1</span>,</span><br><span class="line">            maxDistance: <span class="hljs-number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    left := getMaxDistance(root.Left)</span><br><span class="line">    right := getMaxDistance(root.Right)</span><br><span class="line">    maxDepth := max(left.maxDepth+<span class="hljs-number">1</span>, right.maxDepth+<span class="hljs-number">1</span>)</span><br><span class="line">    maxDistance := max(max(left.maxDistance, right.maxDistance), left.maxDepth+right.maxDepth+<span class="hljs-number">2</span>)</span><br><span class="line">    <span class="hljs-keyword">return</span> &amp;result&#123;</span><br><span class="line">        maxDepth:    maxDepth,</span><br><span class="line">        maxDistance: maxDistance,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetMaxDistance</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line">    result := getMaxDistance(root)</span><br><span class="line">    <span class="hljs-keyword">return</span> result.maxDistance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在这里在线运行：<a href="https://play.golang.org/p/CwIvHaBJwP-" target="_blank" rel="noopener">https://play.golang.org/p/CwIvHaBJwP-</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个二叉树，求它两个节点之间的最大距离。&lt;/p&gt;&lt;p&gt;比如二叉树：&lt;/p&gt;&lt;figure class=&quot;highlight plain hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2   3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4   5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;的最大距离为 3。&lt;/p&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="算法" scheme="http://whypro.github.io/hexo-blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>有序数组的不同绝对值个数</title>
    <link href="http://whypro.github.io/hexo-blog/20190523/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8D%E5%90%8C%E7%BB%9D%E5%AF%B9%E5%80%BC%E4%B8%AA%E6%95%B0/"/>
    <id>http://whypro.github.io/hexo-blog/20190523/有序数组的不同绝对值个数/</id>
    <published>2019-05-23T11:11:28.000Z</published>
    <updated>2019-06-02T09:10:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个有序数组，求它的元素不同的绝对值个数。</p><p>比如</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-3, -1, 0, 0, 1, 1, 2, 5]</span><br></pre></td></tr></table></figure><p>返回</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>首先一个循环将数组所有的负数转换为正数，然后对整个数组进行排序。</p><p>但循环一遍的时间复杂度为 <code>O(n)</code>，排序如果用堆排序，平均时间复杂度为 <code>O(nlogn)</code>，空间复杂度为 <code>O(1)</code>。因此整体的时间复杂度为 <code>O(nlogn)</code>，空间复杂度为 <code>O(1)</code>。而既然题目已经保证了有序数组，那有没有更快的方法呢？</p><h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><p>我们可以用两个索引，索引 i 和 索引 j 分别从数组两端向中间移动，如果当前元素和下一个元素相等则跳过，如果右边的绝对值大于左边的绝对值，则索引 j 左移，如果左边的绝对值大于右边的绝对值，则索引 i 右移，如果两边绝对值相等，则索引同时左移和右移，每次移动计数加一。直到索引相遇时结束，如果相遇后索引刚好相等，则计数最后再加一。</p><p>这样时间复杂度就为 <code>O(n)</code>，空间复杂度为 <code>O(1)</code>。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>使用 Golang 实现的源码如下：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getDistinctAbsCount</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line">    i := <span class="hljs-number">0</span></span><br><span class="line">    j := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span></span><br><span class="line">    count := <span class="hljs-number">0</span></span><br><span class="line">    <span class="hljs-keyword">for</span> i &lt; j &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span> &amp;&amp; nums[i] == nums[i+<span class="hljs-number">1</span>] &#123;</span><br><span class="line">            <span class="hljs-comment">// skip duplicated</span></span><br><span class="line">            i += <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> j &gt; <span class="hljs-number">0</span> &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>] &#123;</span><br><span class="line">            <span class="hljs-comment">// skip duplicated</span></span><br><span class="line">            j -= <span class="hljs-number">1</span></span><br><span class="line">            <span class="hljs-keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum := nums[i] + nums[j]</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> sum &gt; <span class="hljs-number">0</span> &#123;</span><br><span class="line">            <span class="hljs-comment">// abs(nums[i]) &lt; abs(nums[j])</span></span><br><span class="line">            j -= <span class="hljs-number">1</span></span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> sum &lt; <span class="hljs-number">0</span> &#123;</span><br><span class="line">            <span class="hljs-comment">// abs(nums[i]) &gt; abs(nums[j])</span></span><br><span class="line">            i += <span class="hljs-number">1</span></span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-comment">// abs(nums[i]) == abs(nums[j])</span></span><br><span class="line">            i += <span class="hljs-number">1</span></span><br><span class="line">            j -= <span class="hljs-number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        count += <span class="hljs-number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> i == j &#123;</span><br><span class="line">        count += <span class="hljs-number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可在这里在线运行：<a href="https://play.golang.org/p/lmOI5ZNkMNf" target="_blank" rel="noopener">https://play.golang.org/p/lmOI5ZNkMNf</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个有序数组，求它的元素不同的绝对值个数。&lt;/p&gt;&lt;p&gt;比如&lt;/p&gt;&lt;figure class=&quot;highlight plain hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[-3, -1, 0, 0, 1, 1, 2, 5]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;返回&lt;/p&gt;&lt;figure class=&quot;highlight plain hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="算法" scheme="http://whypro.github.io/hexo-blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>从零开始实现一个 terraform plugin</title>
    <link href="http://whypro.github.io/hexo-blog/20190522/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-terraform-plugin/"/>
    <id>http://whypro.github.io/hexo-blog/20190522/从零开始实现一个-terraform-plugin/</id>
    <published>2019-05-22T06:13:02.000Z</published>
    <updated>2019-06-02T09:10:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>terraform 作为一个优秀的开源基础设施管理、构建工具，官方或第三方提供了很多 plugin 来对接各种云平台（IaaS）。然而在我们平时开发和测试过程中，需要使用内部的 IaaS 服务频繁创建和删除 VM，而目前人工操作的方式比较费时费力，且没有现成的 plugin 可以使用。为了更方便地利用 terraform 工具来对内部 IaaS 资源进行管理和操作，我们决定自己开发一个 terraform plugin。</p><a id="more"></a><h2 id="定义-Provider-Schema"><a href="#定义-Provider-Schema" class="headerlink" title="定义 Provider Schema"></a>定义 Provider Schema</h2><p>首先，我们定义入口文件 <code>main.go</code>：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> (</span><br><span class="line">    <span class="hljs-string">"github.com/hashicorp/terraform/plugin"</span></span><br><span class="line">    qvm <span class="hljs-string">"qiniu.com/kirk-deploy/pkg/qvm/terraform"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    plugin.Serve(&amp;plugin.ServeOpts&#123;</span><br><span class="line">        ProviderFunc: qvm.Provider,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>qvm.Provider</code> 函数负责创建一个 provider resource。</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Provider</span><span class="hljs-params">()</span> <span class="hljs-title">terraform</span>.<span class="hljs-title">ResourceProvider</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> &amp;schema.Provider&#123;</span><br><span class="line">        Schema: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*schema.Schema&#123;</span><br><span class="line">            <span class="hljs-string">"url"</span>: &#123;</span><br><span class="line">                Type:        schema.TypeString,</span><br><span class="line">                Optional:    <span class="hljs-literal">true</span>,</span><br><span class="line">                DefaultFunc: schema.EnvDefaultFunc(<span class="hljs-string">"QVM_URL"</span>, <span class="hljs-string">""</span>),</span><br><span class="line">                Description: descriptions[<span class="hljs-string">"url"</span>],</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="hljs-string">"ak"</span>: &#123;</span><br><span class="line">                Type:        schema.TypeString,</span><br><span class="line">                Optional:    <span class="hljs-literal">true</span>,</span><br><span class="line">                DefaultFunc: schema.EnvDefaultFunc(<span class="hljs-string">"QVM_AK"</span>, <span class="hljs-string">""</span>),</span><br><span class="line">                Description: descriptions[<span class="hljs-string">"ak"</span>],</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="hljs-string">"sk"</span>: &#123;</span><br><span class="line">                Type:        schema.TypeString,</span><br><span class="line">                Optional:    <span class="hljs-literal">true</span>,</span><br><span class="line">                DefaultFunc: schema.EnvDefaultFunc(<span class="hljs-string">"QVM_SK"</span>, <span class="hljs-string">""</span>),</span><br><span class="line">                Description: descriptions[<span class="hljs-string">"sk"</span>],</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        ResourcesMap: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*schema.Resource&#123;</span><br><span class="line">            <span class="hljs-string">"compute_instance"</span>: resourceComputeInstance(),</span><br><span class="line">        &#125;,</span><br><span class="line">        ConfigureFunc: configureProvider,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Schema</code> 声明了 provider 配置文件的定义，对应的 <code>tf</code> 文件这样写：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">provider qvm &#123;</span><br><span class="line">    url = &quot;https://qvm.qiniuapi.com&quot;</span><br><span class="line">    ak = &quot;your app key&quot;</span><br><span class="line">    sk = &quot;your app secret&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不在 <code>tf</code> 文件里指定 <code>ak</code> 和 <code>sk</code>，则 terraform 会根据 <code>DefaultFunc</code>，从环境变量 <code>QVM_AK</code> 和 <code>QVM_SK</code> 中获取。<code>Optional</code> 代表字段是可选的，即使用户没有填也不会报错。</p><p><code>ResourcesMap</code> 声明了 provider 支持的资源和对应资源的工厂函数，例如这里我们只实现了计算资源，工厂函数的定义我们稍后再解释。</p><h2 id="定义-Resource-Schema"><a href="#定义-Resource-Schema" class="headerlink" title="定义 Resource Schema"></a>定义 Resource Schema</h2><p>上面提到的 <code>resourceComputeInstance</code> 负责创建一个 compute instance resource，对于计算资源我们可以这样定义：</p><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">resourceComputeInstance</span><span class="hljs-params">()</span> *<span class="hljs-title">schema</span>.<span class="hljs-title">Resource</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> &amp;schema.Resource&#123;</span><br><span class="line">        Create: resourceComputeInstanceCreate,</span><br><span class="line">        Read:   resourceComputeInstanceRead,</span><br><span class="line">        Update: resourceComputeInstanceUpdate,</span><br><span class="line">        Delete: resourceComputeInstanceDelete,</span><br><span class="line">        Timeouts: &amp;schema.ResourceTimeout&#123;</span><br><span class="line">            Create: schema.DefaultTimeout(<span class="hljs-number">30</span> * time.Minute),</span><br><span class="line">            Update: schema.DefaultTimeout(<span class="hljs-number">30</span> * time.Minute),</span><br><span class="line">            Delete: schema.DefaultTimeout(<span class="hljs-number">30</span> * time.Minute),</span><br><span class="line">        &#125;,</span><br><span class="line">        Schema: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*schema.Schema&#123;</span><br><span class="line">            <span class="hljs-string">"image_id"</span>: &#123;</span><br><span class="line">                Type:     schema.TypeString,</span><br><span class="line">                Optional: <span class="hljs-literal">true</span>,</span><br><span class="line">                ForceNew: <span class="hljs-literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="hljs-string">"instance_name"</span>: &#123;</span><br><span class="line">                Type:     schema.TypeString,</span><br><span class="line">                Optional: <span class="hljs-literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="hljs-string">"system_disk"</span>: &#123;</span><br><span class="line">                Type:     schema.TypeList,</span><br><span class="line">                Required: <span class="hljs-literal">true</span>,</span><br><span class="line">                MaxItems: <span class="hljs-number">1</span>,</span><br><span class="line">                Elem: &amp;schema.Resource&#123;</span><br><span class="line">                    Schema: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*schema.Schema&#123;</span><br><span class="line">                        <span class="hljs-string">"category"</span>: &#123;</span><br><span class="line">                            Type:     schema.TypeString,</span><br><span class="line">                            Optional: <span class="hljs-literal">true</span>,</span><br><span class="line">                            Default:  enums.DiskCategoryCloudEfficiency,</span><br><span class="line">                            ForceNew: <span class="hljs-literal">true</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="hljs-string">"size"</span>: &#123;</span><br><span class="line">                            Type:     schema.TypeInt,</span><br><span class="line">                            Optional: <span class="hljs-literal">true</span>,</span><br><span class="line">                            Default:  <span class="hljs-number">40</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="hljs-string">"data_disk"</span>: &#123;</span><br><span class="line">                Type:     schema.TypeList,</span><br><span class="line">                Optional: <span class="hljs-literal">true</span>,</span><br><span class="line">                MinItems: <span class="hljs-number">1</span>,</span><br><span class="line">                MaxItems: <span class="hljs-number">15</span>,</span><br><span class="line">                Elem: &amp;schema.Resource&#123;</span><br><span class="line">                    Schema: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*schema.Schema&#123;</span><br><span class="line">                        <span class="hljs-string">"category"</span>: &#123;</span><br><span class="line">                            Type:     schema.TypeString,</span><br><span class="line">                            Optional: <span class="hljs-literal">true</span>,</span><br><span class="line">                            Default:  enums.DiskCategoryCloudEfficiency,</span><br><span class="line">                            ForceNew: <span class="hljs-literal">true</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="hljs-string">"size"</span>: &#123;</span><br><span class="line">                            Type:     schema.TypeInt,</span><br><span class="line">                            Optional: <span class="hljs-literal">true</span>,</span><br><span class="line">                            Default:  <span class="hljs-number">40</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Create</code> <code>Read</code> <code>Update</code> <code>Delete</code> 分别是管理资源的回调函数，terraform 框架会在合适的时间调用这几个函数，<code>Timeouts</code> 定义了每个操作的超时时间，<code>Schema</code> 与上面一样，是定义 <code>tf</code> 文件的具体结构。</p><p><code>ForceNew</code> 代表一旦这个字段改变，则 terraform 会删除并重新创建该资源。<code>TypeList</code> 定义了一个列表，如果 <code>MaxItems: 1</code> 时，列表退化为单个资源。</p><p>为了简化起见，<code>Schema</code> 我们省略了很多字段，对应的 <code>tf</code> 文件可以这样写：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;compute_instance&quot; &quot;test&quot; &#123;</span><br><span class="line">    count = &quot;$&#123;var.count&#125;&quot;</span><br><span class="line">    provider = &quot;qvm&quot;</span><br><span class="line">    image_id = &quot;$&#123;var.image&#125;&quot;</span><br><span class="line">    instance_name = &quot;$&#123;var.instance_name&#125;-$&#123;count.index&#125;&quot;</span><br><span class="line">    system_disk &#123;</span><br><span class="line">        category = &quot;efficiency&quot;</span><br><span class="line">        size = 40</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>${var.}</code> 代表在 varaibles.tf 文件里定义的变量，具体可以用法可以参考 terraform 官方文档，这里不过多地介绍。</p><h2 id="定义-Resource-Operation-Function"><a href="#定义-Resource-Operation-Function" class="headerlink" title="定义 Resource Operation Function"></a>定义 Resource Operation Function</h2><h3 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h3><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">resourceComputeInstanceCreate</span><span class="hljs-params">(d *schema.ResourceData, meta <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line">    config := meta.(*Config)</span><br><span class="line">    client, err := config.computeClient()</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    systemDisk := d.Get(<span class="hljs-string">"system_disk"</span>).([]<span class="hljs-keyword">interface</span>&#123;&#125;)[<span class="hljs-number">0</span>].(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    systemDiskParameters := params.CreateInstanceSystemDiskParameters&#123;</span><br><span class="line">        Category: enums.DiskCategory(systemDisk[<span class="hljs-string">"category"</span>].(<span class="hljs-keyword">string</span>)),</span><br><span class="line">        Size:     systemDisk[<span class="hljs-string">"size"</span>].(<span class="hljs-keyword">int</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parameters := &amp;params.CreateInstanceParameters&#123;</span><br><span class="line">        ImageId:            d.Get(<span class="hljs-string">"image_id"</span>).(<span class="hljs-keyword">string</span>),</span><br><span class="line">        SystemDisk:         systemDiskParameters,</span><br><span class="line">        InstanceName:       enums.InstanceName(d.Get(<span class="hljs-string">"instance_name"</span>).(<span class="hljs-keyword">string</span>)),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="hljs-string">"[DEBUG] CreateInstanceParameters: %#v"</span>, parameters)</span><br><span class="line">    rsp, err := client.CreateInstance(parameters)</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="hljs-string">"[ERROR] create instance error, %v"</span>, err)</span><br><span class="line">        <span class="hljs-keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="hljs-string">"[INFO] Instance ID: %s"</span>, rsp.Data.InstanceId)</span><br><span class="line">    d.SetId(rsp.Data.InstanceId)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> resourceComputeInstanceRead(d, meta)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Create</code> 的实现最重要的一个操作是 <code>SetId</code>，如果服务端资源创建成功，会返回一个 InstanceId，<code>SetId</code> 会将这个 InstanceId 保存，作为以后判断资源是否更新的 key。</p><p>return 前又进行了一次 <code>Read</code> 操作，是为了防止有些状态字段没有通过 CreateResponse 返回，再尝试通过一次 Read 来获取这些状态信息。</p><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">resourceComputeInstanceDelete</span><span class="hljs-params">(d *schema.ResourceData, meta <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line">    config := meta.(*Config)</span><br><span class="line">    client, err := config.computeClient()</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p := &amp;params.DeleteInstanceParameters&#123;</span><br><span class="line">        InstanceId: d.Id(),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _, err = client.DeleteInstance(p)</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">resourceComputeInstanceUpdate</span><span class="hljs-params">(d *schema.ResourceData, meta <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> resourceComputeInstanceRead(d, meta)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们暂时不实现 <code>Update</code> 操作，因此这里只是简单地返回 Read。</p><h3 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h3><figure class="highlight golang hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">resourceComputeInstanceRead</span><span class="hljs-params">(d *schema.ResourceData, meta <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;</span><br><span class="line">    config := meta.(*Config)</span><br><span class="line">    client, err := config.computeClient()</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p := &amp;params.DescribeInstanceParameters&#123;</span><br><span class="line">        InstanceId: d.Id(),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rsp, err := client.GetInstance(p)</span><br><span class="line">    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    instance := &amp;rsp.Data</span><br><span class="line">    d.Set(<span class="hljs-string">"image_id"</span>, instance.ImageId)</span><br><span class="line">    d.Set(<span class="hljs-string">"instance_name"</span>, instance.InstanceName)</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Read</code> 通过 InstanceId 对资源状态进行查询，保存至 resource data。</p><h2 id="编译和构建"><a href="#编译和构建" class="headerlink" title="编译和构建"></a>编译和构建</h2><p>上面基本代码框架实现后，我们就可以对 plugin 进行编译和构建了：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -o terraform-provider-qvm</span><br></pre></td></tr></table></figure><p>二进制文件的命名必须遵守以下命名规则：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform-provider-&lt;NAME&gt;</span><br></pre></td></tr></table></figure><p>构建后，我们手动将二进制拷贝至 terraform 默认的插件目录：<code>${HOME}/.terraform/plguins</code>。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>进入工作目录，即 <code>tf</code> 文件保存的目录，假设这个目录的结构为：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">terraform/qvm</span><br><span class="line">├── provider.tf</span><br><span class="line">├── resources.tf</span><br><span class="line">├── variables.tf</span><br><span class="line">└── terraform.tfvars</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform init</span><br></pre></td></tr></table></figure><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>可以通过 <code>export</code> 或创建 <code>.tfvars</code> 文件，对配置进行修改：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export QVM_AK=</span><br><span class="line">export QVM_SK=</span><br></pre></td></tr></table></figure><p>创建 <code>terraform.tfvars</code> 文件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">instance_name = &quot;&quot;</span><br><span class="line">count = 1</span><br><span class="line">image = &quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="查看更改"><a href="#查看更改" class="headerlink" title="查看更改"></a>查看更改</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform plan</span><br></pre></td></tr></table></figure><p>执行后 terraform 会对配置进行合法性校验。</p><h3 id="应用更改"><a href="#应用更改" class="headerlink" title="应用更改"></a>应用更改</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform apply</span><br></pre></td></tr></table></figure><p>或者指定 <code>.tfvars</code> 文件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform apply -var-file=&quot;terraform.tfvars&quot;</span><br></pre></td></tr></table></figure><h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform destroy</span><br></pre></td></tr></table></figure><p>或者指定 <code>.tfvars</code> 文件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">terraform destroy -var-file=&quot;terraform.tfvars&quot;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.terraform.io/docs/extend/writing-custom-providers.html" target="_blank" rel="noopener">https://www.terraform.io/docs/extend/writing-custom-providers.html</a></p><p><a href="https://www.terraform.io/docs/extend/how-terraform-works.html" target="_blank" rel="noopener">https://www.terraform.io/docs/extend/how-terraform-works.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;terraform 作为一个优秀的开源基础设施管理、构建工具，官方或第三方提供了很多 plugin 来对接各种云平台（IaaS）。然而在我们平时开发和测试过程中，需要使用内部的 IaaS 服务频繁创建和删除 VM，而目前人工操作的方式比较费时费力，且没有现成的 plugin 可以使用。为了更方便地利用 terraform 工具来对内部 IaaS 资源进行管理和操作，我们决定自己开发一个 terraform plugin。&lt;/p&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="Golang" scheme="http://whypro.github.io/hexo-blog/tags/Golang/"/>
    
      <category term="terraform" scheme="http://whypro.github.io/hexo-blog/tags/terraform/"/>
    
  </entry>
  
  <entry>
    <title>使用 Devstack 搭建 Openstack 集群</title>
    <link href="http://whypro.github.io/hexo-blog/20190107/%E4%BD%BF%E7%94%A8-Devstack-%E6%90%AD%E5%BB%BA-Openstack-%E9%9B%86%E7%BE%A4/"/>
    <id>http://whypro.github.io/hexo-blog/20190107/使用-Devstack-搭建-Openstack-集群/</id>
    <published>2019-01-07T07:22:00.000Z</published>
    <updated>2019-06-02T09:10:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>多节点搭建步骤：</p><p><a href="https://docs.openstack.org/devstack/rocky/guides/multinode-lab.html" target="_blank" rel="noopener">https://docs.openstack.org/devstack/rocky/guides/multinode-lab.html</a></p><p>要配置 kvm，否则使用默认的 qemu 跑 vm 性能会很差：</p><p><a href="https://docs.openstack.org/devstack/rocky/guides/devstack-with-nested-kvm.html" target="_blank" rel="noopener">https://docs.openstack.org/devstack/rocky/guides/devstack-with-nested-kvm.html</a></p><a id="more"></a><p>control 节点配置:</p><figure class="highlight ini hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">[[local|localrc]]</span></span><br><span class="line"><span class="hljs-attr">HOST_IP</span>=<span class="hljs-number">10.20</span>.<span class="hljs-number">102.37</span></span><br><span class="line"><span class="hljs-attr">FLAT_INTERFACE</span>=bond0</span><br><span class="line"><span class="hljs-attr">FIXED_RANGE</span>=<span class="hljs-number">10.4</span>.<span class="hljs-number">128.0</span>/<span class="hljs-number">20</span></span><br><span class="line"><span class="hljs-attr">FIXED_NETWORK_SIZE</span>=<span class="hljs-number">4096</span></span><br><span class="line"><span class="hljs-attr">FLOATING_RANGE</span>=<span class="hljs-number">10.20</span>.<span class="hljs-number">102.223</span>/<span class="hljs-number">27</span></span><br><span class="line"><span class="hljs-attr">MULTI_HOST</span>=<span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-attr">LOGFILE</span>=/opt/stack/logs/stack.sh.log</span><br><span class="line"><span class="hljs-attr">ADMIN_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">DATABASE_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">RABBIT_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">SERVICE_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">LIBVIRT_TYPE</span>=kvm</span><br><span class="line"><span class="hljs-attr">IP_VERSION</span>=<span class="hljs-number">4</span></span><br></pre></td></tr></table></figure><p>compute 节点配置:</p><figure class="highlight ini hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">[[local|localrc]]</span></span><br><span class="line"><span class="hljs-attr">HOST_IP</span>=<span class="hljs-number">10.20</span>.<span class="hljs-number">102.38</span> # change this per compute node</span><br><span class="line"><span class="hljs-attr">FLAT_INTERFACE</span>=bond0</span><br><span class="line"><span class="hljs-attr">FIXED_RANGE</span>=<span class="hljs-number">10.4</span>.<span class="hljs-number">128.0</span>/<span class="hljs-number">20</span></span><br><span class="line"><span class="hljs-attr">FIXED_NETWORK_SIZE</span>=<span class="hljs-number">4096</span></span><br><span class="line"><span class="hljs-attr">FLOATING_RANGE</span>=<span class="hljs-number">10.20</span>.<span class="hljs-number">102.223</span>/<span class="hljs-number">27</span></span><br><span class="line"><span class="hljs-attr">MULTI_HOST</span>=<span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-attr">LOGFILE</span>=/opt/stack/logs/stack.sh.log</span><br><span class="line"><span class="hljs-attr">ADMIN_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">DATABASE_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">RABBIT_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">SERVICE_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">DATABASE_TYPE</span>=mysql</span><br><span class="line"><span class="hljs-attr">SERVICE_HOST</span>=<span class="hljs-number">10.20</span>.<span class="hljs-number">102.37</span></span><br><span class="line"><span class="hljs-attr">MYSQL_HOST</span>=<span class="hljs-variable">$SERVICE_HOST</span></span><br><span class="line"><span class="hljs-attr">RABBIT_HOST</span>=<span class="hljs-variable">$SERVICE_HOST</span></span><br><span class="line"><span class="hljs-attr">GLANCE_HOSTPORT</span>=<span class="hljs-variable">$SERVICE_HOST</span>:<span class="hljs-number">9292</span></span><br><span class="line"><span class="hljs-attr">ENABLED_SERVICES</span>=n-cpu,q-agt,n-api-meta,c-vol,placement-client</span><br><span class="line"><span class="hljs-attr">NOVA_VNC_ENABLED</span>=<span class="hljs-literal">True</span></span><br><span class="line"><span class="hljs-attr">NOVNCPROXY_URL</span>=<span class="hljs-string">"http://$SERVICE_HOST:6080/vnc_auto.html"</span></span><br><span class="line"><span class="hljs-attr">VNCSERVER_LISTEN</span>=<span class="hljs-variable">$HOST_IP</span></span><br><span class="line"><span class="hljs-attr">VNCSERVER_PROXYCLIENT_ADDRESS</span>=<span class="hljs-variable">$VNCSERVER_LISTEN</span></span><br><span class="line"><span class="hljs-attr">LIBVIRT_TYPE</span>=kvm</span><br><span class="line"><span class="hljs-attr">IP_VERSION</span>=<span class="hljs-number">4</span></span><br></pre></td></tr></table></figure><ul><li><code>FIXED_RANGE</code> 是 vm 实例的内网地址，供 vm 之间访问，vm 创建时便会分配一个，创建后一般不能更改。</li><li><code>FLOATING_RANGE</code> 是 vm 实例的外网地址，供物理机访问 vm，以及 vm 访问物理机，可以在实例创建后进行绑定和解绑。这个网段一般设置为物理机 IP 的子网段。</li></ul><p>如果需要 ipv6，则需要修改以下参数：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">net.ipv6.conf.all.disable_ipv6=0</span><br><span class="line">net.ipv6.conf.default.disable_ipv6=0</span><br><span class="line">net.ipv6.conf.lo.disable_ipv6=0</span><br><span class="line"></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>不要按照 devstack 官方文档创建 <code>local.sh</code>。因为 openstack rocky 已经默认使用 neutron 了，这个脚本对 neutron 没有什么作用。<a href="https://bugs.launchpad.net/devstack/+bug/1783576" target="_blank" rel="noopener">https://bugs.launchpad.net/devstack/+bug/1783576</a></p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> `seq 2 10`; <span class="hljs-keyword">do</span> /opt/stack/nova/bin/nova-manage fixed reserve 10.4.128.<span class="hljs-variable">$i</span>; <span class="hljs-keyword">done</span></span><br></pre></td></tr></table></figure><p>多节点如果出现调度错误，需要执行：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./tools/discover_hosts.sh</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nova-manage cell_v2 discover_hosts --verbose</span><br></pre></td></tr></table></figure><p>如果如果遇到一些未知的问题，尝试拆除环境，清除所有资源后重试：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./unstack.sh</span><br><span class="line">./clean.sh</span><br><span class="line">./stack.sh</span><br></pre></td></tr></table></figure><h2 id="镜像创建"><a href="#镜像创建" class="headerlink" title="镜像创建"></a>镜像创建</h2><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openstack image create --public --disk-format qcow2 --container-format bare --file xenial-server-cloudimg-amd64-disk1.img ubuntu-xenial-server-amd64</span><br></pre></td></tr></table></figure><h2 id="实例创建"><a href="#实例创建" class="headerlink" title="实例创建"></a>实例创建</h2><p>首先进行 admin 认证鉴权：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo su - stack</span><br><span class="line"><span class="hljs-built_in">cd</span> /opt/stack/devstack</span><br><span class="line"><span class="hljs-built_in">source</span> openrc</span><br></pre></td></tr></table></figure><p>创建安全组规则，允许 ping 和 ssh：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openstack security group rule create --proto icmp default</span><br><span class="line">openstack security group rule create --proto tcp --dst-port 22 default</span><br></pre></td></tr></table></figure><p>创建测试实例：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openstack server create --flavor m1.tiny \</span><br><span class="line">--image $(openstack image list | grep cirros | cut -f3 -d <span class="hljs-string">'|'</span>) \</span><br><span class="line">--nic net-id=$(openstack network list | grep private | cut -f2 -d <span class="hljs-string">'|'</span> | tr -d <span class="hljs-string">' '</span>) \</span><br><span class="line">--security-group default vm</span><br></pre></td></tr></table></figure><p>创建 floating IP：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openstack floating ip create public</span><br></pre></td></tr></table></figure><p>将 floating IP 与实例绑定：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openstack server add floating ip vm 10.20.102.238</span><br></pre></td></tr></table></figure><p>就可以通过 floating IP 登录 vm 实例了，用户名密码是：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cirros</span><br><span class="line">cubswin:)</span><br></pre></td></tr></table></figure><p>vm 如果需要上外网，需要配置 nat。在物理机上执行：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#ifconfig br-ex 10.20.102.223/27</span></span><br><span class="line">iptables -t nat -I POSTROUTING -s 10.20.102.223/27 -j MASQUERADE</span><br><span class="line">iptables -I FORWARD -s 10.20.102.223/27 -j ACCEPT</span><br><span class="line">iptables -I FORWARD -d 10.20.102.223/27 -j ACCEPT</span><br></pre></td></tr></table></figure><h2 id="配置卷类型"><a href="#配置卷类型" class="headerlink" title="配置卷类型"></a>配置卷类型</h2><p>创建 pv 和 vg：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pvcreate /dev/sdb1</span><br><span class="line">vgcreate stack-volumes-hdd /dev/sdb1</span><br></pre></td></tr></table></figure><p>配置 cinder：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/cinder/cinder.conf</span><br></pre></td></tr></table></figure><figure class="highlight ini hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">[DEFAULT]</span></span><br><span class="line"><span class="hljs-attr">default_volume_type</span> = hdd</span><br><span class="line"><span class="hljs-attr">enabled_backends</span> = hdd,ssd</span><br><span class="line"></span><br><span class="line"><span class="hljs-section">[hdd]</span></span><br><span class="line"><span class="hljs-attr">image_volume_cache_enabled</span> = <span class="hljs-literal">True</span></span><br><span class="line"><span class="hljs-attr">volume_clear</span> = zero</span><br><span class="line"><span class="hljs-attr">lvm_type</span> = auto</span><br><span class="line"><span class="hljs-attr">target_helper</span> = tgtadm</span><br><span class="line"><span class="hljs-attr">volume_group</span> = stack-volumes-hdd</span><br><span class="line"><span class="hljs-attr">volume_driver</span> = cinder.volume.drivers.lvm.LVMVolumeDriver</span><br><span class="line"><span class="hljs-attr">volume_backend_name</span> = hdd</span><br></pre></td></tr></table></figure><p>重启 openstack：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart devstack@*</span><br></pre></td></tr></table></figure><p>创建卷类型：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openstack volume <span class="hljs-built_in">type</span> create hdd</span><br><span class="line">openstack volume <span class="hljs-built_in">type</span> <span class="hljs-built_in">set</span> hdd --property volume_backend_name=hdd</span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="volume-无法创建"><a href="#volume-无法创建" class="headerlink" title="volume 无法创建"></a>volume 无法创建</h3><ul><li>排查</li></ul><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo journalctl -f --unit devstack@c-vol</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mar 06 14:59:18 kirk-system cinder-volume[27813]: ERROR oslo_service.service [None req-e1391562-6252-4b98-ba3a-6420edbafffe None None] Error starting thread.: DetachedInstanceError: Parent instance &lt;VolumeAttachment at 0x7f6455ffee90&gt; is not bound to a Session; lazy load operation of attribute &apos;volume&apos; cannot proceed (Background on this error at: http://sqlalche.me/e/bhk3)</span><br></pre></td></tr></table></figure><ul><li>解决</li></ul><p><a href="https://ask.openstack.org/en/question/103315/cinder-volume-attached-to-a-terminated-server-now-i-cant-delete-it/" target="_blank" rel="noopener">https://ask.openstack.org/en/question/103315/cinder-volume-attached-to-a-terminated-server-now-i-cant-delete-it/</a></p><h3 id="ubuntu-18-04-切换到-etc-network-interface"><a href="#ubuntu-18-04-切换到-etc-network-interface" class="headerlink" title="ubuntu 18.04 切换到 /etc/network/interface"></a>ubuntu 18.04 切换到 /etc/network/interface</h3><p><a href="https://askubuntu.com/questions/1031709/ubuntu-18-04-switch-back-to-etc-network-interfaces" target="_blank" rel="noopener">https://askubuntu.com/questions/1031709/ubuntu-18-04-switch-back-to-etc-network-interfaces</a></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><p>golang SDK：<a href="http://gophercloud.io/docs/compute/#servers" target="_blank" rel="noopener">http://gophercloud.io/docs/compute/#servers</a></p></li><li><p>terraform：<a href="https://www.terraform.io/docs/providers/openstack/" target="_blank" rel="noopener">https://www.terraform.io/docs/providers/openstack/</a></p></li><li><p>获取 Openstack 镜像：<a href="https://docs.openstack.org/image-guide/obtain-images.html" target="_blank" rel="noopener">https://docs.openstack.org/image-guide/obtain-images.html</a></p></li><li><p>使用 systemd 管理 devstack：<a href="https://docs.openstack.org/devstack/rocky/systemd.html" target="_blank" rel="noopener">https://docs.openstack.org/devstack/rocky/systemd.html</a></p></li><li><p>devstack networking：</p><ul><li><a href="https://docs.openstack.org/devstack/rocky/networking.html" target="_blank" rel="noopener">https://docs.openstack.org/devstack/rocky/networking.html</a></li><li><a href="https://wiki.openstack.org/wiki/OpsGuide-Network-Troubleshooting" target="_blank" rel="noopener">https://wiki.openstack.org/wiki/OpsGuide-Network-Troubleshooting</a></li></ul></li><li><p>neutron 相关：</p><ul><li><a href="https://docs.openstack.org/devstack/rocky/guides/neutron.html" target="_blank" rel="noopener">https://docs.openstack.org/devstack/rocky/guides/neutron.html</a></li><li><a href="https://www.ibm.com/developerworks/cn/cloud/library/1402_chenhy_openstacknetwork/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/cloud/library/1402_chenhy_openstacknetwork/</a></li></ul></li></ul><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>neutron+vlan 模式配置：</p><figure class="highlight ini hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">[[local|localrc]]</span></span><br><span class="line"><span class="hljs-attr">HOST_IP</span>=<span class="hljs-number">10.20</span>.<span class="hljs-number">102.37</span></span><br><span class="line"><span class="hljs-attr">PUBLIC_INTERFACE</span>=bond1</span><br><span class="line"><span class="hljs-attr">LOGFILE</span>=/opt/stack/logs/stack.sh.log</span><br><span class="line"><span class="hljs-attr">ADMIN_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">DATABASE_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">RABBIT_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">SERVICE_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">LIBVIRT_TYPE</span>=kvm</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">## Neutron options</span></span><br><span class="line"><span class="hljs-attr">IP_VERSION</span>=<span class="hljs-number">4</span></span><br><span class="line"><span class="hljs-attr">Q_USE_SECGROUP</span>=<span class="hljs-literal">True</span></span><br><span class="line"><span class="hljs-attr">ENABLE_TENANT_VLANS</span>=<span class="hljs-literal">True</span></span><br><span class="line"><span class="hljs-attr">TENANT_VLAN_RANGE</span>=<span class="hljs-number">3001</span>:<span class="hljs-number">4000</span></span><br><span class="line"><span class="hljs-attr">PHYSICAL_NETWORK</span>=default</span><br><span class="line"><span class="hljs-attr">OVS_PHYSICAL_BRIDGE</span>=br-ex</span><br><span class="line"><span class="hljs-attr">Q_USE_PROVIDER_NETWORKING</span>=<span class="hljs-literal">True</span></span><br><span class="line">disable_service q-l3</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">## Neutron Networking options used to create Neutron Subnets</span></span><br><span class="line"><span class="hljs-attr">IPV4_ADDRS_SAFE_TO_USE</span>=<span class="hljs-string">"203.0.113.0/24"</span></span><br><span class="line"><span class="hljs-attr">NETWORK_GATEWAY</span>=<span class="hljs-number">203.0</span>.<span class="hljs-number">113.1</span></span><br><span class="line"><span class="hljs-attr">PROVIDER_SUBNET_NAME</span>=<span class="hljs-string">"provider_net"</span></span><br><span class="line"><span class="hljs-attr">PROVIDER_NETWORK_TYPE</span>=<span class="hljs-string">"vlan"</span></span><br><span class="line"><span class="hljs-attr">SEGMENTATION_ID</span>=<span class="hljs-number">2010</span></span><br><span class="line"><span class="hljs-attr">USE_SUBNETPOOL</span>=<span class="hljs-literal">False</span></span><br></pre></td></tr></table></figure><figure class="highlight ini hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">[[local|localrc]]</span></span><br><span class="line"><span class="hljs-attr">HOST_IP</span>=<span class="hljs-number">10.20</span>.<span class="hljs-number">102.38</span> # change this per compute node</span><br><span class="line"><span class="hljs-attr">LOGFILE</span>=/opt/stack/logs/stack.sh.log</span><br><span class="line"><span class="hljs-attr">ADMIN_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">DATABASE_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">RABBIT_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">SERVICE_PASSWORD</span>=</span><br><span class="line"><span class="hljs-attr">DATABASE_TYPE</span>=mysql</span><br><span class="line"><span class="hljs-attr">SERVICE_HOST</span>=<span class="hljs-number">10.20</span>.<span class="hljs-number">102.37</span></span><br><span class="line"><span class="hljs-attr">MYSQL_HOST</span>=<span class="hljs-variable">$SERVICE_HOST</span></span><br><span class="line"><span class="hljs-attr">RABBIT_HOST</span>=<span class="hljs-variable">$SERVICE_HOST</span></span><br><span class="line"><span class="hljs-attr">GLANCE_HOSTPORT</span>=<span class="hljs-variable">$SERVICE_HOST</span>:<span class="hljs-number">9292</span></span><br><span class="line"><span class="hljs-attr">ENABLED_SERVICES</span>=n-cpu,q-agt,n-api-meta,c-vol,placement-client</span><br><span class="line"><span class="hljs-attr">NOVA_VNC_ENABLED</span>=<span class="hljs-literal">True</span></span><br><span class="line"><span class="hljs-attr">NOVNCPROXY_URL</span>=<span class="hljs-string">"http://$SERVICE_HOST:6080/vnc_auto.html"</span></span><br><span class="line"><span class="hljs-attr">VNCSERVER_LISTEN</span>=<span class="hljs-variable">$HOST_IP</span></span><br><span class="line"><span class="hljs-attr">VNCSERVER_PROXYCLIENT_ADDRESS</span>=<span class="hljs-variable">$VNCSERVER_LISTEN</span></span><br><span class="line"><span class="hljs-attr">LIBVIRT_TYPE</span>=kvm</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Services that a compute node runs</span></span><br><span class="line"><span class="hljs-attr">ENABLED_SERVICES</span>=n-cpu,rabbit,q-agt</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">## Open vSwitch provider networking options</span></span><br><span class="line"><span class="hljs-attr">IP_VERSION</span>=<span class="hljs-number">4</span></span><br><span class="line"><span class="hljs-attr">PHYSICAL_NETWORK</span>=default</span><br><span class="line"><span class="hljs-attr">OVS_PHYSICAL_BRIDGE</span>=br-ex</span><br><span class="line"><span class="hljs-attr">PUBLIC_INTERFACE</span>=bond1</span><br><span class="line"><span class="hljs-attr">Q_USE_PROVIDER_NETWORKING</span>=<span class="hljs-literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h2&gt;&lt;p&gt;多节点搭建步骤：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://docs.openstack.org/devstack/rocky/guides/multinode-lab.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.openstack.org/devstack/rocky/guides/multinode-lab.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;要配置 kvm，否则使用默认的 qemu 跑 vm 性能会很差：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://docs.openstack.org/devstack/rocky/guides/devstack-with-nested-kvm.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.openstack.org/devstack/rocky/guides/devstack-with-nested-kvm.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="云计算" scheme="http://whypro.github.io/hexo-blog/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Openstack" scheme="http://whypro.github.io/hexo-blog/tags/Openstack/"/>
    
  </entry>
  
  <entry>
    <title>PLEG unhealthy 导致节点状态不断在 Ready/NotReady 之间切换问题</title>
    <link href="http://whypro.github.io/hexo-blog/20181127/PLEG-unhealthy-%E5%AF%BC%E8%87%B4%E8%8A%82%E7%82%B9%E7%8A%B6%E6%80%81%E4%B8%8D%E6%96%AD%E5%9C%A8-Ready-NotReady-%E4%B9%8B%E9%97%B4%E5%88%87%E6%8D%A2%E9%97%AE%E9%A2%98/"/>
    <id>http://whypro.github.io/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/</id>
    <published>2018-11-27T07:53:30.000Z</published>
    <updated>2019-06-02T09:10:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><ol><li>收到告警提示 PLEG 延时升高（240s）</li></ol><a id="more"></a> <img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/1.png"> <img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/2.png"><ol start="2"><li>节点状态在 Ready 和 NotReady 之间频繁切换</li></ol><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/3.png"> <img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/4.png"><ol start="3"><li>有 pod 处于 Terminating 状态</li></ol><h2 id="排查和原因分析"><a href="#排查和原因分析" class="headerlink" title="排查和原因分析"></a>排查和原因分析</h2><p>查看 kubelet PLEG 相关日志，发现大量 PLEG 超时日志：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Nov 27 10:10:07 xq68 kubelet[24562]: E1127 10:10:07.444787   24562 generic.go:271] PLEG: pod apiserver-inspection-workers-ds-1542964416453270535-6vhmt/qiniu-ranger failed reinspection: rpc error: code = DeadlineExceeded desc = context deadline exceeded</span><br><span class="line">Nov 27 10:14:08 xq68 kubelet[24562]: E1127 10:14:08.502149   24562 generic.go:271] PLEG: pod apiserver-inspection-workers-ds-1542964416453270535-6vhmt/qiniu-ranger failed reinspection: rpc error: code = DeadlineExceeded desc = context deadline exceeded</span><br><span class="line">Nov 27 10:18:09 xq68 kubelet[24562]: E1127 10:18:09.555935   24562 generic.go:271] PLEG: pod apiserver-inspection-workers-ds-1542964416453270535-6vhmt/qiniu-ranger failed reinspection: rpc error: code = DeadlineExceeded desc = context deadline exceeded</span><br><span class="line">Nov 27 10:22:10 xq68 kubelet[24562]: E1127 10:22:10.838479   24562 generic.go:271] PLEG: pod apiserver-inspection-workers-ds-1542964416453270535-6vhmt/qiniu-ranger failed reinspection: rpc error: code = DeadlineExceeded desc = context deadline exceeded</span><br><span class="line">Nov 27 10:26:11 xq68 kubelet[24562]: E1127 10:26:11.878116   24562 generic.go:271] PLEG: pod apiserver-inspection-workers-ds-1542964416453270535-6vhmt/qiniu-ranger failed reinspection: rpc error: code = DeadlineExceeded desc = context deadline exceeded</span><br><span class="line">Nov 27 10:30:12 xq68 kubelet[24562]: E1127 10:30:12.928984   24562 generic.go:271] PLEG: pod apiserver-inspection-workers-ds-1542964416453270535-6vhmt/qiniu-ranger failed reinspection: rpc error: code = DeadlineExceeded desc = context deadline exceeded</span><br><span class="line">Nov 27 10:34:13 xq68 kubelet[24562]: E1127 10:34:13.993793   24562 generic.go:271] PLEG: pod apiserver-inspection-workers-ds-1542964416453270535-6vhmt/qiniu-ranger failed reinspection: rpc error: code = DeadlineExceeded desc = context deadline exceeded</span><br></pre></td></tr></table></figure><p>PLEG (Pod Lifecycle Event Generator) 是 kubelet 定期检查节点上每个 pod 状态的逻辑，它内部缓存了节点所有 pod 的状态，每次通过 relist 时从 container runtime (dockerd) 获取 pod (也就是 pod 包含的所有 container) 的最新状态，然后和当前缓存比较，产生 <code>PodLifecycleEvent</code>。然后遍历所有的 events，更新 pod 状态缓存后将该 event 发送至 event channel。部分代码如下：</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/5.png"><p>而问题就出在更新 Pod 缓存的逻辑，首先 PLEG 更新缓存是串行的，也就是前一个 Pod 执行成功了，后一个 Pod 才能开始；其次，更新缓存会调用 container runtime 的 <code>GetPodStatus</code> 接口来获取 Pod 状态（通过 rpc 获取容器状态和 Pod IP）；而 rpc 调用是阻塞的，默认 120s (2min) 超时；PLEG 只要发现两次 relist 间隔超过 3min，就会认为 PLEG unhealthy，将节点设为 NotReady。</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/6.png"> <img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/7.png"><p>上面的 <code>GetPodStatus</code> 中有调用 cri 的 rpc 接口 PodSandboxStatus 和 <code>ListContainers</code>/<code>ContainerStatus</code> 分别获取 pause 容器和其他容器的状态。</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/8.png"><p>其中 ListContainers/ContainerStatus 里只会从 docker daemon 获取容器信息，而 PodSandboxStatus 不仅会从 docker daemon 获取 pause 容器信息，还会从 CNI 通过 GetPodNetworkStatus 接口获取 pod ip。这几个请求都是 grpc 请求，且超时时间都是 2min，如果中间因为各种原因 hang 住，会阻塞 2min 才能超时返回。</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/9.png"> <img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/10.png"> <img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/11.png"><p>简单整理了整个调用逻辑如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">         grpc       http           grpc</span><br><span class="line">kubelet &lt;----&gt; cri &lt;----&gt; dockerd &lt;----&gt; containerd</span><br><span class="line">                   &lt;----&gt;   cni   &lt;----&gt; network plugin      </span><br><span class="line">                    grpc          command</span><br></pre></td></tr></table></figure><p>同时由上面代码分析，PLEG 超时的原因，就是在更新某个 Pod 状态时，kubelet 通过 rpc 调用 docker daemon 或者 network plugin 时超时了。</p><p><strong>调用 docker daemon 超时的原因有：</strong></p><p>docker daemon hang 住。</p><p><strong>调用 network plugin 超时的原因有：</strong></p><p>network plugin 是利用 command exec 方式调用的， 因为各种原因进程不退出，会导致调用 hang 住。</p><p>调用 network plugin 还有个细节，就是每次调用前会按照 pod 加锁，<strong>所以只要一次调用 hang 住，后面的调用都会 hang 住，等待锁释放</strong>。</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/12.png"><p>但是为什么对一个 Pod 调用 GetPodStatus 时 grpc 超时会导致 PLEG unhealthy 呢？我们先看看两个逻辑：</p><p>一是 relist 时的 updateCache 逻辑：</p><p>PLEG 每次 relist 时不仅要对当前状态有更新的 Pod 进行一次状态获取，还要对上次获取失败的 Pod 重新执行一次状态获取。也就是说，如果一个 grpc 请求的超时是 2min，那么假设一个 Pod 有问题，会将单次 relist 耗时放大至 4min。</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/13.png"><p>二是 PLEG healthy check 逻辑：</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/14.png"> <img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/15.png"><p>Runtime Health Checker 会定时调用 PLEG 的 Healty 函数对 PLEG 执行状态进行检测，从而判断节点的健康状况。每次检测时，只要判断距离上次执行完 relist 的时间大于 3 分钟，上层逻辑就会认为节点不健康了，便会根据结果将节点设置为 NotReady。</p><p>现在的场景是 PLEG relist 会执行，但是每次执行对于有问题的 Pod 要执行两次 updateCache/GetPodStatus，也就是等两次超时需要 4min 时间。Runtime Healthy Checker 每隔 100ms ~ 5s 执行一次，因此在 4min 内，前 3min 的 health check 是成功的，成功之后会将节点标记为 Ready，而 3min 后的 1min 内 healthy check 会失败，kubelet 又会将节点标记为 NotReady。</p><p>这个也能从监控图像上得到证实，如下图，ready status == 1 的间隔是 3min，ready status == 0 的间隔是 1min。</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/16.png"><p>接下来我们一步步确认是哪个组件出了问题导致的：</p><p>确认 docker daemon 状态，看状态获取接口是否正常：</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --unix-socket /var/run/docker.sock http:/containers/40cddec6426e280b8e42a07ca5c8711d18557f3163c2541efd39462ccba10e39/json</span><br></pre></td></tr></table></figure><p>结果正常返回。</p><p>再查看网络组件进程状态，发现 nuke 和 nuke-ipam 两个进程从 2018-11-23 启动后一直没有退出（今天是 2018-11-27）。正常情况下，nuke 和 nkue-ipam 只在 kubelet 通过 cni 调用时执行，执行成功后会立即退出，而现在没有退出是个异常。因此判断问题可能出在 nuke 组件上。</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@xq68:~<span class="hljs-comment"># ps aux | grep nuke</span></span><br><span class="line">root     21122  3.3  0.0  40064 38164 ?        Ssl  Nov19 390:35 /nuke/nukedaemon</span><br><span class="line">root     22814  0.0  0.0 116436  8528 ?        Sl   Nov23   0:00 /opt/cni/bin/nuke</span><br><span class="line">root     22831  0.0  0.0 115204  8192 ?        Sl   Nov23   0:00 /opt/cni/bin/nuke-ipam</span><br><span class="line">root     24012  0.0  0.0  14224  1032 pts/32   S+   10:24   0:00 grep --color=auto nuke</span><br><span class="line">root     29315  0.0  0.0   1560   960 ?        Ss   Jul27   0:00 sh /app/install-nuke-cni.sh</span><br><span class="line">root     31448  0.0  0.0  28280 23696 ?        Ssl  Nov01  28:36 /bin/nuke-l3-agent</span><br></pre></td></tr></table></figure><p>之前出现同样的问题时，为方便排查，我保存了 nuke 相关的 stack 信息，具体原因还需要网络组协助排查。</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/17.png"><p>另外，如果网络方案为 calico，calico 进程 Z 住也会导致该问题：</p><img src="/hexo-blog/20181127/PLEG-unhealthy-导致节点状态不断在-Ready-NotReady-之间切换问题/18.png"><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>解决方式有：（选一种即可）</p><ol><li><p>删除问题容器（一般都是 pause 容器）</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a | grep apiserver-inspection-workers-ds-1542964416453270535-6vhmt</span><br><span class="line">docker rm -f &lt;container_id&gt;</span><br></pre></td></tr></table></figure><p>删除后 kubelet 已经找不到这个容器，会认为 sandbox 已经 stop 成功，就不会再继续执行 PodSandBoxStatus 调用 cri 和 cni，从而就不会触发有问题的逻辑了。</p></li><li><p>重启 kubelet（待验证）</p></li><li><p>对于 neutron 网络方案，手动 kill 掉 hang 住的 nuke 和 nuke-ipam，network plugin 强行返回错误，kubelet 会继续执行后续逻辑。</p></li></ol><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><h3 id="优化-kubelet-PLEG-逻辑"><a href="#优化-kubelet-PLEG-逻辑" class="headerlink" title="优化 kubelet PLEG 逻辑"></a>优化 kubelet PLEG 逻辑</h3><ul><li>考虑并行执行，一个 Pod 有问题时不影响整个 PLEG relist 耗时；</li><li>缩小 rpc 超时时间（目前 2min），对于正常场景来说，调用 cri 和 cni 都用不了这么长的时间。缩小超时可以减小单个 Pod 超时对 PLEG 整体的影响；</li><li>优化 updateCache 逻辑，保证每次 relist 对同一个 Pod 只进行一次状态获取。</li></ul><h3 id="修复-network-plugin"><a href="#修复-network-plugin" class="headerlink" title="修复 network plugin"></a>修复 network plugin</h3><p>寻找 network plugin hang 住的原因并修复。</p><h3 id="优化监控告警"><a href="#优化监控告警" class="headerlink" title="优化监控告警"></a>优化监控告警</h3><ul><li>pleg latency &gt; 240s for 15min -&gt; error 短信、slack 告知</li><li>pleg latency &gt; 240s -&gt; warning slack 告知</li></ul><h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><p><a href="https://github.com/kubernetes/kubernetes/issues/45419" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/issues/45419</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;收到告警提示 PLEG 延时升高（240s）&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="云计算" scheme="http://whypro.github.io/hexo-blog/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Kubernetes" scheme="http://whypro.github.io/hexo-blog/tags/Kubernetes/"/>
    
      <category term="K8S" scheme="http://whypro.github.io/hexo-blog/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>HTC 刷机备忘</title>
    <link href="http://whypro.github.io/hexo-blog/20181020/HTC-%E5%88%B7%E6%9C%BA%E5%A4%87%E5%BF%98/"/>
    <id>http://whypro.github.io/hexo-blog/20181020/HTC-刷机备忘/</id>
    <published>2018-10-20T11:10:26.000Z</published>
    <updated>2019-06-02T09:10:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者对 HTC 手机有着深厚的感情，从 HTC G2 到 HTC M8，经历了 HTC 的鼎盛和衰落。本文记录了一些常用的刷机方法和 hack 命令，以作备忘。</p><h2 id="官方-Unlock-ReLock-方法"><a href="#官方-Unlock-ReLock-方法" class="headerlink" title="官方 Unlock/ReLock 方法"></a>官方 Unlock/ReLock 方法</h2><h3 id="Unlock"><a href="#Unlock" class="headerlink" title="Unlock"></a>Unlock</h3><h4 id="获取解锁-token"><a href="#获取解锁-token" class="headerlink" title="获取解锁 token"></a>获取解锁 token</h4><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot oem get_identifier_token</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt; Identifier Token Start &gt;&gt;&gt;&gt;</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br><span class="line">&lt;&lt;&lt;&lt;&lt; Identifier Token End &gt;&gt;&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="获取解锁码"><a href="#获取解锁码" class="headerlink" title="获取解锁码"></a>获取解锁码</h4><p>前往 <a href="http://www.htcdev.com/bootloader" target="_blank" rel="noopener">http://www.htcdev.com/bootloader</a> 获取官方解锁码。</p><h4 id="刷入解锁码"><a href="#刷入解锁码" class="headerlink" title="刷入解锁码"></a>刷入解锁码</h4><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot flash unlocktoken Unlock_code.bin</span><br></pre></td></tr></table></figure><h3 id="Relock"><a href="#Relock" class="headerlink" title="Relock"></a>Relock</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot oem lock</span><br></pre></td></tr></table></figure><h2 id="刷入-Recovery-方法"><a href="#刷入-Recovery-方法" class="headerlink" title="刷入 Recovery 方法"></a>刷入 Recovery 方法</h2><h3 id="常规方法"><a href="#常规方法" class="headerlink" title="常规方法"></a>常规方法</h3><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb reboot bootloader</span><br><span class="line">fastboot flash recovery recovery.img</span><br></pre></td></tr></table></figure><p>重启后进入 recovery 界面</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fastboot reboot</span><br><span class="line">adb reboot recovery</span><br></pre></td></tr></table></figure><p>或者可以在 fastboot 界面直接进入 recovery</p><h3 id="在-S-OFF-LOCKED-状态下刷入第三方-Recovery-的方法"><a href="#在-S-OFF-LOCKED-状态下刷入第三方-Recovery-的方法" class="headerlink" title="在 S-OFF + LOCKED 状态下刷入第三方 Recovery 的方法"></a>在 S-OFF + LOCKED 状态下刷入第三方 Recovery 的方法</h3><h4 id="准备-ZIP-文件"><a href="#准备-ZIP-文件" class="headerlink" title="准备 ZIP 文件"></a>准备 ZIP 文件</h4><p>在 S-OFF + LOCKED 情况下通过 adb 工具线刷时，所用的 <code>recovery.zip</code> 包里必须包括 <code>android-info.txt</code> 和 <code>recovery.img</code>。而这个 <code>android-info.txt</code> 的内容必须符合你的手机信息，以我的 Sprint 版为例，其内容是：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">modelid: PN0720000</span><br><span class="line">cidnum: 11111111</span><br><span class="line">mainver: 5.03.651.3</span><br><span class="line">btype:1</span><br><span class="line">aareport:1</span><br><span class="line">DelCache:1</span><br><span class="line">hbootpreupdate:3</span><br></pre></td></tr></table></figure><p>查询以上信息的方法为：在 adb 中输入 <code>fastboot getvar all</code> 即可看到，然后将所需的 <code>modelid</code>、<code>cidnum</code>、<code>mainver</code> 信息修改到 <code>android-info.txt</code> 文件中。</p><p><code>android-info.txt</code> 文件可以从官方 RUU 中提取，然后把上面查询到的信息替换到里面即可。</p><p>最后将 <code>recovery.img</code> 和 <code>android-info.txt</code> 一起打包到 zip 压缩包中，并放入 adb 工具的文件夹里即可开始下面步骤了。</p><p>（刷 radio 也是同理，必须在 zip 压缩包中加入 <code>android-info.txt</code>。）</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb reboot bootloader</span><br><span class="line">fastboot oem rebootRUU</span><br><span class="line">fastboot flash zip recovery.zip</span><br></pre></td></tr></table></figure><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot reboot</span><br></pre></td></tr></table></figure><h2 id="BootLoader-状态随意修改（需要-S-OFF）"><a href="#BootLoader-状态随意修改（需要-S-OFF）" class="headerlink" title="BootLoader 状态随意修改（需要 S-OFF）"></a>BootLoader 状态随意修改（需要 S-OFF）</h2><h3 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h3><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="hljs-keyword">if</span>=/dev/block/mmcblk0p3 bs=1 skip=33796 count=4</span><br></pre></td></tr></table></figure><h3 id="LOCK"><a href="#LOCK" class="headerlink" title="LOCK"></a>LOCK</h3><p>to LOCK your bootloader,enter the following:</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br><span class="line"></span><br><span class="line">adb shell</span><br><span class="line"></span><br><span class="line">su (<span class="hljs-keyword">if</span> needed to get a <span class="hljs-comment"># prompt)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># (i would very strongly recomend you copy/paste this)</span></span><br><span class="line"><span class="hljs-built_in">echo</span> -ne <span class="hljs-string">'\x00\x00\x00\x00'</span> | dd of=/dev/block/mmcblk0p3 bs=1 seek=33796</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># (exit a second time if you need to to get back to a normal &gt; prompt)</span></span><br><span class="line"><span class="hljs-built_in">exit</span></span><br><span class="line"></span><br><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure><p>verify you are now locked</p><h3 id="UNLOCK"><a href="#UNLOCK" class="headerlink" title="UNLOCK"></a>UNLOCK</h3><p>to UNLOCK your bootloader,enter the following:</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br><span class="line"></span><br><span class="line">adb shell</span><br><span class="line"></span><br><span class="line">su (<span class="hljs-keyword">if</span> needed to get a <span class="hljs-comment"># prompt)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># (i would very strongly recomend you copy/paste this)</span></span><br><span class="line"><span class="hljs-built_in">echo</span> -ne <span class="hljs-string">"HTCU"</span> | dd of=/dev/block/mmcblk0p3 bs=1 seek=33796</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># (exit a second time if you need to to get back to a normal &gt; prompt)</span></span><br><span class="line"><span class="hljs-built_in">exit</span></span><br><span class="line"></span><br><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure><p>verify you are now unlocked</p><h3 id="RELOCK"><a href="#RELOCK" class="headerlink" title="RELOCK"></a>RELOCK</h3><p>to RELOCK your bootloader,enter the following:</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br><span class="line"></span><br><span class="line">adb shell</span><br><span class="line"></span><br><span class="line">su (<span class="hljs-keyword">if</span> needed to get a <span class="hljs-comment"># prompt)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># (i would very strongly recomend you copy/paste this)</span></span><br><span class="line"><span class="hljs-built_in">echo</span> -ne <span class="hljs-string">"HTCL"</span> | dd of=/dev/block/mmcblk0p3 bs=1 seek=33796</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># (exit a second time if you need to to get back to a normal &gt; prompt)</span></span><br><span class="line"><span class="hljs-built_in">exit</span></span><br><span class="line"></span><br><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure><p>verify you are now relocked</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://bbs.gfan.com/android-7235658-1-1.html" target="_blank" rel="noopener">http://bbs.gfan.com/android-7235658-1-1.html</a></p><p><a href="https://androidforums.com/threads/how-to-lock-unlock-your-bootloader-without-htcdev-s-off-required.916138/" target="_blank" rel="noopener">https://androidforums.com/threads/how-to-lock-unlock-your-bootloader-without-htcdev-s-off-required.916138/</a></p><h2 id="HTC-测试指令"><a href="#HTC-测试指令" class="headerlink" title="HTC 测试指令"></a>HTC 测试指令</h2><p>测试指令：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*#*#3424#*#*</span><br></pre></td></tr></table></figure><p>工程模式</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*#*#4636#*#*</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者对 HTC 手机有着深厚的感情，从 HTC G2 到 HTC M8，经历了 HTC 的鼎盛和衰落。本文记录了一些常用的刷机方法和 hack 命令，以作备忘。&lt;/p&gt;&lt;h2 id=&quot;官方-Unlock-ReLock-方法&quot;&gt;&lt;a href=&quot;#官方-Unlock-ReLock-方法&quot; class=&quot;headerlink&quot; title=&quot;官方 Unlock/ReLock 方法&quot;&gt;&lt;/a&gt;官方 Unlock/ReLock 方法&lt;/h2&gt;&lt;h3 id=&quot;Unlock&quot;&gt;&lt;a href=&quot;#Unlock&quot; class=&quot;headerlink&quot; title=&quot;Unlock&quot;&gt;&lt;/a&gt;Unlock&lt;/h3&gt;&lt;h4 id=&quot;获取解锁-token&quot;&gt;&lt;a href=&quot;#获取解锁-token&quot; class=&quot;headerlink&quot; title=&quot;获取解锁 token&quot;&gt;&lt;/a&gt;获取解锁 token&lt;/h4&gt;&lt;figure class=&quot;highlight sh hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fastboot oem get_identifier_token&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="HTC" scheme="http://whypro.github.io/hexo-blog/tags/HTC/"/>
    
      <category term="刷机" scheme="http://whypro.github.io/hexo-blog/tags/%E5%88%B7%E6%9C%BA/"/>
    
      <category term="Android" scheme="http://whypro.github.io/hexo-blog/tags/Android/"/>
    
      <category term="安卓" scheme="http://whypro.github.io/hexo-blog/tags/%E5%AE%89%E5%8D%93/"/>
    
  </entry>
  
  <entry>
    <title>etcd 集群的备份和还原</title>
    <link href="http://whypro.github.io/hexo-blog/20180725/etcd-%E9%9B%86%E7%BE%A4%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E8%BF%98%E5%8E%9F/"/>
    <id>http://whypro.github.io/hexo-blog/20180725/etcd-集群的备份和还原/</id>
    <published>2018-07-25T08:12:00.000Z</published>
    <updated>2019-06-02T09:10:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>安装 etcdctl</p><p><strong>方法1</strong></p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install etcd-client=3.2.17+dfsg-1</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>方法2</strong></p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">export</span> RELEASE=<span class="hljs-string">"3.2.17"</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">test</span> -d /tmp/etcd &amp;&amp; mkdir -p /tmp/etcd &amp;&amp; <span class="hljs-built_in">cd</span> /tmp/etcd</span><br><span class="line">wget https://github.com/etcd-io/etcd/releases/download/v<span class="hljs-variable">$&#123;RELEASE&#125;</span>/etcd-v<span class="hljs-variable">$&#123;RELEASE&#125;</span>-linux-amd64.tar.gz</span><br><span class="line">tar -zxvf etcd-v<span class="hljs-variable">$&#123;RELEASE&#125;</span>-linux-amd64.tar.gz</span><br><span class="line"><span class="hljs-built_in">cd</span> etcd-v<span class="hljs-variable">$&#123;RELEASE&#125;</span>-linux-amd64</span><br><span class="line">cp etcdctl /usr/<span class="hljs-built_in">local</span>/bin</span><br><span class="line"></span><br><span class="line">etcdctl --version</span><br></pre></td></tr></table></figure><p><strong>方法3</strong></p><p>使用 docker cp 从 etcd 容器中拷贝。</p><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>etcd 的备份有两种方式，选择其一即可。</p><h3 id="方式一：使用-etcdctl-snapshot-命令（推荐）"><a href="#方式一：使用-etcdctl-snapshot-命令（推荐）" class="headerlink" title="方式一：使用 etcdctl snapshot 命令（推荐）"></a>方式一：使用 etcdctl snapshot 命令（推荐）</h3><p>在任何一个 member 节点执行：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl snapshot save snapshot.db</span><br></pre></td></tr></table></figure><h3 id="方式二：拷贝-member-snap-db-文件"><a href="#方式二：拷贝-member-snap-db-文件" class="headerlink" title="方式二：拷贝 member/snap/db 文件"></a>方式二：拷贝 member/snap/db 文件</h3><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /var/lib/etcd/member/snap/db snapshot.db</span><br></pre></td></tr></table></figure><p>如果使用此方法，etcdctl snapshot restore 时需要设置 <code>--skip-hash-check=true</code></p><h2 id="还原"><a href="#还原" class="headerlink" title="还原"></a>还原</h2><h3 id="方式一：单节点还原成功后，再将其他节点加入集群"><a href="#方式一：单节点还原成功后，再将其他节点加入集群" class="headerlink" title="方式一：单节点还原成功后，再将其他节点加入集群"></a>方式一：单节点还原成功后，再将其他节点加入集群</h3><p>根据 snapshot.db 生成新的 data dir：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># restore.sh</span></span><br><span class="line"></span><br><span class="line">rm /var/lib/etcd -rf </span><br><span class="line"> </span><br><span class="line">ETCDCTL_API=3 etcdctl snapshot restore snapshot.db \</span><br><span class="line">  --name k8s-etcd-host1 \</span><br><span class="line">  --data-dir /var/lib/etcd \</span><br><span class="line">  --initial-cluster k8s-etcd-host1=http://host1:2380 \</span><br><span class="line">  --initial-cluster-token k8s-etcd \</span><br><span class="line">  --initial-advertise-peer-urls http://host1:2380 \</span><br><span class="line">  --skip-hash-check=<span class="hljs-literal">false</span></span><br></pre></td></tr></table></figure><p>启动单实例：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">spec:</span></span><br><span class="line"><span class="hljs-attr">  containers:</span></span><br><span class="line"><span class="hljs-attr">  - command:</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-string">etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--name=k8s-etcd-host1</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-advertise-peer-urls=http://host1:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--listen-peer-urls=http://host1:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--listen-client-urls=http://0.0.0.0:2379</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--advertise-client-urls=http://host1:2379</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--data-dir=/var/lib/etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster-token=k8s-etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster=k8s-etcd-host1=http://host1:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster-state=existing</span></span><br></pre></td></tr></table></figure><p>将其他节点依次加入集群（先执行 add 命令再启动实例），add 命令如下：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl member add k8s-etcd-host2 http://host2:2380</span><br></pre></td></tr></table></figure><p>启动实例：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">spec:</span></span><br><span class="line"><span class="hljs-attr">  containers:</span></span><br><span class="line"><span class="hljs-attr">  - command:</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-string">etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--name=k8s-etcd-host2</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-advertise-peer-urls=http://host2:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--listen-peer-urls=http://host2:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--listen-client-urls=http://0.0.0.0:2379</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--advertise-client-urls=http://host2:2379</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--data-dir=/var/lib/etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster-token=k8s-etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster=k8s-etcd-host1=http://host1:2380,k8s-etcd-host2=http://host2:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster-state=existing</span></span><br></pre></td></tr></table></figure><p>其他实例操作方法类似。</p><h3 id="方式二：同时还原多节点集群"><a href="#方式二：同时还原多节点集群" class="headerlink" title="方式二：同时还原多节点集群"></a>方式二：同时还原多节点集群</h3><p>将 snapshot.db 文件拷贝至所有 etcd 节点，根据 snapshot.db 生成 data dir：</p><figure class="highlight sh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl snapshot restore snapshot.db \</span><br><span class="line">  --name k8s-etcd-host1 \</span><br><span class="line">  --data-dir /var/lib/etcd \</span><br><span class="line">  --initial-cluster k8s-etcd-host1=http://host1:2380,k8s-etcd-host2=http://host2:2380,k8s-etcd-host3=http://host3:2380 \</span><br><span class="line">  --initial-cluster-token k8s-etcd \</span><br><span class="line">  --initial-advertise-peer-urls http://host1:2380 \</span><br><span class="line">  --skip-hash-check=<span class="hljs-literal">false</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">ETCDCTL_API=3 etcdctl snapshot restore snapshot.db \</span><br><span class="line">  --name k8s-etcd-host2 \</span><br><span class="line">  --data-dir /var/lib/etcd \</span><br><span class="line">  --initial-cluster k8s-etcd-host1=http://host1:2380,k8s-etcd-host2=http://host2:2380,k8s-etcd-host3=http://host3:2380 \</span><br><span class="line">  --initial-cluster-token k8s-etcd \</span><br><span class="line">  --initial-advertise-peer-urls http://host2:2380 \</span><br><span class="line">  --skip-hash-check=<span class="hljs-literal">false</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">ETCDCTL_API=3 etcdctl snapshot restore snapshot.db \</span><br><span class="line">  --name k8s-etcd-host3 \</span><br><span class="line">  --data-dir /var/lib/etcd \</span><br><span class="line">  --initial-cluster k8s-etcd-host1=http://host1:2380,k8s-etcd-host2=http://host2:2380,k8s-etcd-host3=http://host3:2380 \</span><br><span class="line">  --initial-cluster-token k8s-etcd \</span><br><span class="line">  --initial-advertise-peer-urls http://host3:2380 \</span><br><span class="line">  --skip-hash-check=<span class="hljs-literal">false</span></span><br></pre></td></tr></table></figure><p>还原后启动所有 etcd 实例 。启动参数如下，其他类似：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">spec:</span></span><br><span class="line"><span class="hljs-attr">  containers:</span></span><br><span class="line"><span class="hljs-attr">  - command:</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-string">etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--name=k8s-etcd-host1</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-advertise-peer-urls=http://host1:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--listen-peer-urls=http://host1:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--listen-client-urls=http://0.0.0.0:2379</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--advertise-client-urls=http://host1:2379</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--data-dir=/var/lib/etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster-token=k8s-etcd</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster=k8s-etcd-host1=http://host1:2380,k8s-etcd-host2=http://host2:2380,k8s-etcd-host3=http://host3:2380</span></span><br><span class="line"><span class="hljs-bullet">    -</span> <span class="hljs-bullet">--initial-cluster-state=existing</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>启动 etcd 之前最好停掉 kube-apiserver</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://coreos.com/etcd/docs/3.1.12/op-guide/recovery.html" target="_blank" rel="noopener">https://coreos.com/etcd/docs/3.1.12/op-guide/recovery.html</a></li><li><a href="https://coreos.com/etcd/docs/latest/op-guide/runtime-configuration.html" target="_blank" rel="noopener">https://coreos.com/etcd/docs/latest/op-guide/runtime-configuration.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;p&gt;安装 etcdctl&lt;/p&gt;&lt;p&gt;&lt;strong&gt;方法1&lt;/strong&gt;&lt;/p&gt;&lt;figure class=&quot;highlight sh hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;apt install etcd-client=3.2.17+dfsg-1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="云计算" scheme="http://whypro.github.io/hexo-blog/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Kubernetes" scheme="http://whypro.github.io/hexo-blog/tags/Kubernetes/"/>
    
      <category term="K8S" scheme="http://whypro.github.io/hexo-blog/tags/K8S/"/>
    
      <category term="etcd" scheme="http://whypro.github.io/hexo-blog/tags/etcd/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 容器生命周期管理</title>
    <link href="http://whypro.github.io/hexo-blog/20180404/Kubernetes-%E5%AE%B9%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/"/>
    <id>http://whypro.github.io/hexo-blog/20180404/Kubernetes-容器生命周期管理/</id>
    <published>2018-04-04T08:09:40.000Z</published>
    <updated>2019-06-02T09:10:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="健康检查和就绪检查"><a href="#健康检查和就绪检查" class="headerlink" title="健康检查和就绪检查"></a>健康检查和就绪检查</h2><h3 id="健康检查（Liveness-Probe）"><a href="#健康检查（Liveness-Probe）" class="headerlink" title="健康检查（Liveness Probe）"></a>健康检查（Liveness Probe）</h3><p>如果设置了 <code>livenessProbe</code>，k8s (kubelet) 会每隔 n 秒执行预先配置的行为来检查容器是否健康</p><p>当健康检查失败时，k8s 会认为容器已经挂掉，会根据 <code>restartPolicy</code> 来对容器进行重启或其他操作。</p><p>每次检查有 3 种结果，<code>Success</code>、<code>Failure</code>、<code>Unknown</code></p><p>如果不配置，默认的检查状态为 <code>Success</code></p><a id="more"></a><p><strong>什么时候不需要健康检查</strong>：如果服务在异常后会自动退出或 crash，就不必配置健康检查，k8s 会按照重启策略来自动操作。</p><p><strong>什么时候需要健康检查</strong>：相反，如果服务异常必须由 k8s 主动介入来重启容器，就需要配置健康检查</p><h3 id="就绪检查（Readiness-Probe）"><a href="#就绪检查（Readiness-Probe）" class="headerlink" title="就绪检查（Readiness Probe）"></a>就绪检查（Readiness Probe）</h3><p>如果设置了 <code>readinessProbe</code>，k8s (kubelet) 会每隔 n 秒检查容器对外提供的服务是否正常</p><p>当就绪检查失败时，k8s 会将 Pod 标记为 <code>Unready</code>，将 Pod IP 从 endpoints 中剔除，即不会让之后的流量通过 service 发送过来。</p><p>在首次检查之前，初始状态为 <code>Failure</code></p><p>如果不配置，默认的状态为 <code>Success</code></p><p><strong>什么时候需要就绪检查</strong>：如果在服务启动后、初始化完成之前不想让流量过来，就需要配置就绪检查。</p><p><strong>什么时候不需要就绪检查</strong>：除了上述场景，在 Pod 被删除时，k8s 会主动将 Pod 置为 <code>UnReady</code> 状态，之后的流量也不会过来，因此针对这种情况不必配置就绪检查。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>健康／就绪检查支持以下参数：</p><ul><li><code>initialDelaySeconds</code>: 容器启动后，进行首次检查的等待时间（秒）</li><li><code>periodSeconds</code>: 每次检查的间隔时间（秒）</li><li><code>timeoutSeconds</code>: 执行检查的超时时间（秒），默认值为 1，最小值是 1</li><li><code>successThreshold</code>: 检查失败时，连续成功 n 次后，认为该容器的健康／就绪检查成功。默认值为 1，最小值是 1，对于健康检查必须为 1</li><li><code>failureThreshold</code>: 连续失败 n 次后，认为该容器的健康／就绪检查失败。默认值为 3，最小值是 1</li></ul><h3 id="检查方式"><a href="#检查方式" class="headerlink" title="检查方式"></a>检查方式</h3><h4 id="Exec-方式"><a href="#Exec-方式" class="headerlink" title="Exec 方式"></a>Exec 方式</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">livenessProbe:</span><br><span class="line">  exec:</span><br><span class="line">    command:</span><br><span class="line">    - cat</span><br><span class="line">    - /tmp/healthy</span><br></pre></td></tr></table></figure><h4 id="HTTP-GET-请求方式"><a href="#HTTP-GET-请求方式" class="headerlink" title="HTTP GET 请求方式"></a>HTTP GET 请求方式</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">livenessProbe:</span><br><span class="line">  httpGet:</span><br><span class="line">    path: /healthz</span><br><span class="line">    port: 8080</span><br><span class="line">    httpHeaders:</span><br><span class="line">    - name: X-Custom-Header</span><br><span class="line">      value: Awesome</span><br></pre></td></tr></table></figure><p>支持的参数包括：</p><ul><li><code>host</code>: 目标主机地址，默认值为 pod IP</li><li><code>scheme</code>: HTTP 或 HTTPS，默认为 HTTP</li><li><code>path</code>: 访问路径</li><li><code>httpHeaders</code>: 自定义请求头</li><li><code>port</code>: 目标端口号，有效值 1~65535</li></ul><h4 id="TCP-Socket-方式"><a href="#TCP-Socket-方式" class="headerlink" title="TCP Socket 方式"></a>TCP Socket 方式</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">livenessProbe:</span><br><span class="line">  tcpSocket:</span><br><span class="line">    port: 8080</span><br></pre></td></tr></table></figure><p>支持的参数包括：</p><ul><li><code>host</code>: 目标主机地址，默认值为 pod IP</li><li><code>port</code>: 目标端口号，有效值 1~65535</li></ul><h2 id="容器重启策略"><a href="#容器重启策略" class="headerlink" title="容器重启策略"></a>容器重启策略</h2><p><code>restartPolicy</code> 是 livenessProbe <code>Failure</code> 后执行的策略，作用于 Pod 的每个容器，可以配置为 <code>Always</code>、<code>OnFaiiure</code>、<code>Never</code>，默认值为 <code>Always</code>。</p><p><code>restartPolicy</code> 只会影响本机节点重启容器的策略，并不会影响 Pod 重新调度的行为，重启的方式按照时间间隔（10s, 20s, 40s, …, 5min）来重启容器，并且每 10min 重置间隔时间</p><p>重启策略 <code>restartPolicy</code> 的配置通过以下几个场景来举例说明：</p><ol><li>Pod Running 状态，包含 1 个容器，容器正常退出</li></ol><p>记录 completion 事件</p><ul><li><code>Always</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>OnFaiiure</code>: 不重启容器，Pod phase 变为 <code>Succeeded</code></li><li><code>Never</code>: 不重启容器，Pod phase 变为 <code>Succeeded</code></li></ul><ol start="2"><li>Pod Running 状态，包含 1 个容器，容器异常退出</li></ol><p>记录 failure 事件</p><ul><li><code>Always</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>OnFaiiure</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>Never</code>: 不重启容器，Pod phase 变为 <code>Failed</code></li></ul><ol start="3"><li>Pod Running 状态，包含 2 个容器，其中一个容器异常退出</li></ol><p>记录 failure 事件</p><ul><li><code>Always</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>OnFaiiure</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>Never</code>: 不重启容器，Pod phase 保持 <code>Running</code> 状态</li></ul><p>此时如果第二个容器退出（无论正常还是异常）</p><p>记录 failure 事件</p><ul><li><code>Always</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>OnFaiiure</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>Never</code>: 不重启容器，Pod phase 变为 <code>Failed</code></li></ul><ol start="4"><li>Pod Running 状态，包含 1 个容器，容器被 OOM (out of memory) killed</li></ol><p>记录 OOM 事件</p><ul><li><code>Always</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>OnFaiiure</code>: 重启容器，Pod phase 保持 <code>Running</code> 状态</li><li><code>Never</code>: 不重启容器，Pod phase 变为 <code>Failed</code></li></ul><ol start="5"><li>Pod Running 状态，遇到节点异常（比如磁盘挂掉、segmented out）</li></ol><p>根据异常原因记录相应事件</p><p>无论设置为哪种策略，Pod 状态变为 <code>Failed</code>，并尝试在其他节点重新创建（如果 Pod 是通过 Controller 管理的）</p><h2 id="容器生存周期事件处理"><a href="#容器生存周期事件处理" class="headerlink" title="容器生存周期事件处理"></a>容器生存周期事件处理</h2><p>k8s 在容器创建或终止时会发送 <code>postStart</code> 或 <code>preStop</code> 事件，用户可以通过配置 handler，对这两个容器事件进行处理。</p><p>k8s 在容器创建之后发送 <code>postStart</code> 事件，postStart handler 是异步执行，所以并不保证会在容器的 entrypoint 之前执行，不过容器代码会阻塞住直到 postStart handler 执行完成。执行成功后，容器状态才会设为 <code>Running</code></p><p>k8s 在容器 terminate 之前发送 <code>preStop</code> 事件，terminate 行为会阻塞，直到 preStop handler 同步执行成功或者 Pod 配置的 grace period 超时 (<code>terminationGracePeriodSeconds</code>)。注意：如果不是主动终止，k8s 不会发送 <code>preStop</code> 事件（比如正常退出）。</p><p>如果 postStart 或 preStop handler 执行失败，k8s 直接 kill 掉容器。</p><h3 id="handler-执行方式"><a href="#handler-执行方式" class="headerlink" title="handler 执行方式"></a>handler 执行方式</h3><h4 id="Exec-方式-1"><a href="#Exec-方式-1" class="headerlink" title="Exec 方式"></a>Exec 方式</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lifecycle:</span><br><span class="line">  postStart:</span><br><span class="line">    exec:</span><br><span class="line">      command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo Hello from the postStart handler &gt; /usr/share/message&quot;]</span><br></pre></td></tr></table></figure><h4 id="HTTP-GET-方式"><a href="#HTTP-GET-方式" class="headerlink" title="HTTP GET 方式"></a>HTTP GET 方式</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lifecycle:</span><br><span class="line">  postStart:</span><br><span class="line">    httpGet:</span><br><span class="line">      path: /healthz</span><br><span class="line">      port: 8080</span><br><span class="line">      httpHeaders:</span><br><span class="line">      - name: X-Custom-Header</span><br><span class="line">        value: Awesome</span><br></pre></td></tr></table></figure><h2 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h2><p>livenessProbe 和 readinessProbe 的配置项完全相同，只是检查失败后的行为不同</p><p>lifecycle 的 exec 和 httpGet 和 livenessProbe 对应的配置项相同。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: example</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: example</span><br><span class="line">    // ... </span><br><span class="line">    livenessProbe:</span><br><span class="line">      exec:</span><br><span class="line">        command:</span><br><span class="line">        - cat</span><br><span class="line">        - /tmp/healthy</span><br><span class="line">      initialDelaySeconds: 5</span><br><span class="line">      periodSeconds: 10</span><br><span class="line">    readinessProbe:</span><br><span class="line">      tcpSocket:</span><br><span class="line">        port: 8080</span><br><span class="line">      initialDelaySeconds: 10</span><br><span class="line">      periodSeconds: 10</span><br><span class="line">    lifecycle:</span><br><span class="line">      postStart:</span><br><span class="line">        exec:</span><br><span class="line">          command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo Hello from the postStart handler &gt; /usr/share/message&quot;]</span><br><span class="line">      preStop:</span><br><span class="line">        httpGet:</span><br><span class="line">          host: xxx.xxx.xxx</span><br><span class="line">          path: /stop</span><br><span class="line">          port: 8080</span><br><span class="line">  restartPolicy: OnFailure</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Pod 生命周期：<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/</a></p><p>健康检查和就绪检查：<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/</a></p><p>容器生存周期事件处理：<br><a href="https://kubernetes.io/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/</a><br><a href="https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;健康检查和就绪检查&quot;&gt;&lt;a href=&quot;#健康检查和就绪检查&quot; class=&quot;headerlink&quot; title=&quot;健康检查和就绪检查&quot;&gt;&lt;/a&gt;健康检查和就绪检查&lt;/h2&gt;&lt;h3 id=&quot;健康检查（Liveness-Probe）&quot;&gt;&lt;a href=&quot;#健康检查（Liveness-Probe）&quot; class=&quot;headerlink&quot; title=&quot;健康检查（Liveness Probe）&quot;&gt;&lt;/a&gt;健康检查（Liveness Probe）&lt;/h3&gt;&lt;p&gt;如果设置了 &lt;code&gt;livenessProbe&lt;/code&gt;，k8s (kubelet) 会每隔 n 秒执行预先配置的行为来检查容器是否健康&lt;/p&gt;&lt;p&gt;当健康检查失败时，k8s 会认为容器已经挂掉，会根据 &lt;code&gt;restartPolicy&lt;/code&gt; 来对容器进行重启或其他操作。&lt;/p&gt;&lt;p&gt;每次检查有 3 种结果，&lt;code&gt;Success&lt;/code&gt;、&lt;code&gt;Failure&lt;/code&gt;、&lt;code&gt;Unknown&lt;/code&gt;&lt;/p&gt;&lt;p&gt;如果不配置，默认的检查状态为 &lt;code&gt;Success&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="云计算" scheme="http://whypro.github.io/hexo-blog/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Kubernetes" scheme="http://whypro.github.io/hexo-blog/tags/Kubernetes/"/>
    
      <category term="K8S" scheme="http://whypro.github.io/hexo-blog/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 服务灰度升级最佳实践</title>
    <link href="http://whypro.github.io/hexo-blog/20180301/Kubernetes-%E6%9C%8D%E5%8A%A1%E7%81%B0%E5%BA%A6%E5%8D%87%E7%BA%A7%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://whypro.github.io/hexo-blog/20180301/Kubernetes-服务灰度升级最佳实践/</id>
    <published>2018-03-01T10:10:00.000Z</published>
    <updated>2019-06-02T09:10:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了 Deployment 和 StatefulSet 的升级机制和扩缩容机制，以及一些常用的配置项。并分别介绍了以这两种方式部署 Pod 时的对服务进行升级（包括滚动发布、蓝绿发布、灰度／金丝雀发布）的最佳实践。</p><h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><h3 id="升级机制"><a href="#升级机制" class="headerlink" title="升级机制"></a>升级机制</h3><h4 id="Rollout"><a href="#Rollout" class="headerlink" title="Rollout"></a>Rollout</h4><p>Deployment 的 rollout 在 .spec.template 被修改时触发（比如镜像地址更新、Pod label 更新等等），其他修改（.spec.replicas 更新）不会触发。</p><p>更新时，k8s 通过计算 pod-template-hash，创建新的 ReplicaSet，由新的 rs 启动新的 Pod，不断替换旧 rs 的 Pod。</p><a id="more"></a><p>通过命令</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; rollout status deployment/&lt;deployment-name&gt;</span><br></pre></td></tr></table></figure><p>查看 Deployment rollout 的状态。</p><p><code>.spec.strategy</code> 定义了更新 Pod 的策略：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">minReadySeconds:</span> <span class="hljs-number">5</span></span><br><span class="line"><span class="hljs-attr">strategy:</span></span><br><span class="line"><span class="hljs-attr">  type:</span> <span class="hljs-string">RollingUpdate</span></span><br><span class="line"><span class="hljs-attr">  rollingUpdate:</span></span><br><span class="line"><span class="hljs-attr">    maxSurge:</span> <span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-attr">    maxUnavailable:</span> <span class="hljs-number">1</span></span><br></pre></td></tr></table></figure><ul><li><code>spec.strategy.type</code> 可以为 Recreate 或 RollingUpdate。Recreate 先删掉旧 Pod 再创建新 Pod，RollingUpdate 则按照滚动升级的策略来更新。</li><li><code>maxUnavailable</code>：更新时，Deployment 确保不超过 25%（默认值） 的 Pod 处于 unavailable 状态。既可以是数量也可以是百分比，当 <code>maxSurge</code> 为 <code>0</code> 时 <code>maxUnavailable</code> 不能为 <code>0</code>。</li><li><code>maxSurge</code>：更新时，Deployment 确保当前实际创建的 Pod 数（包括新旧实例总和）不超过期望 Pod 数的 25%（默认值）。既可以是数量也可以是百分比。</li><li><code>minReadySeconds</code>：新创建的 Pod 变为 Ready 状态的最少时间，如果容器在该时间内没有 crash，则认为该 Pod 是 available 的。默认值为 0，表示一旦 readiness probe 通过后就变为 Ready，这时如果没有配置 <code>readinessProbe</code>，则只要 Pod 创建后就会为 Ready 状态，可能会导致服务不可用。</li></ul><h4 id="Rollover"><a href="#Rollover" class="headerlink" title="Rollover"></a>Rollover</h4><p>当 Deployment 在 rollout 过程中被更新时，Deployment 会立即执行新的更新，停止之前的 rollout 动作，并根据期望实例数删除（缩容）之前的 Pod，这个过程叫做 rollover。</p><h4 id="Rollback"><a href="#Rollback" class="headerlink" title="Rollback"></a>Rollback</h4><p>获取 Deployment 的 rollout 历史，最新的 revision 即当前版本</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; rollout history deployment/&lt;deployment-name&gt;</span><br></pre></td></tr></table></figure><p>查看指定 revision 的详细信息</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; rollout history deployment/&lt;deployment-name&gt; --revision=&lt;revision_num&gt;</span><br></pre></td></tr></table></figure><p>回滚到上一个版本</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; rollout undo deployment/&lt;deployment-name&gt;</span><br></pre></td></tr></table></figure><p>回滚到指定版本</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; rollout undo deployment/&lt;deployment-name&gt; --to-revision=&lt;revision_num&gt;</span><br></pre></td></tr></table></figure><p>当 Deployment 回滚成功时，会生成 DeploymentRollback 事件</p><p>可以通过 <code>.spec.revisionHistoryLimit</code> 配置最多保留的 revision 历史个数（不包括当前版本），默认值为 2，即保留 3 个 revision。</p><h4 id="Pause-Resume"><a href="#Pause-Resume" class="headerlink" title="Pause/Resume"></a>Pause/Resume</h4><p>当 Deployment 的 <code>.spec.paused = true</code> 时，任何更新都不会被触发 rollout。通过如下命令设置 Deployment 为 paused：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; rollout pause deployment/&lt;deployment-name&gt;</span><br></pre></td></tr></table></figure><p>还原：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n &lt;namespace&gt; rollout resume deploy/&lt;deployment-name&gt;</span><br></pre></td></tr></table></figure><h3 id="扩缩容机制"><a href="#扩缩容机制" class="headerlink" title="扩缩容机制"></a>扩缩容机制</h3><h4 id="手动扩缩容"><a href="#手动扩缩容" class="headerlink" title="手动扩缩容"></a>手动扩缩容</h4><p>可以通过修改 <code>.spec.replicas</code>，或者执行 kubectl 命令的方式对 Deployment 进行扩缩容：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale deployment nginx-deployment --replicas=10</span><br></pre></td></tr></table></figure><h4 id="自动扩缩容"><a href="#自动扩缩容" class="headerlink" title="自动扩缩容"></a>自动扩缩容</h4><p>k8s 支持通过创建 HorizontalPodAutoscaler，根据 CPU 利用率或者服务提供的 metrics，对 Deployment、Replication Controller 或者 ReplicaSet 进行自动扩缩容。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl autoscale deployment nginx-deployment --min=10 --max=15 --cpu-percent=80</span><br></pre></td></tr></table></figure><p>详细请参考：</p><p><a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/</a></p><p><a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/</a></p><h3 id="发布最佳实践"><a href="#发布最佳实践" class="headerlink" title="发布最佳实践"></a>发布最佳实践</h3><h4 id="滚动发布"><a href="#滚动发布" class="headerlink" title="滚动发布"></a>滚动发布</h4><p>滚动发布是 Deployment 默认支持的更新方式，除了上文介绍的 rollingUpdate 相关配置外，不需要其他特殊的配置工作，</p><h4 id="灰度／金丝雀发布"><a href="#灰度／金丝雀发布" class="headerlink" title="灰度／金丝雀发布"></a>灰度／金丝雀发布</h4><p>金丝雀发布通过同时创建两个 Deployments 来实现，通过 track 标签区分两个版本，稳定版本的 Deployment 定义如下：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">name:</span> <span class="hljs-string">frontend</span></span><br><span class="line"><span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span></span><br><span class="line"><span class="hljs-string">...</span></span><br><span class="line"><span class="hljs-attr">labels:</span></span><br><span class="line"><span class="hljs-attr">   app:</span> <span class="hljs-string">guestbook</span></span><br><span class="line"><span class="hljs-attr">   tier:</span> <span class="hljs-string">frontend</span></span><br><span class="line"><span class="hljs-attr">   track:</span> <span class="hljs-string">stable</span></span><br><span class="line"><span class="hljs-string">...</span></span><br><span class="line"><span class="hljs-attr">image:</span> <span class="hljs-attr">gb-frontend:v3</span></span><br></pre></td></tr></table></figure><p>金丝雀版本的定义如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name: frontend-canary</span><br><span class="line">replicas: 1</span><br><span class="line">...</span><br><span class="line">labels:</span><br><span class="line">   app: guestbook</span><br><span class="line">   tier: frontend</span><br><span class="line">   track: canary</span><br><span class="line">...</span><br><span class="line">image: gb-frontend:v4</span><br></pre></td></tr></table></figure><p>再配置 service 的 labelSelector 将流量同时导入两个版本的 Pod</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">selector:</span></span><br><span class="line"><span class="hljs-attr">  app:</span> <span class="hljs-string">guestbook</span></span><br><span class="line"><span class="hljs-attr">  tier:</span> <span class="hljs-string">frontend</span></span><br></pre></td></tr></table></figure><p>通过 <code>.spec.replicas</code> 数量和扩缩容机制可以灵活配置稳定版本和金丝雀版本的比例（上面的例子为 3:1），流量会按照这个比例转发至不同版本，一旦线上测试无误后，将 track = stable 的 Deployment 更新为新版本镜像，再删除 track = canary 的 Deployment 即可。</p><h4 id="蓝绿发布"><a href="#蓝绿发布" class="headerlink" title="蓝绿发布"></a>蓝绿发布</h4><p>与金丝雀发布类似，同时创建 2 个label 不同的 Deployment，例如，deployment-1 定义如下：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">name:</span> <span class="hljs-string">frontend</span></span><br><span class="line"><span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span></span><br><span class="line"><span class="hljs-string">...</span></span><br><span class="line"><span class="hljs-attr">labels:</span></span><br><span class="line"><span class="hljs-attr">   app:</span> <span class="hljs-string">guestbook</span></span><br><span class="line"><span class="hljs-attr">   tier:</span> <span class="hljs-string">frontend</span></span><br><span class="line"><span class="hljs-attr">   version:</span> <span class="hljs-string">v3</span></span><br><span class="line"><span class="hljs-string">...</span></span><br><span class="line"><span class="hljs-attr">image:</span> <span class="hljs-attr">gb-frontend:v3</span></span><br></pre></td></tr></table></figure><p>deployment-2 定义如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">name: frontend</span><br><span class="line">replicas: 3</span><br><span class="line">...</span><br><span class="line">labels:</span><br><span class="line">   app: guestbook</span><br><span class="line">   tier: frontend</span><br><span class="line">   version: v4</span><br><span class="line">...</span><br><span class="line">image: gb-frontend:v4</span><br></pre></td></tr></table></figure><p>金丝雀发布通过修改 Deployment 的 replicas 数量和 Pod 镜像地址实现流量切换，而蓝绿发布通过修改 Service 的 labelSelector 实现流量切换。</p><p>原 service 定义如下：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">selector:</span></span><br><span class="line"><span class="hljs-attr">  app:</span> <span class="hljs-string">guestbook</span></span><br><span class="line"><span class="hljs-attr">  tier:</span> <span class="hljs-string">frontend</span></span><br><span class="line"><span class="hljs-attr">  version:</span> <span class="hljs-string">v3</span></span><br></pre></td></tr></table></figure><p>切量时修改为：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">selector:</span></span><br><span class="line"><span class="hljs-attr">  app:</span> <span class="hljs-string">guestbook</span></span><br><span class="line"><span class="hljs-attr">  tier:</span> <span class="hljs-string">frontend</span></span><br><span class="line"><span class="hljs-attr">  version:</span> <span class="hljs-string">v4</span></span><br></pre></td></tr></table></figure><h2 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h2><p>StatefulSet 相对于 Deployment，具有以下特点：</p><ul><li>稳定：唯一的 Pod 名称，唯一的网络ID，持久化存储</li><li>有序：部署和伸缩都按照顺序执行，滚动升级按照顺序执行</li></ul><h3 id="升级机制-1"><a href="#升级机制-1" class="headerlink" title="升级机制"></a>升级机制</h3><ul><li><code>.spec.updateStrategy</code> 定义了升级 StatefulSet 的 Pod 的行为</li><li><code>.spec.updateStrategy.type</code> 为 OnDelete （默认行为）时，用户手动删除 Pod 后，新的 Pod 才会创建；为 RollingUpdate 时，k8s 按照 {N-1 .. 0} 的顺序滚动更新每个 Pod。</li><li><code>.spec.updateStrategy.rollingUpdate.partition</code> 可以实现灰度发布，当 StatefulSet 更新时，所有序号大于或等于 partition 的 Pod 会滚动更新；所有序号小于 partition 的 Pod 不会更新，即使被删掉，也会创建旧版本的 Pod。当 partition 大于 replicas 时，任何 Pod 都不会被更新。</li></ul><p>配置示例如下：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">spec:</span></span><br><span class="line"><span class="hljs-attr">  replicas:</span> <span class="hljs-number">10</span></span><br><span class="line"><span class="hljs-attr">  updateStrategy:</span></span><br><span class="line"><span class="hljs-attr">    type:</span> <span class="hljs-string">RollingUpdate</span></span><br><span class="line"><span class="hljs-attr">    rollingUpdate:</span></span><br><span class="line"><span class="hljs-attr">      partition:</span> <span class="hljs-number">7</span>  <span class="hljs-comment"># 7, 8, 9 will be rolling updated</span></span><br></pre></td></tr></table></figure><p>StatefulSet 也支持 <code>kubectl rollout</code> 命令，使用方法同 Deployment。</p><h3 id="扩缩容机制-1"><a href="#扩缩容机制-1" class="headerlink" title="扩缩容机制"></a>扩缩容机制</h3><p>可以通过 <code>spec.podManagementPolicy</code> 来配置 StatefulSet 的扩缩容策略</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">spec:</span></span><br><span class="line"><span class="hljs-attr">  podManagementPolicy:</span> <span class="hljs-string">OrderdReady</span></span><br></pre></td></tr></table></figure><h4 id="OrderedReady"><a href="#OrderedReady" class="headerlink" title="OrderedReady"></a>OrderedReady</h4><p>默认行为</p><p>扩容时，Pod 按照 {0 .. N-1} 依次创建，并且前一个 Running／Ready 之后，后一个才会创建</p><p>缩容时，Pod 按照 {N-1 .. 0} 依次删除，前一个完全删除之后，后一个才会开始删除</p><h4 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h4><p>扩缩容时忽略顺序，并发创建或删除</p><p>注意，该配置仅仅对扩缩容（修改 replicas）的情况有效，升级 StatefulSet 时 k8s 依然按照次序来更新 Pod。</p><h3 id="唯一网络-ID"><a href="#唯一网络-ID" class="headerlink" title="唯一网络 ID"></a>唯一网络 ID</h3><p>每个 Pod 都有唯一的 hostname，格式为<statefulset-name>-<pod 序号>，domain name 的格式为<headless-svc-name>.<namespace>.svc.cluster.local，通过该 domain name 可以解析到 StatefulSet 下所有的 Pod。通过<statefulset-name>-<pod 序号>.<headless-svc-name>.<namespace>.svc.cluster.local 可以解析到指定 Pod。</namespace></headless-svc-name></pod></statefulset-name></namespace></headless-svc-name></pod></statefulset-name></p><h3 id="稳定存储"><a href="#稳定存储" class="headerlink" title="稳定存储"></a>稳定存储</h3><p>通过配置 StatefulSet 的 <code>volumeClaimTemplates</code>，k8s 会为每个 Pod 创建 PV 和 PVC 并绑定。当 Pod 删除时，对应的 PVC 不会被删除，当重新创建时，仍然会绑定到之前的 PV。</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">volumeClaimTemplates:</span></span><br><span class="line"><span class="hljs-attr">- metadata:</span></span><br><span class="line"><span class="hljs-attr">    name:</span> <span class="hljs-string">www</span></span><br><span class="line"><span class="hljs-attr">  spec:</span></span><br><span class="line"><span class="hljs-attr">    accessModes:</span> <span class="hljs-string">[</span> <span class="hljs-string">"ReadWriteOnce"</span> <span class="hljs-string">]</span></span><br><span class="line"><span class="hljs-attr">    storageClassName:</span> <span class="hljs-string">"my-storage-class"</span></span><br><span class="line"><span class="hljs-attr">    resources:</span></span><br><span class="line"><span class="hljs-attr">      requests:</span></span><br><span class="line"><span class="hljs-attr">        storage:</span> <span class="hljs-number">1</span><span class="hljs-string">Gi</span></span><br></pre></td></tr></table></figure><h3 id="发布最佳实践-1"><a href="#发布最佳实践-1" class="headerlink" title="发布最佳实践"></a>发布最佳实践</h3><h4 id="滚动发布-1"><a href="#滚动发布-1" class="headerlink" title="滚动发布"></a>滚动发布</h4><p>滚动发布需要配置 <code>.spec.updateStrategy.type</code> 为 <code>RollingUpdate</code>，StatefulSet 的默认行为是按照 {N-1 .. 0} 的顺序依次更新。</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">spec:</span></span><br><span class="line"><span class="hljs-attr">  updateStrategy:</span></span><br><span class="line"><span class="hljs-attr">    type:</span> <span class="hljs-string">RollingUpdate</span></span><br></pre></td></tr></table></figure><h4 id="蓝绿发布-1"><a href="#蓝绿发布-1" class="headerlink" title="蓝绿发布"></a>蓝绿发布</h4><p>蓝绿发布与 Deployment 的方式相同，通过创建 2 个 StatefulSet，修改 Service 的方式实现切量。</p><h4 id="灰度／金丝雀发布-1"><a href="#灰度／金丝雀发布-1" class="headerlink" title="灰度／金丝雀发布"></a>灰度／金丝雀发布</h4><p>金丝雀发布通过修改 StatefulSet 的 <code>.spec.updateStrategy.rollingUpdate.partition</code> 的值来实现发布。</p><p>例如 replicas 为 10 时，Pod 的序号为 0 - 9，首先将 partition 设置为 7，再修改 StatefulSet 的 Pod template 配置，会依次触发 Pod 9, 8, 7 的滚动更新，Pod 0-6 依然维持老版本，此时老版本与旧版本的比例为 7:3。线上验证无误后，再将 partition 设置为 0，依次触发 Pod 6 - 0 的滚动更新，此时全部更新至新版本。</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">spec:</span></span><br><span class="line"><span class="hljs-attr">  replicas:</span> <span class="hljs-number">10</span></span><br><span class="line"><span class="hljs-attr">  updateStrategy:</span></span><br><span class="line"><span class="hljs-attr">    type:</span> <span class="hljs-string">RollingUpdate</span></span><br><span class="line"><span class="hljs-attr">    rollingUpdate:</span></span><br><span class="line"><span class="hljs-attr">      partition:</span> <span class="hljs-number">7</span>  <span class="hljs-comment"># 7, 8, 9 will be rolling updated</span></span><br></pre></td></tr></table></figure><h2 id="Replication-Controller-（官方已不推荐使用）"><a href="#Replication-Controller-（官方已不推荐使用）" class="headerlink" title="Replication Controller （官方已不推荐使用）"></a>Replication Controller （官方已不推荐使用）</h2><p>kubectl rolling-update 只适用于 Replication Controllers，已经被 Deployment 取代，在此不过多介绍。</p><p><a href="https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/run-application/rolling-update-replication-controller/</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Deployment：<a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/workloads/controllers/deployment/</a></li><li>Deployment Rolling Update：<a href="https://tachingchen.com/blog/kubernetes-rolling-update-with-deployment/" target="_blank" rel="noopener">https://tachingchen.com/blog/kubernetes-rolling-update-with-deployment/</a></li><li>金丝雀部署：<a href="https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments</a></li><li>微服务部署：蓝绿部署、滚动部署、灰度发布、金丝雀发布：<a href="https://www.jianshu.com/p/022685baba7d" target="_blank" rel="noopener">https://www.jianshu.com/p/022685baba7d</a></li><li>StatefulSet：<a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了 Deployment 和 StatefulSet 的升级机制和扩缩容机制，以及一些常用的配置项。并分别介绍了以这两种方式部署 Pod 时的对服务进行升级（包括滚动发布、蓝绿发布、灰度／金丝雀发布）的最佳实践。&lt;/p&gt;&lt;h2 id=&quot;Deployment&quot;&gt;&lt;a href=&quot;#Deployment&quot; class=&quot;headerlink&quot; title=&quot;Deployment&quot;&gt;&lt;/a&gt;Deployment&lt;/h2&gt;&lt;h3 id=&quot;升级机制&quot;&gt;&lt;a href=&quot;#升级机制&quot; class=&quot;headerlink&quot; title=&quot;升级机制&quot;&gt;&lt;/a&gt;升级机制&lt;/h3&gt;&lt;h4 id=&quot;Rollout&quot;&gt;&lt;a href=&quot;#Rollout&quot; class=&quot;headerlink&quot; title=&quot;Rollout&quot;&gt;&lt;/a&gt;Rollout&lt;/h4&gt;&lt;p&gt;Deployment 的 rollout 在 .spec.template 被修改时触发（比如镜像地址更新、Pod label 更新等等），其他修改（.spec.replicas 更新）不会触发。&lt;/p&gt;&lt;p&gt;更新时，k8s 通过计算 pod-template-hash，创建新的 ReplicaSet，由新的 rs 启动新的 Pod，不断替换旧 rs 的 Pod。&lt;/p&gt;
    
    </summary>
    
    
      <category term="原创" scheme="http://whypro.github.io/hexo-blog/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="Kubernetes" scheme="http://whypro.github.io/hexo-blog/tags/Kubernetes/"/>
    
      <category term="K8S" scheme="http://whypro.github.io/hexo-blog/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>从头编写一款时间序列数据库</title>
    <link href="http://whypro.github.io/hexo-blog/20180110/%E4%BB%8E%E5%A4%B4%E7%BC%96%E5%86%99%E4%B8%80%E6%AC%BE%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://whypro.github.io/hexo-blog/20180110/从头编写一款时间序列数据库/</id>
    <published>2018-01-10T14:01:52.000Z</published>
    <updated>2019-06-02T09:10:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转自 <a href="http://dockone.io/article/2300" target="_blank" rel="noopener">从头编写一款时间序列数据库</a> （翻译：Colstuwjx），请支持原作者。</p></blockquote><p>我从事监控方面的工作。尤其是专注在 <a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus</a>，一款内置了自己定制的时间序列数据库的监控系统，以及它和 <a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a> 的集成工作。</p><p>从很多方面来说，Kubernetes 表现出了一切 Prometheus 专门设计的东西。它使得持续部署，自动扩缩，以及高度动态环境的其他功能更易于实现。它的查询语言和操作模型，还有许多其他概念方面的决策使得 Prometheus 尤其适合这样的环境。然而，如果被监控的工作负载变得更加显著动态的话，这也会给监控系统本身带来新的压力。基于这一点的考虑，与其再次回顾 Prometheus 已经很好解决的问题，还不如专注于在这样一个高度动态或短生命周期服务的环境里提高它的性能。</p><p>Prometheus 的存储层在历史上有着惊人的性能表现，一个单台服务器每秒可以摄取多达 100 万个采样，数百万个时间序列，同时仅占用令人惊叹的少量磁盘空间。尽管当前的存储已经给我们提供了不错的服务，笔者构思了一个新设计的存储子系统用来纠正现有解决方案的一些短板，并且可以用来配备支撑下一代的集群规模。</p><a id="more"></a><blockquote><p>注意：笔者并没有数据库方面的背景。我在这里所说的话可能是错误的或是带有误导性的。你可以在 Freenode 上的 #prometheus 频道里将你的批评指正反馈到我（fabxc）。</p></blockquote><h2 id="问题，难题，问题域"><a href="#问题，难题，问题域" class="headerlink" title="问题，难题，问题域"></a>问题，难题，问题域</h2><p>首先，快速概括一下我们试图完成的任务以及这里面暴露出的关键问题。针对每一点，我们会先看一看 Prometheus 目前的做法，它在哪些地方做的出色，以及我们旨在通过新的设计想解决哪些问题。</p><h3 id="时间序列数据"><a href="#时间序列数据" class="headerlink" title="时间序列数据"></a>时间序列数据</h3><p>我们有一个根据时间采集数据点的系统。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">identifier -&gt; (t0, v0), (t1, v1), (t2, v2), (t3, v3), ....</span><br></pre></td></tr></table></figure><p>每个数据点都是一个由时间戳和值组成的元组。为了达成监控的目的，时间戳是一个整数，值则可以是任意数字。经验来看，一个64位的浮点数往往能够很好地展现计数器（counter）和测量（gauge）的值，因此我们也不例外。一个时间序列是一组时间上严格单调递增的数据点序列，它可以通过一个标识符来寻址。我们的标识符便是一个度量（metric）名带上一个多维标签的字典。多维标签会将单个度量的测量空间分区。每个度量名加上一串唯一的标签便组成了它自己的时间序列（time series），它会有一个与之关联的值序列流。下面是一组典型的序列标识符，它是度量请求计数的一部分：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">requests_total&#123;path=&quot;/status&quot;, method=&quot;GET&quot;, instance=&quot;10.0.0.1:80&quot;&#125;</span><br><span class="line">requests_total&#123;path=&quot;/status&quot;, method=&quot;POST&quot;, instance=&quot;10.0.0.3:80&quot;&#125;</span><br><span class="line">requests_total&#123;path=&quot;/&quot;, method=&quot;GET&quot;, instance=&quot;10.0.0.2:80&quot;&#125;</span><br></pre></td></tr></table></figure><p>让我们快速简化一下这个表达形式：我们不妨将一个度量名视为另一种标签维度 - 在我们的场景里便是 <code>__name__</code>。在查询级别上，它可能会被特殊对待，但是它并不会关注我们采用何种方式来存放它，这一点我们将在后面看到。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;__name__=&quot;requests_total&quot;, path=&quot;/status&quot;, method=&quot;GET&quot;, instance=&quot;10.0.0.1:80&quot;&#125;</span><br><span class="line">&#123;__name__=&quot;requests_total&quot;, path=&quot;/status&quot;, method=&quot;POST&quot;, instance=&quot;10.0.0.3:80&quot;&#125;</span><br><span class="line">&#123;__name__=&quot;requests_total&quot;, path=&quot;/&quot;, method=&quot;GET&quot;, instance=&quot;10.0.0.2:80&quot;&#125;</span><br></pre></td></tr></table></figure><p>当查询时间序列数据时，我们想通过指定标签来选择。最简单的例子莫过于 <code>{__name__=&quot;requests_total&quot;}</code> 会选出所有属于 <code>requests_total</code> 度量的序列。针对所有被选中的序列来说，我们会在一个指定的时间窗口里检索出对应的数据点。</p><p>而在更复杂的查询里，我们可能希望同时选择满足多个标签选择器的序列，并且就表达形式来说也会存在比等于更复杂的条件。比如，取反（<code>method!=&quot;GET&quot;</code>）或者正则表达式匹配（<code>method=~&quot;PUT|POST&quot;</code>）。</p><p>这大体上决定了所需存储的数据以及它们该如何被调用。</p><h3 id="横轴和纵轴"><a href="#横轴和纵轴" class="headerlink" title="横轴和纵轴"></a>横轴和纵轴</h3><p>在一个简化的视图中，所有数据点都可以在一个二维平面上分布。横轴代表时间，而序列标识符的空间遍及整个纵轴。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">series</span><br><span class="line">  ^   </span><br><span class="line">  │   . . . . . . . . . . . . . . . . .   . . . . .   &#123;__name__=&quot;request_total&quot;, method=&quot;GET&quot;&#125;</span><br><span class="line">  │     . . . . . . . . . . . . . . . . . . . . . .   &#123;__name__=&quot;request_total&quot;, method=&quot;POST&quot;&#125;</span><br><span class="line">  │         . . . . . . .</span><br><span class="line">  │       . . .     . . . . . . . . . . . . . . . .                  ... </span><br><span class="line">  │     . . . . . . . . . . . . . . . . .   . . . .   </span><br><span class="line">  │     . . . . . . . . . .   . . . . . . . . . . .   &#123;__name__=&quot;errors_total&quot;, method=&quot;POST&quot;&#125;</span><br><span class="line">  │           . . .   . . . . . . . . .   . . . . .   &#123;__name__=&quot;errors_total&quot;, method=&quot;GET&quot;&#125;</span><br><span class="line">  │         . . . . . . . . .       . . . . .</span><br><span class="line">  │       . . .     . . . . . . . . . . . . . . . .                  ... </span><br><span class="line">  │     . . . . . . . . . . . . . . . .   . . . . </span><br><span class="line">  v</span><br><span class="line">    &lt;-------------------- time ---------------------&gt;</span><br></pre></td></tr></table></figure><p>Prometheus 通过定期抓取一组时间序列的当前值来检索得到数据点。这样一个我们检索批次的实体被称作一个目标（target）。由于每个目标的样本数据都是单独抓取的，因此写入模式是完全垂直并且高度并发的。这里提供一些衡量尺度：一个单个的Prometheus实例会从成千上万的目标采集数据点，每个目标可以暴露出数百上千个不同的时间序列。</p><p>就每秒采集数百万个数据点的规模而言，批量写入是一个不可调和的性能需求。分散地写入单个数据点到磁盘的话又会是一个非常缓慢的过程。因此，我们想要实现的是按顺序写入更大的数据块。对于机械的旋转磁盘而言这样做并不出奇，因为它们的头会一直物理地移动到不同的区块。虽然 SSD 以快速地随机写入性能而闻名，但是实际上它们却不能修改单个字节，而只能写入 4KiB 或更大的的页。这意味着写一个 16 字节的样本同写一个完整的 4KiB 页没什么两样。这种行为即是所谓的<a href="https://en.wikipedia.org/wiki/Write_amplification" target="_blank" rel="noopener">写入放大</a>的一部分，作为一个“额外红利”，它会耗损你的 SSD —— 因此它不仅仅只是会变慢而已，还会在几天或者几周内完全毁掉你的硬件。关于这个问题的更详细信息，系列博客”<a href="http://codecapsule.com/2014/02/12/coding-for-ssds-part-1-introduction-and-table-of-contents/" target="_blank" rel="noopener">针对 SSD 编程</a>“系列会是一个不错的资源。我们不妨考虑一下这里面的主要关键点：顺序和批量写入是旋转磁盘和 SSD 的理想写入模式。 这是一个应该遵循的简单规则。</p><p>时间序列数据库的查询模型跟写模型相比，更是有明显不同的区别。我们可以对一个单个序列查询一个单个的数据点，在 10000 个序列里查询一个单个的数据点，在一个单个序列里查询几周的数据点，甚至在 10000 个序列里查询几周的数据点，等等。因此在我们的二维平面上，查询既不是完全垂直的，也不是水平的，而是二者的矩形组合。<a href="https://prometheus.io/docs/practices/rules/" target="_blank" rel="noopener">记录规则</a>可以减轻已知的一些查询方面的问题，但是仍然不是临时查询（ad-hoc queries）的一个通用解决方案，这些查询也必须能很好的进行下去。</p><p>须知我们想要的是批量写入，但是我们得到的批次只是序列之间一个纵向的数据点集合。当在一个时间窗口上针对某个序列查询数据点时，不仅难以确定各个数据点可以被找到的位置，我们还不得不从磁盘上大量的随机位置进行读取。每次查询操作可能涉及到数以百万的样例数据，即使在最快的 SSD 上这样的操作也会变慢。读操作还将从磁盘上检索更多的数据，而不仅仅只是所请求的 16 字节大小的样本。 SSD 将加载一整页，HDD 将至少读取整个扇区。 无论哪种方式，我们都会浪费宝贵的读吞吐量。</p><p>因此，在理想情况下，相同序列的样本数据将会被顺序存储，这样一来我们便可以用尽可能少的读来扫描得到它们。 在上层，我们只需要知道这个序列可以访问的所有数据点的开始位置。</p><p>在将收集的数据写入磁盘的理想模式和为服务的查询操作提供更显著有效的存储格式之间显然存在着强烈的冲突。这是我们的时间序列数据库要解决的根本问题。</p><h4 id="当前的解决方案"><a href="#当前的解决方案" class="headerlink" title="当前的解决方案"></a>当前的解决方案</h4><p>是时候来看看 Prometheus 当前的存储是如何实现的，我们不妨叫它“V2”，它致力于解决这个问题。我们会为每个时间序列创建一个文件，它会按照时间顺序包含所有的样本数据。由于每隔几秒就把单个的样本数据添加到所有这些文件的成本不小，我们针对每个序列在内存里批量存放了 1KiB 的数据块，一旦它们填满了再把这些块添加到一个个的文件里。这一方案解决了很大一部分问题。写操作如今是分批次的，样本数据也是顺序存储的。它还能为我们提供一个令人难以置信的高效压缩格式，这是基于一个给定的样本相对于相同序列里前面的那些样本数据只有非常少量的变化这一属性而设计。Facebook 在它们的 Gorilla TSDB 的论文里描述了一种类似的基于块（Chunk）的存储方法，并且引入了一个压缩格式，将16个字节的样本减少到平均 1.37 字节。V2 存储使用了各种压缩格式，包括 Gorilla 的一个变种。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  ┌──────────┬─────────┬─────────┬─────────┬─────────┐           series A</span><br><span class="line">  └──────────┴─────────┴─────────┴─────────┴─────────┘</span><br><span class="line">         ┌──────────┬─────────┬─────────┬─────────┬─────────┐    series B</span><br><span class="line">         └──────────┴─────────┴─────────┴─────────┴─────────┘ </span><br><span class="line">                             . . .</span><br><span class="line">┌──────────┬─────────┬─────────┬─────────┬─────────┬─────────┐   series XYZ</span><br><span class="line">└──────────┴─────────┴─────────┴─────────┴─────────┴─────────┘ </span><br><span class="line">  chunk 1    chunk 2   chunk 3     ...</span><br></pre></td></tr></table></figure><p>尽管基于块的实现方案很棒，如何为每个序列维护一个单独的文件却也是V2存储引擎困扰的地方，这里面有几个原因：</p><ul><li><p>我们实际上需要维护的文件数量多于我们正在收集数据的时间序列数量。在“序列分流”一节会详解介绍到这点。由于产生了几百万个文件，不久的将来或者迟早有一天，我们的文件系统会出现 <a href="https://en.wikipedia.org/wiki/Inode" target="_blank" rel="noopener">inodes</a> 耗尽的情况。在这种情况下我们只能通过重新格式化磁盘来恢复，这样做可能带有侵入性和破坏性。通常我们都希望避免格式化磁盘，特别是需要适配某个单个应用时更是如此。</p></li><li><p>即便做了分块，每秒也会产生数以千计的数据块并且准备好被持久化。这仍然需要每秒完成几千次单独的磁盘写操作。尽管这一点可以通过为每个序列填满的数据块做分批处理来缓解压力，这反过来又会增加等待被持久化的数据总的内存占用。</p></li><li><p>保持打开所有文件来读取和写入是不可行的。特别是因为在24小时后超过99%的数据便不再会被查询。如果它还是被查询到的话，我们就不得不打开数千个文件，查找和读取相关的数据点到内存，然后再重新关闭它们。而这样做会导致很高的查询延迟，数据块被相对积极地缓存的话又会导致一些问题，这一点会在“耗用资源”一节里进一步概述。</p></li><li><p>最终，旧数据必须得被清理掉，而且数据需要从数百万的文件前面被抹除。这意味着删除实际上是写密集型操作。此外，循环地在这数百万的文件里穿梭然后分析它们会让这个过程常常耗费数个小时。在完成时有可能还需要重新开始。呵呵，删除旧文件将会给你的SSD带来进一步的写入放大！</p></li><li><p>当前堆积的数据块只能放在内存里。如果应用崩溃的话，数据将会丢失。为了避免这种情况，它会定期地保存内存状态的检查点（Checkpoint）到磁盘，这可能比我们愿意接受的数据丢失窗口要长得多。从检查点恢复估计也会花上几分钟，造成痛苦而漫长的重启周期。</p></li></ul><p>从现有的设计中脱颖而出的关键在于块的概念，我们当然希望保留这一设计。大多数最近的块被保留在内存里一般来说也是一个不错的做法。毕竟，最大幅度被查询数据里大部分便是这些最近的点。</p><p>一个时间序列对应一个文件这一概念是我们想要替换的。</p><h3 id="序列分流-Series-Churn"><a href="#序列分流-Series-Churn" class="headerlink" title="序列分流 (Series Churn)"></a>序列分流 (Series Churn)</h3><p>在 Prometheus 的上下文里，我们使用术语“序列分流”来描述一组时间序列变得不活跃，即不再接收数据点，取而代之的是有一组新的活跃的序列出现。</p><p>举个例子，由一个给定的微服务实例产出的所有序列各自都有一个标识它起源的“instance”标签。如果我们对该微服务完成了一次滚动更新然后将每个实例切换到了一个更新的版本的话，序列分流就产生了。在一个更加动态的环境里，这些事件可能会以小时的频率出现。像Kubernetes这样的集群编排系统允许应用程序不断地自动伸缩和频繁的滚动更新，它可能会创建出数万个新的应用程序实例，并且每天都会使用全新的时间序列。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">series</span><br><span class="line">  ^</span><br><span class="line">  │   . . . . . .</span><br><span class="line">  │   . . . . . .</span><br><span class="line">  │   . . . . . .</span><br><span class="line">  │               . . . . . . .</span><br><span class="line">  │               . . . . . . .</span><br><span class="line">  │               . . . . . . .</span><br><span class="line">  │                             . . . . . .</span><br><span class="line">  │                             . . . . . .</span><br><span class="line">  │                                         . . . . .</span><br><span class="line">  │                                         . . . . .</span><br><span class="line">  │                                         . . . . .</span><br><span class="line">  v</span><br><span class="line">    &lt;-------------------- time ---------------------&gt;</span><br></pre></td></tr></table></figure><p>因此，即便整个基础设施大体上保持不变，随着时间的推移，我们数据库里的时间序列数据量也会呈线性增长。 尽管 Prometheus 服务器很愿意去采集 1000 万个时间序列的数据，但是如果不得不在十亿个序列中查找数据的话，很明显查询性能会受到影响。</p><h4 id="当前解决方案"><a href="#当前解决方案" class="headerlink" title="当前解决方案"></a>当前解决方案</h4><p>Prometheus当前 V2 版本的存储针对当前被存放的所有序列都有一个基于 LevelDB 的索引。它允许包含一个指定的标签对来查询序列，但是缺乏一个可扩展的方式以组合来自不同标签选择的结果。举个例子，用户可以有效地选出带有标签 <code>__name __ =&quot;requests_total&quot;</code> 的所有序列，但是选择所有满足 <code>instance=&quot;A&quot;</code> AND <code>__name __ =&quot;requests_total&quot;</code> 的序列则都有可扩展性的问题。我们稍后会重新审视为什么会造成这样的结果，要改善查询延迟的话要做哪些必要的调整。</p><p>实际上这一问题正是触发要实现一个更好的存储系统的最初动力。Prometheus 需要一个改进的索引方法从数亿个时间序列里进行快速搜索。</p><h3 id="耗用资源"><a href="#耗用资源" class="headerlink" title="耗用资源"></a>耗用资源</h3><p>耗用资源是试图扩展 Prometheus（或者任何东西，真的）时不变的话题之一。但是实际上烦恼用户的问题并不是绝对的资源匮乏。实际上，由于给定需求的驱动，Prometheus 管理着令人难以置信的吞吐量。问题更在于是面对变化的相对未知性和不稳定性。由于V2存储本身的架构设计，它会缓慢地构建出大量的样本数据块，而这会导致内存消耗随着时间的推移不断增加。随着数据块被填满，它们会被写入到磁盘，随即便能够从内存中被清理出去。最终，Prometheus 的内存使用量会达到一个稳定的状态。直到受监控的环境发生变化 - 每次我们扩展应用程序或进行滚动更新时，序列分流 会造成内存，CPU 和磁盘 IO 占用方面的增长。</p><p>如果变更是正在进行的话，那么最终它将再次达到一个稳定的状态，但是比起一个更加静态的环境而言，它所消耗的资源将会显著提高。过渡期的时长一般长达几个小时，而且很难说最大资源使用量会是多少。</p><p>每个时间序列对应一个单个文件的方式使得单个查询很容易就击垮 Prometheus 的进程。而当所要查询的数据没有缓存到内存时，被查询序列的文件会被打开，然后包含相关数据点的数据块会被读取到内存里。倘若数据量超过了可用内存，Prometheus 会因为 OOM 被杀死而退出。待查询完成后，加载的数据可以再次释放，但通常会缓存更长时间，以便在相同数据上更快地提供后续查询。后者显然是一件好事。</p><p>最后，我们看下 SSD 上下文里的写入放大，以及 Prometheus 是如何通过批量写入来解决这个问题。然而，这里仍然有几处会造成写入放大，因为存在太多小的批次而且没有精确地对准页面边界。针对更大规模的 Prometheus 服务器，现实世界已经有发现硬件寿命缩短的情况。可能对于具有高写入吞吐量的数据库应用程序来说，这仍属正常，但是我们应该关注是否可以缓解这一情况。</p><h2 id="从头开始"><a href="#从头开始" class="headerlink" title="从头开始"></a>从头开始</h2><p>如今，我们对我们的问题域有了一个清晰的了解，V2 存储是如何解决它的，以及它在设计上存在哪些问题。我们也看到一些很棒的概念设计，这些也是我们想要或多或少无缝适配的。相当数量的 V2 版本存在的问题均可以通过一些改进和部分的重新设计来解决，但为了让事情变得更好玩些（当然，我这个决定是经过深思熟虑的），我决定从头开始编写一款全新的时间序列数据库 —— 从零开始，即，将字节数据写到文件系统。</p><p>性能和资源使用这样的关键问题会直接引领我们做出存储格式方面的选择。我们必须为我们的数据找到一个正确的算法和磁盘布局以实现一个性能优良的存储层。</p><p>这便是我直接迈向成功时走的捷径 —— 忽略之前经历过的头疼，无数失败的想法，数不尽的草图，眼泪，还有绝望。</p><h3 id="V3-宏观设计"><a href="#V3-宏观设计" class="headerlink" title="V3 - 宏观设计"></a>V3 - 宏观设计</h3><p>我们新版存储引擎的宏观设计是怎样的？简略来讲，只要到我们的 data 目录下运行 <code>tree</code> 命令，一切便都一目了然。不妨看下这幅美妙的画面它能带给我们怎样的一个惊喜。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ tree ./data</span><br><span class="line">./data</span><br><span class="line">├── b-000001</span><br><span class="line">│   ├── chunks</span><br><span class="line">│   │   ├── 000001</span><br><span class="line">│   │   ├── 000002</span><br><span class="line">│   │   └── 000003</span><br><span class="line">│   ├── index</span><br><span class="line">│   └── meta.json</span><br><span class="line">├── b-000004</span><br><span class="line">│   ├── chunks</span><br><span class="line">│   │   └── 000001</span><br><span class="line">│   ├── index</span><br><span class="line">│   └── meta.json</span><br><span class="line">├── b-000005</span><br><span class="line">│   ├── chunks</span><br><span class="line">│   │   └── 000001</span><br><span class="line">│   ├── index</span><br><span class="line">│   └── meta.json</span><br><span class="line">└── b-000006</span><br><span class="line">    ├── meta.json</span><br><span class="line">    └── wal</span><br><span class="line">        ├── 000001</span><br><span class="line">        ├── 000002</span><br><span class="line">        └── 000003</span><br></pre></td></tr></table></figure><p>在最上面一层，我们有一组带编号的块，它们均有一个前缀 <code>b-</code>。 每个块显然都维护一个包含索引的文件以及一个包含更多编号文件的”chunk”目录。”chunks”目录没别的，就多个序列的一些数据点的原始块。跟V2的做法一样，这样可以用非常低的成本来读取一个时间窗口里的序列数据，并且允许我们采用相同的有效压缩算法。这个概念已经被证实是行之有效的，我们自然就沿用这一点。很显然，这里不再是每个序列对应一个单个文件，取而代之的是，几个文件包含许多序列的数据块。</p><p>“index”文件的存在是预料之中的事情。我们不妨假定它包含了大量的黑魔法，允许我们找出标签，它们可能的值，整个时间序列，以及存放数据点的数据块。</p><p>但是，为什么有几个目录是一个索引和一些块文件这样的布局？为什么最后一个目录里取而代之的是有一个“wal”目录？搞清楚这两个问题的话可以解决我们90％的问题。</p><h4 id="众多的小型数据库"><a href="#众多的小型数据库" class="headerlink" title="众多的小型数据库"></a>众多的小型数据库</h4><p>我们将我们的水平维度，即时间空间分割成非重叠的块。 每个块当成一个完全独立的数据库，包含其时间窗口的所有时间序列数据。因此，它有自己的索引和一组块文件。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t0            t1             t2             t3             now</span><br><span class="line"> ┌───────────┐  ┌───────────┐  ┌───────────┐  ┌───────────┐</span><br><span class="line"> │           │  │           │  │           │  │           │                 ┌────────────┐</span><br><span class="line"> │           │  │           │  │           │  │  mutable  │ &lt;─── write ──── ┤ Prometheus │</span><br><span class="line"> │           │  │           │  │           │  │           │                 └────────────┘</span><br><span class="line"> └───────────┘  └───────────┘  └───────────┘  └───────────┘                        ^</span><br><span class="line">       └──────────────┴───────┬──────┴──────────────┘                              │</span><br><span class="line">                              │                                                  query</span><br><span class="line">                              │                                                    │</span><br><span class="line">                            merge ─────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p>每个块的数据均是无法更改的。当然，在我们采集到新数据时我们必须能够将新序列和样本数据添加到最近的数据块里。对于这个数据块，所有新数据都将写入到内存数据库里，跟我们持久化的数据块一样，它也会提供相同的查找属性。内存里的数据结构也可以被有效地更新。为了防止数据丢失，所有传入的数据还会被写入预写日志（write ahead log），即我们的“wal”目录中的一组文件，我们可以在重新启动时基于这些文件将之前内存里的数据重新填充到内存数据库。</p><p>所有这些文件都带有自己的序列化格式，它附带了许多标志，偏移量，变体和 CRC32 校验和。比起无聊地读着介绍，读者朋友自己去发现它们也许会更有乐趣些。</p><p>这种布局允许我们查出所有和被查询的时间范围相关的数据块。每个块的部分结果被合并到一起形成最终的完整结果。</p><p>这种水平分区解锁了一些很棒的功能：</p><ul><li><p>当查询一个时间范围时，我们可以轻松地忽略该范围外的所有数据块。 通过减少一系列开始时需要检查的数据，它可以初步解决序列分流的问题。</p></li><li><p>当完成一个数据块的填充时，我们可以通过顺序写入数据到一些较大的文件来保存内存数据库中的数据。 这样就避免了任何写入放大的问题，并且同样适用于SSD和HDD。</p></li><li><p>我们继承了 V2 优秀的地方，最近最多被查询的数据块总是作为热点保存在内存里。</p></li><li><p>棒棒哒，我们再也不需要通过固定的1KiB块大小设定来更好地对齐磁盘上的数据。 我们可以选择任何对于个别数据点和选定的压缩格式最有意义的大小。</p></li><li><p>删除旧数据变得非常低成本和及时。我们只需要删除一个目录。 请记住，在旧存储中，我们不得不分析并重新编写高达数亿个文件，这一操作可能需要几个小时才能收敛。</p></li></ul><p>每个块还包含一个 <code>meta.json</code> 文件。 它简单地保存该数据块的人类可读信息，便于用户轻松了解数据块的存储状态及其包含的数据。</p><h5 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h5><p>从数以百万的小文件改成几个更大的文件使得我们能够以很小的成本保持所有文件的打开句柄。这也解锁了使用 <a href="https://en.wikipedia.org/wiki/Mmap" target="_blank" rel="noopener">mmap(2)</a> 的玩法，它是一个系统调用，允许我们通过文件内容透明地回传到一个虚拟内存区域。为了简单起见，你可以联想它类似于交换(swap)空间，只是我们所有的数据已经在磁盘上，并且在将数据交换出内存后不会发生写入。这意味着我们可以将数据库里的所有内容均视为内存而不占用任何物理RAM。只有我们访问我们的数据库文件中的某些字节范围时，操作系统才会从磁盘惰性地加载页面。这就把和我们持久化数据相关的所有内存管理都交给了操作系统负责。 一般来说，操作系统更有资格做出这样的决定，因为它对整个机器及其所有过程有更全面的看法。查询数据可以相当积极地被缓存在内存里，而一旦面临内存压力，页面便会被逐出(evicted)。如果机器有未使用的内存，Prometheus 将会很高兴去缓存整个数据库，而一旦另一个应用程序需要它，它将立即返回。</p><p>这样一来，比起受到 RAM 的大小限制，即便查询更多的持久化数据，查询操作也不会再轻易造成进程的 OOM。内存的缓存大小变得完全自适应，只有在查询实际需要的数据时才会加载数据。</p><p>就我个人的理解，这是今天的很多数据库的工作方式，如果磁盘格式允许的话，这是一个理想的方法 - 除非你有信心在进程里做的工作能够超越操作系统。我们自己做了很少一部分工作而确实从外部系统收获了大量功能。</p><h4 id="压缩-compaction"><a href="#压缩-compaction" class="headerlink" title="压缩 (compaction)"></a>压缩 (compaction)</h4><p>存储引擎必须定期地“切出”一个新的块，并将之前完成的块写入到磁盘。只有块被成功持久化后，用于恢复内存块的预写日志文件（wal）才会被删除。</p><p>我们有兴趣将每个块的保存时间设置的相对短一些（一般设置大约两个小时），以避免在内存中堆积太多的数据。当查询多个块时，我们必须将其结果合并为一个完整结果。 这个合并过程显然会有一个成本，一个一周长的查询不应该需要合并超过80个的部分结果。</p><p>为了实现两者共同的需求，我们引入数据压缩（compaction）。它描述了采集一个或多个数据块并将其写入一个可能会更大的块的过程。它还可以沿途修改现有的数据，例如，清理已删除的数据，或重组我们的样本数据块以提高查询性能。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t0             t1            t2             t3             t4             now</span><br><span class="line"> ┌────────────┐  ┌──────────┐  ┌───────────┐  ┌───────────┐  ┌───────────┐</span><br><span class="line"> │ 1          │  │ 2        │  │ 3         │  │ 4         │  │ 5 mutable │    before</span><br><span class="line"> └────────────┘  └──────────┘  └───────────┘  └───────────┘  └───────────┘</span><br><span class="line"> ┌─────────────────────────────────────────┐  ┌───────────┐  ┌───────────┐</span><br><span class="line"> │ 1              compacted                │  │ 4         │  │ 5 mutable │    after (option A)</span><br><span class="line"> └─────────────────────────────────────────┘  └───────────┘  └───────────┘</span><br><span class="line"> ┌──────────────────────────┐  ┌──────────────────────────┐  ┌───────────┐</span><br><span class="line"> │ 1       compacted        │  │ 3      compacted         │  │ 5 mutable │    after (option B)</span><br><span class="line"> └──────────────────────────┘  └──────────────────────────┘  └───────────┘</span><br></pre></td></tr></table></figure><p>在这个例子里，我们有一组顺序的块 <code>[1, 2, 3, 4]</code>。数据块 1, 2 和 3 可以被一起压缩，然后形成的新结构便是 <code>[1, 4]</code>。或者，将它们成对地压缩成 <code>[1，3]</code>。 所有的时间序列数据仍然存在，但是现在总体的数据块更少。 这显著降低了查询时的合并成本，因为现在需要被合并的部分查询结果会更少。</p><h4 id="保留-Retention"><a href="#保留-Retention" class="headerlink" title="保留 (Retention)"></a>保留 (Retention)</h4><p>我们看到，删除旧数据在 V2 存储引擎里是一个缓慢的过程，而且会消耗 CPU，内存和磁盘。那么，我们该如何在基于块的设计中删除旧数据呢？简单来讲，只需删除该目录下在我们配置的保留窗口里没有数据的块。 在下面的示例中，块1可以安全地被删除，而2必须保留到完全落在边界之后才行。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                     |</span><br><span class="line">┌────────────┐  ┌────┼─────┐  ┌───────────┐  ┌───────────┐  ┌───────────┐</span><br><span class="line">│ 1          │  │ 2  |     │  │ 3         │  │ 4         │  │ 5         │   . . .</span><br><span class="line">└────────────┘  └────┼─────┘  └───────────┘  └───────────┘  └───────────┘</span><br><span class="line">                     |</span><br><span class="line">                     |</span><br><span class="line">            retention boundary</span><br></pre></td></tr></table></figure><p>获取越旧的数据，数据块可能就变得越大，这是因为我们会不断地压缩以前压缩的块。 因此必须得有一个压缩的上限，这样一来块就不会扩展到跨越整个数据库从而影响到我们设计的最初优势。</p><p>另一个方便之处在于，这样也可以限制部分在保留窗口里部分在外面的数据块的总磁盘开销，即上面示例中的块 2.当用户将最大块的大小设置为总保留窗口的 10% 时，保留块 2 的总开销也有 10% 的上限。</p><p>总而言之，保留删除的实现从非常高的成本变成了几乎零成本。</p><blockquote><p>如果看到这里，而且读者朋友本人有一些数据库的背景的话，你可能会问一件事：这是一个新玩法吗？ —— 其实不是；而且大概还可以做得更好。</p><p>在内存里批量处理数据，在预写日志（wal）里跟踪，并定期刷新到磁盘，这种模式在今天是被广泛采纳的。</p><p>无论数据特指的问题域是什么，我们所看到的好处几乎都是普遍适用的。 遵循这一方法的突出开源案例是 LevelDB，Cassandra，InfluxDB 或 HBase。而这里面的关键是要避免重复发明劣质轮子，研究经过生产验证的方法，并采取正确的姿势应用它们。</p><p>这里仍然留有余地可以添加用户自己的黑科技。</p></blockquote><h3 id="索引-index"><a href="#索引-index" class="headerlink" title="索引 (index)"></a>索引 (index)</h3><p>调研存储的改进方案的源动力便是为了解决序列分流引发的问题。基于块的布局设计减少了为查询提供服务所涉及的时间序列的总数。因此，假设我们索引查找的时间复杂度是 O（n ^ 2），我们设法减少n个相等的数量，那么现在就有一个改进的复杂度 O（n ^ 2） - uhm，等一下… 哇靠。</p><p>这时候脑海里迅速回忆起“算法101”提醒我们的事情，理论上讲，这并没有给我们带来任何改善。 如果以前做的不好，那现在也差不多。理论有时候真的挺让人沮丧的。</p><p>通过实践，我们大部分的查询明显会被更快地应答。然而，跨越全部时间范围的查询仍然很慢，即便他们只需要找到少量的系列。在所有这些工作开始之前，我最初的想法都是想要一个切实解决这个问题的方案：我们需要一个更强大的<a href="https://en.wikipedia.org/wiki/Inverted_index" target="_blank" rel="noopener">倒排索引</a>。</p><p>倒排索引基于它们内容的子集提供对数据项的快速查找。简单来讲，用户可以找出所有带有标签“app =”nginx“的序列，而无需遍历每一个序列然后再检查它是否包含该标签。</p><p>为此，每个序列被分配一个唯一的 ID，通过它可以在恒定的时间内检索，即 O（1）。在这种情况下，ID 就是我们的正向索引。</p><blockquote><p>示例：如果ID为10,29和9的序列包含标签 <code>app=&quot;nginx&quot;</code>，标签 “nginx” 的倒排索引便是一个简单的列表 <code>[10,29,9]</code>，它可以用来快速检索包含该标签的所有序列。即便还有 200 亿个序列，这也不会影响该次查找的速度。</p></blockquote><p>简而言之，如果n是我们的序列总数，m 是给定查询的结果大小，那么使用索引的查询复杂度便是 O（m）。查询操作扩展到根据其检索的数据量（m）而不是正在搜索的数据体（n）是一个很棒的特性，因为一般来说 m 明显会更小些。</p><p>为了简单起见，我们假定可以在恒定的时间内完成倒排索引列表本身的检索。</p><p>实际上，这也几乎就是V2版本所拥有的倒排索引的类型，也是为数百万序列提供高性能查询的最低要求。敏锐的观察者会注意到，在最坏的情况下，所有的系列都存在一个标签，因此，m又是O（n）。 这是预料中的事情，而且也完全合理。 如果用户要查询所有的数据，自然就需要更长的时间。 一旦涉及到更复杂的查询这里可能就有问题了。</p><h4 id="组合标签-Combining-Labels"><a href="#组合标签-Combining-Labels" class="headerlink" title="组合标签 (Combining Labels)"></a>组合标签 (Combining Labels)</h4><p>标签被关联到数百万序列是很常见的。 假设有一个拥有数百个实例的横向可扩缩的“foo”微服务，每个实例有数千个系列。 每个系列都会有“app =”foo“的标签。当然，用户一般不会去查询所有的系列，而是通过进一步的过滤标签来限制查询，例如，我想知道我的服务实例收到多少个请求，那查询语句便是 <code>__name __ =“requests_total” AND app =“foo”</code>。</p><p>为了找出满足两个标签选择器的所有系列，我们取每个标签选择器的倒排索引列表然后取交集。 所得到的集合通常比每个输入列表小一个数量级。由于每个输入列表具有最差情况的复杂度是O（n），所以在两个列表上嵌套迭代的暴力解都具有O（n ^ 2）的运行时间。 其他集合操作也是相同的成本，例如union（app =“foo”OR app =“bar”）。当用户向查询添加进一步的标签选择器时，指数会增加到O（n ^ 3），O（n ^ 4），O（n ^ 5），… O（n ^ k）。 通过更改执行顺序，可以玩很多技巧来最大限度地有效减少运行时间。越复杂，就越需要了解数据样式和标签之间的关系。这引入了更多复杂度，但是并没有减少我们算法的最坏运行时间。</p><p>以上基本便是V2存储里采取的方式，幸运的是，看似微不足道的修改足以获得显著的提升。如果我们说我们的倒排索引中ID是排序好的话会发生什么？</p><p>假设我们初始查询的列表示例如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__name__=&quot;requests_total&quot;   -&gt;   [ 9999, 1000, 1001, 2000000, 2000001, 2000002, 2000003 ]</span><br><span class="line">     app=&quot;foo&quot;              -&gt;   [ 1, 3, 10, 11, 12, 100, 311, 320, 1000, 1001, 10002 ]</span><br><span class="line"></span><br><span class="line">             intersection   =&gt;   [ 1000, 1001 ]</span><br></pre></td></tr></table></figure><p>它们的交集相当小。我们可以通过在每个列表的开始处设置一个光标，并且始终从较小的数字那端依次推进。 当两个数字相等时，我们将数字添加到我们的结果中并推进两个游标。总的来说，我们以这种之字形模式（zig-zag pattern）扫描这两个列表，这样一来我们总的成本会是O（2n）= O（n），因为我们只是在任意一个列表中向前移动。</p><p>两个以上列表的不同集合操作的过程也是类似的效果。因此，k个集合操作的数量仅仅只会将时间复杂度修改为（O（k * n））而不是我们最坏情况的查找运行时的指数级（O（n ^ k））。真是一个大进步。</p><p>我在这里描述的内容几乎就是任意一款<a href="https://en.wikipedia.org/wiki/Search_engine_indexing#Inverted_indices" target="_blank" rel="noopener">全文搜索引擎</a> 所使用的规范搜索索引的简化版本。每个序列的描述符被视为一个简短的“文档”，每个标签（名称+固定值）作为其中的“单词”。我们可以忽略通常在搜索引擎索引中遇到的大量附加数据，例如字位置和出现频率等数据。</p><p>业内似乎都在无休止的研究探索改进实际运行时的方法，他们也常常对输入数据做出一些假设。不出所料的是，许多可以压缩倒排索引的技术均是有利有弊的。而由于我们的“文档”很小，“文字”在所有序列里都是非常重复的，所以压缩变得几乎无关紧要。 例如，一个约440万系列的现实世界数据集，每个标签约有12个，拥有少于5,000个唯一的标签。在我们最开始的存储版本里，我们坚持使用基本方法而不进行压缩，只添加了一些简单的调整来跳过大范围的非相交ID。</p><p>维持排序好的ID听上去可能很简单，但是实际坚持下来却是不太容易办到的。比如，V2存储引擎将一个哈希值作为ID赋给新的序列，我们无法有效地基于此建立一个排序好的倒排索引。另一个艰巨的任务是在数据被删除或更新时修改磁盘上的索引。通常，最简单的方法是简单地重新计算和重写它们，但是得在保证数据库可查询和一致性的同时执行这一操作。V3版本的存储引擎通过在每个块中分配一个单独的不可变索引来彻底解决这一问题，只能通过压缩时的重写来进行修改。而且，只有整个保存在内存里的可变块的索引才需要被更新。</p><h2 id="基准测试-Benchmark"><a href="#基准测试-Benchmark" class="headerlink" title="基准测试 (Benchmark)"></a>基准测试 (Benchmark)</h2><p>我发起了一个最初开发版本V3存储的基准测试，它是基于从现实世界数据集中提取的大约440万个序列描述符，并生成合成的数据点到对应的序列。这种遍历测试了单独的存储模块，而且对于快速识别性能瓶颈和触发仅在高并发负载下才会遇到的死锁尤为重要。</p><p>在完成概念性的实施之后，基准测试可以在我的Macbook Pro上保持每秒2000万个数据点的写吞吐量 —— 而所有的Chrome Tab和Slack都在持续运行。所以尽管这听上去很棒，但也表明推动这一基准测试没有进一步的价值（或者在这个问题里的随机环境下运行是这样的）。毕竟，这是合成的，这就决定了第一印象不会太好。对比最初的设计目标放大到近20倍的数据量，那么是时候将它嵌入到真正的Prometheus服务器里了，我们可以在上面添加所有只会在更贴近现实的环境里才会遇到的一切实际开销和情景。</p><p>实际上，我们没有可重复的Prometheus基准测试配置，特别是没有允许不同版本的A / B测试。 亡羊补牢为时不晚，<a href="https://github.com/prometheus/prombench" target="_blank" rel="noopener">现在我们有一个了</a>！</p><p>我们的工具允许我们声明式地定义一个基准测试场景，然后将其部署到AWS上的Kubernetes集群。 虽然这不是全面的基准测试的最佳环境，但它肯定能反映出我们的用户基本上会比64内核和128GB内存的专用裸机服务器跑的更好。我们部署了两台Prometheus 1.5.2的服务器（V2存储引擎）以及两台基于2.0开发分支（V3存储引擎）部署的两台Prometheus服务器。每台Prometheus服务都是运行在一台配备有一块SSD的专用服务器上。我们将一个横向可扩展的应用程序部署到了工作节点上并让它对外暴露典型的微服务度量。此外，Kubernetes集群和节点本身也正在被监控。全部配置均由另一个Meta-Prometheus监督，它会监控每台Prometheus服务器的健康性和性能。为了模拟序列分流，微服务会定期地向上扩容和向下缩容，以去除旧的pod，并产生新的pod，从而生成新的序列。 查询负载以“典型”地选择查询来模拟，对每个Prometheus版本的一台服务器执行操作。</p><p>总体而言，缩放和查询负载以及采样频率显著超过了今天Prometheus的生产部署。 例如，我们每15分钟换掉60％的微服务实例以产生序列分流。在现代化的基础设施中这应该每天只会发生1-5次。 这样就能确保我们的V3设计能够处理未来几年的工作负载。 因此，比起一个更为温和的环境，在现在这样的情况下，Prometheus 1.5.2和2.0之间的性能差异更大。我们每秒总共从850个同一时间暴露50万个序列的目标里收集大约11万个样本。</p><p>在放任这一配置运行一段时间后，我们可以来看些数字。我们评估一下前12个小时内两个版本均达到稳定状态的几个指标。</p><blockquote><p>请注意在Prometheus图形界面上的屏幕截图中略微截断的Y轴。</p></blockquote><img src="/hexo-blog/20180110/从头编写一款时间序列数据库/heap_usage.png"><p>堆内存使用（GB）</p><p>内存使用是当今用户最为困扰的资源问题，因为它是相对无法预测的，而且可能会导致进程崩溃。显然，被查询的服务器正在消耗更多的内存，这主要得归咎于查询引擎的开销，而这一点在未来将有望得到优化。总的来说，Prometheus 2.0的内存消耗减少了3-4倍。 大约六个小时后，Prometheus 1.5版本就有一个明显的尖峰，与六个小时的保留边界一致。 由于删除操作成本很高，资源消耗也随之增加。这将在下面的各种其他图表中体现。</p><img src="/hexo-blog/20180110/从头编写一款时间序列数据库/cpu_usage.png"><p>CPU使用率，核心/秒</p><p>CPU使用率的展示也是类似的模式，但是这里面查询服务器与非查询服务器之间的增量差异更为明显。以约0.5个核心/秒的平均值摄取大约110,000个样本/秒，与查询计算所花费的时间周期相比，我们的新存储消耗成本几乎可以忽略不计。 总的来说，新存储需要的CPU资源减少了3-10倍。</p><img src="/hexo-blog/20180110/从头编写一款时间序列数据库/disk_writes.png"><p>磁盘写入MB/秒</p><p>我们磁盘的写入利用率方面展示出了最突出和意想不到的改进。 这清晰地表明了为什么Prometheus 1.5容易造成SSD的耗损。 一旦第一个块被持久化到序列文件里，我们就能看到最开始会有一个飙升的过程，一旦删除然后开始重写，就会出现第二次飙升。令人诧异的是，被查询和非查询的服务器显示出完全不同的资源消耗。</p><p>另一方面，Prometheus 2.0只是以大约每秒一兆字节的写入速度写入到wal文件。 当块被压缩到磁盘时，写入周期性地出现一个尖峰。 这总体上节省了：惊人的97-99％。</p><img src="/hexo-blog/20180110/从头编写一款时间序列数据库/disk_usage.png"><p>磁盘大小（GB）</p><p>与磁盘写入量密切相关的是磁盘空间的总占用量。 由于我们对样本，即我们数据中的大部分组成，使用几乎相同的压缩算法，因此它们也应该是大致相同的。 在一个更稳定的环境中，这样做在很大程度上是合理的，但是因为我们要处理的是高度的序列分流，我们还得考虑每个序列的开销。</p><p>可以看到，Prometheus 1.5在两个版本都抵达稳定状态之前，消耗的存储空间因为保留策略的执行而迅速飙升。而Prometheus 2.0似乎在每个序列的开销都有一个明显的降幅。我们可以很高兴地看到磁盘空间是由预写日志文件线性填充的，并随着其压缩会瞬间下降。 事实上，Prometheus 2.0服务器不完全匹配线性增长的情况也是需要进一步调查的。</p><p>一切看上去都是充满希望的。 剩下的重要部分便是查询延迟。 新的索引应该提高了我们的查找复杂度。 没有实质改变的是这些数据的处理，例如 rate（）函数或聚合。 这些是查询引擎的一部分。</p><img src="/hexo-blog/20180110/从头编写一款时间序列数据库/query_latency.png"><p>99百分位数查询延迟（以秒为单位）</p><p>数据完全符合预期。 在Prometheus 1.5中，随着存储更多的序列，查询延迟会随时间而增加。 一旦保留策略开始执行，旧的系列被删除，它才会平息。 相比之下，Prometheus 2.0从一开始就停留在合理的位置。</p><p>这个数据怎样被收集则需要用户花些心思。对服务器发出的查询请求取决于一个时间范围值和即时查询估计的最佳搭档，压缩或轻或重，以及涉及的序列或多或少等等。它不一定代表查询的真实分布。它也不能代表冷数据的查询性能，我们可以假设所有样本数据实际上总是存储在内存中的热点数据。</p><p>尽管如此，我们仍然可以非常有信心地说，新版存储引擎在序列分流方面整体查询的性能变得非常有弹性，并且在我们高压的基准场景中存储的性能提高了4倍。在一个更加静态的环境里，我们可以假定查询时间主要用于查询引擎本身，而且延迟明显可以被改进到更低值。</p><img src="/hexo-blog/20180110/从头编写一款时间序列数据库/ingestion_rate.png"><p>采样/秒</p><p>最后，快速过一下我们对不同Prometheus服务器的采样率。 我们可以看到，配备V3存储的两台服务器是相同的采样率。几个小时后，它变得不稳定，这是由于基准集群的各个节点高负载造成的失去响应而跟Prometheus实例本身无关。 （这两行2.0的数据完全匹配的事实希望能让人信服）</p><p>即便还有更多可用的CPU和内存资源，Prometheus 1.5.2服务器的采样速率也在大大降低。 序列分流的高压导致它无法收集更大量的数据。</p><p>那么，现在每秒可以抓取的绝对最大样本数是多少？</p><p>我不知道 - 而且也故意不关注这一点。</p><p>影响Prometheus数据流量的因素众多，而这里面没有哪个单个数字能够衡量捕获质量。最大采样率历来是导致基准偏倚的一个指标，它忽略了更重要的方面，如查询性能以及对序列分流的抵御能力。 一些基本测试证实了资源使用线性增长的粗略假设。而这很容易推断出存在什么可能的结果。</p><p>我们的基准测试设置模拟了一个高度动态的环境，它给Prometheus施加的压力比今天大多数现实世界的设定要更大。 结果表明，我们在最优设计目标的基础上运行，而在不是最棒的云服务器上跑着。当然，最终衡量是否成功还是得取决于用户的反馈而不是基准数字。</p><blockquote><p>注意：在撰写本文时，Prometheus 1.6正在开发中，它将允许更可靠地配置最大内存使用量，并且可能会显著降低总体的消耗，略微有利于提高CPU利用率。我并没有进行重复的测试，因为整体的结果仍然变化不大，特别是当面对高度的序列分流时更是如此。</p></blockquote><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Prometheus开始准备应对独立样本的高基数序列及吞吐的处理。 这仍然是一项很具有挑战的任务，但是新的存储引擎似乎使得我们对于超大规模，超收敛的GIFEE基础设施的未来感到满意。恩，它似乎跑的不错。</p><p>配备新版V3存储引擎的第一个Alpha版本的 <a href="https://prometheus.io/blog/2017/04/10/promehteus-20-sneak-peak/" target="_blank" rel="noopener">Prometheus 2.0</a> 已经可用于测试。在这个早期阶段，预计会发生崩溃，死锁和其他错误。</p><p>存储引擎本身的代码可以在<a href="https://github.com/prometheus/tsdb" target="_blank" rel="noopener">单独的项目</a>中找到。对于Prometheus本身而言，这是非常不可知论的，而且它也可以广泛用于一大波正在苦苦寻觅一个有效的本地时间序列数据库存储的应用。</p><blockquote><p>这里得感谢很多人对这项工作的贡献。以下名单不分前后：</p><p>Bojoern Rabenstein和Julius Volz在V2存储引擎上的打磨工作以及他们对于V3的反馈为这新一代设计里所能看到的一切事物奠定了基础。</p><p>Wilhelm Bierbaum持续不断地意见和见解为新一代的设计做出了重大贡献。Brian Brazil源源不断的反馈也确保我们最终采用语义上合理的方案。与Peter Bourgon的精辟讨论验证了新的设计，并且造就了这篇文章。</p><p>当然也别忘了我所在的CoreOS整个团队和公司本身对这项工作的支持和赞助。感谢那些能够耐心听我一次又一次地扯着SSD，浮点数和序列化格式的每一位同学。</p></blockquote><p>原文链接：<a href="https://fabxc.org/blog/2017-04-10-writing-a-tsdb/" target="_blank" rel="noopener">writing-a-time-series-database-from-scratch</a><br>译文链接：<a href="http://dockone.io/article/2300" target="_blank" rel="noopener">从头编写一款时间序列数据库</a> （翻译：Colstuwjx）</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;本文转自 &lt;a href=&quot;http://dockone.io/article/2300&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;从头编写一款时间序列数据库&lt;/a&gt; （翻译：Colstuwjx），请支持原作者。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我从事监控方面的工作。尤其是专注在 &lt;a href=&quot;https://prometheus.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Prometheus&lt;/a&gt;，一款内置了自己定制的时间序列数据库的监控系统，以及它和 &lt;a href=&quot;https://kubernetes.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kubernetes&lt;/a&gt; 的集成工作。&lt;/p&gt;&lt;p&gt;从很多方面来说，Kubernetes 表现出了一切 Prometheus 专门设计的东西。它使得持续部署，自动扩缩，以及高度动态环境的其他功能更易于实现。它的查询语言和操作模型，还有许多其他概念方面的决策使得 Prometheus 尤其适合这样的环境。然而，如果被监控的工作负载变得更加显著动态的话，这也会给监控系统本身带来新的压力。基于这一点的考虑，与其再次回顾 Prometheus 已经很好解决的问题，还不如专注于在这样一个高度动态或短生命周期服务的环境里提高它的性能。&lt;/p&gt;&lt;p&gt;Prometheus 的存储层在历史上有着惊人的性能表现，一个单台服务器每秒可以摄取多达 100 万个采样，数百万个时间序列，同时仅占用令人惊叹的少量磁盘空间。尽管当前的存储已经给我们提供了不错的服务，笔者构思了一个新设计的存储子系统用来纠正现有解决方案的一些短板，并且可以用来配备支撑下一代的集群规模。&lt;/p&gt;
    
    </summary>
    
    
      <category term="转载" scheme="http://whypro.github.io/hexo-blog/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="Kubernetes" scheme="http://whypro.github.io/hexo-blog/tags/Kubernetes/"/>
    
      <category term="K8S" scheme="http://whypro.github.io/hexo-blog/tags/K8S/"/>
    
      <category term="Prometheus" scheme="http://whypro.github.io/hexo-blog/tags/Prometheus/"/>
    
  </entry>
  
</feed>
